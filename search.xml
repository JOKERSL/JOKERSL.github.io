<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[事件的传递和响应机制]]></title>
    <url>%2F2018%2F09%2F12%2F%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E9%80%92%E5%92%8C%E5%93%8D%E5%BA%94%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[事件的生命周期 事件的产生和传递（事件如何从父控件传递到子控件并寻找到最合适的view、寻找最合适的view的底层实现、拦截事件的处理）-&gt;找到最合适的view后事件的处理（touches方法的重写，也就是事件的响应） ​ 其中重点和难点是： 1.如何寻找最合适的view 2.寻找最合适的view的底层实现（hitTest:withEvent:底层实现） iOS中的事件iOS中的事件可以分为3大类型： 触摸事件 加速计事件 远程控制事件 本文只讨论接触事件 响应者对象(UIResponder)学习触摸事件首先要了解一个比较重要的概念-响应者对象（UIResponder）。 在iOS中不是任何对象都能处理事件，只有继承了UIResponder的对象才能接受并处理事件，我们称之为“响应者对象”。以下都是继承自UIResponder的，所以都能接收并处理事件。 UIApplication UIViewController UIView 那么为什么继承自UIResponder的类就能够接收并处理事件呢？ 因为UIResponder中提供了以下4个对象方法来处理触摸事件。 12345678910111213141516UIResponder内部提供了以下方法来处理事件触摸事件- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;加速计事件- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event;- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event;- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event;远程控制事件- (void)remoteControlReceivedWithEvent:(UIEvent *)event;作者：VV木公子链接：https://www.jianshu.com/p/2e074db792ba來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 iOS中的事件的产生和传递事件的产生发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中,为什么是队列而不是栈？因为队列的特点是FIFO，即先进先出，先产生的事件先处理才符合常理，所以把事件添加到队列。 UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）。 主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个事件处理过程的第一步。找到合适的视图控件后，就会调用视图控件的touches方法来作具体的事件处理。 事件的传递 触摸事件的传递是从父控件传递到子控件 也就是UIApplication-&gt;window-&gt;寻找处理事件最合适的view 注 意: 如果父控件不能接受触摸事件，那么子控件就不可能接收到触摸事件 应用如何找到最合适的控件来处理事件？1.首先判断主窗口（keyWindow）自己是否能接受触摸事件 2.判断触摸点是否在自己身上 3.子控件数组中从后往前遍历子控件，重复前面的两个步骤（所谓从后往前遍历子控件，就是首先查找子控件数组中最后一个元素，然后执行1、2步骤） 4.view，比如叫做fitView，那么会把这个事件交给这个fitView，再遍历这个fitView的子控件，直至没有更合适的view为止。 5.如果没有符合条件的子控件，那么就认为自己最合适处理这个事件，也就是自己是最合适的view。 UIView不能接收触摸事件的三种情况： 不允许交互：userInteractionEnabled = NO 隐藏：如果把父控件隐藏，那么子控件也会隐藏，隐藏的控件不能接受事件 透明度：如果设置一个控件的透明度&lt;0.01，会直接影响子控件的透明度。alpha：0.0~0.01为透明。 注 意:默认UIImageView不能接受触摸事件，因为不允许交互，即userInteractionEnabled = NO。所以如果希望UIImageView可以交互，需要设置UIImageView的userInteractionEnabled = YES。 总结一下1.点击一个UIView或产生一个触摸事件A，这个触摸事件A会被添加到由UIApplication管理的事件队列中（即，首先接收到事件的是UIApplication）。2.UIApplication会从事件对列中取出最前面的事件（此处假设为触摸事件A），把事件A传递给应用程序的主窗口（keyWindow）。3.窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件。（至此，第一步已完成） (重难点）如何寻找最合适的view应用如何找到最合适的控件来处理事件？1.首先判断主窗口（keyWindow）自己是否能接受触摸事件2.触摸点是否在自己身上3.从后往前遍历子控件，重复前面的两个步骤（首先查找数组中最后一个元素）4.如果没有符合条件的子控件，那么就认为自己最合适处理 详述：1.主窗口接收到应用程序传递过来的事件后，首先判断自己能否接手触摸事件。如果能，那么在判断触摸点在不在窗口自己身上 2.如果触摸点也在窗口身上，那么窗口会从后往前遍历自己的子控件（遍历自己的子控件只是为了寻找出来最合适的view） 3.遍历到每一个子控件后，又会重复上面的两个步骤（传递事件给子控件，1.判断子控件能否接受事件，2.点在不在子控件上） 4.如此循环遍历子控件，直到找到最合适的view，如果没有更合适的子控件，那么自己就成为最合适的view。找到最合适的view后，就会调用该view的touches方法处理具体的事件。所以，只有找到最合适的view，把事件传递给最合适的view后，才会调用touches方法进行接下来的事件处理。找不到最合适的view，就不会调用touches方法进行事件处理。注意：之所以会采取从后往前遍历子控件的方式寻找最合适的view只是为了做一些循环优化。因为相比较之下，后添加的view在上面，降低循环次数。 寻找最合适的view底层剖析两个重要的方法：hitTest:withEvent:方法pointInside方法 3.3.1.1.hitTest：withEvent：方法什么时候调用？ 只要事件一传递给一个控件,这个控件就会调用他自己的hitTest：withEvent：方法 作用 寻找并返回最合适的view(能够响应事件的那个最合适的view) 注 意：不管这个控件能不能处理事件，也不管触摸点在不在这个控件上，事件都会先传递给这个控件，随后再调用hitTest:withEvent:方法 拦截事件的处理 正因为hitTest：withEvent：方法可以返回最合适的view，所以可以通过重写hitTest：withEvent：方法，返回指定的view作为最合适的view。 不管点击哪里，最合适的view都是hitTest：withEvent：方法中返回的那个view。 通过重写hitTest：withEvent：，就可以拦截事件的传递过程，想让谁处理事件谁就处理事件。 事件传递给谁，就会调用谁的hitTest:withEvent:方法。注 意：如果hitTest:withEvent:方法中返回nil，那么调用该方法的控件本身和其子控件都不是最合适的view，也就是在自己身上没有找到更合适的view。那么最合适的view就是该控件的父控件。所以事件的传递顺序是这样的： 产生触摸事件-&gt;UIApplication事件队列-&gt;[UIWindow hitTest:withEvent:]-&gt;返回更合适的view-&gt;[子控件 hitTest:withEvent:]-&gt;返回最合适的view 事件传递给窗口或控件的后，就调用hitTest:withEvent:方法寻找更合适的view。所以是，先传递事件，再根据事件在自己身上找更合适的view。不管子控件是不是最合适的view，系统默认都要先把事件传递给子控件，经过子控件调用子控件自己的hitTest:withEvent:方法验证后才知道有没有更合适的view。即便父控件是最合适的view了，子控件的hitTest:withEvent:方法还是会调用，不然怎么知道有没有更合适的！即，如果确定最终父控件是最合适的view，那么该父控件的子控件的hitTest:withEvent:方法也是会被调用的。技巧：想让谁成为最合适的view就重写谁自己的父控件的hitTest:withEvent:方法返回指定的子控件，或者重写自己的hitTest:withEvent:方法 return self。但是，建议在父控件的hitTest:withEvent:中返回子控件作为最合适的view！ 原因在于在自己的hitTest:withEvent:方法中返回自己有时候会出现问题。因为会存在这么一种情况：当遍历子控件时，如果触摸点不在子控件A自己身上而是在子控件B身上，还要要求返回子控件A作为最合适的view，采用返回自己的方法可能会导致还没有来得及遍历A自己，就有可能已经遍历了点真正所在的view，也就是B。这就导致了返回的不是自己而是触摸点真正所在的view。所以还是建议在父控件的hitTest:withEvent:中返回子控件作为最合适的view！例如：whiteView有redView和greenView两个子控件。redView先添加，greenView后添加。如果要求无论点击那里都要让redView作为最合适的view（把事件交给redView来处理）那么只能在whiteView的hitTest:withEvent:方法中return self.subViews[0];这种情况下在redView的hitTest:withEvent:方法中return self;是不好使的！ 123456789101112131415161718192021// 这里redView是whiteView的第0个子控件#import &quot;redView.h&quot;@implementation redView- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; return self;&#125;- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;red-touch&quot;);&#125;@end// 或者#import &quot;whiteView.h&quot;@implementation whiteView- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; return self.subviews[0];&#125;- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;white-touch&quot;);&#125;@end 特殊情况：谁都不能处理事件，窗口也不能处理。 重写window的hitTest：withEvent：方法return nil 只能有窗口处理事件。 控制器的view的hitTest：withEvent：方法return nil或者window的hitTest：withEvent：方法return self return nil的含义：hitTest：withEvent：中return nil的意思是调用当前hitTest：withEvent：方法的view不是合适的view，子控件也不是合适的view。如果同级的兄弟控件也没有合适的view，那么最合适的view就是父控件。 寻找最合适的view底层剖析之hitTest：withEvent：方法底层做法/** hitTest:withEvent:方法底层实现**/ 12345678910111213141516171819202122232425262728293031323334353637383940#import &quot;WSWindow.h&quot;@implementation WSWindow// 什么时候调用:只要事件一传递给一个控件，那么这个控件就会调用自己的这个方法// 作用:寻找并返回最合适的view// UIApplication -&gt; [UIWindow hitTest:withEvent:]寻找最合适的view告诉系统// point:当前手指触摸的点// point:是方法调用者坐标系上的点- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; // 1.判断下窗口能否接收事件 if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt;= 0.01) return nil; // 2.判断下点在不在窗口上 // 不在窗口上 if ([self pointInside:point withEvent:event] == NO) return nil; // 3.从后往前遍历子控件数组 int count = (int)self.subviews.count; for (int i = count - 1; i &gt;= 0; i--) &#123; // 获取子控件 UIView *childView = self.subviews[i]; // 坐标系的转换,把窗口上的点转换为子控件上的点 // 把自己控件上的点转换成子控件上的点 CGPoint childP = [self convertPoint:point toView:childView]; UIView *fitView = [childView hitTest:childP withEvent:event]; if (fitView) &#123; // 如果能找到最合适的view return fitView; &#125; &#125; // 4.没有找到更合适的view，也就是没有比自己更合适的view return self; &#125; // 作用:判断下传入过来的点在不在方法调用者的坐标系上 // point:是方法调用者坐标系上的点 //- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event //&#123; // return NO; //&#125; - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;%s&quot;,__func__); &#125; @end hit:withEvent:方法底层会调用pointInside:withEvent:方法判断点在不在方法调用者的坐标系上。 3.3.1.2.pointInside:withEvent:方法pointInside:withEvent:方法判断点在不在当前view上（方法调用者的坐标系上）如果返回YES，代表点在方法调用者的坐标系上;返回NO代表点不在方法调用者的坐标系上，那么方法调用者也就不能处理事件。 3.3.2.练习屏幕上现在有一个viewA，viewA有一个subView叫做viewB，要求触摸viewB时,viewB会响应事件，而触摸viewA本身，不会响应该事件。如何实现？ 1234567- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; UIView *view = [super hitTest:point withEvent:event]; if (view == self) &#123; return nil; &#125; return view;&#125; 事件的响应触摸事件处理的整体过程1&gt;用户点击屏幕后产生的一个触摸事件，经过一系列的传递过程后，会找到最合适的视图控件来处理这个事件2&gt;找到最合适的视图控件后，就会调用控件的touches方法来作具体的事件处理touchesBegan…touchesMoved…touchedEnded…3&gt;这些touches方法的默认做法是将事件顺着响应者链条向上传递（也就是touch方法默认不处理事件，只传递事件），将事件交给上一个响应者进行处理 响应者链条示意图响应者链条：在iOS程序中无论是最后面的UIWindow还是最前面的某个按钮，它们的摆放是有前后关系的，一个控件可以放到另一个控件上面或下面，那么用户点击某个控件时是触发上面的控件还是下面的控件呢，这种先后关系构成一个链条就叫“响应者链”。也可以说，响应者链是由多个响应者对象连接起来的链条。在iOS中响应者链的关系可以用下图表示： 响应者对象： 作用： 如何判断上一个响应者 1&gt; 如果当前这个view是控制器的view,那么控制器就是上一个响应者 2&gt; 如果当前这个view不是控制器的view,那么父控件就是上一个响应者 响应者链的事件传递过程: 1&gt;如果当前view是控制器的view，那么控制器就是上一个响应者，事件就传递给控制器；如果当前view不是控制器的view，那么父视图就是当前view的上一个响应者，事件就传递给它的父视图 2&gt;在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理 3&gt;如果window对象也不处理，则其将事件或消息传递给UIApplication对象 4&gt;如果UIApplication也不能处理该事件或消息，则将其丢弃 事件处理的整个流程总结： 1.触摸屏幕产生触摸事件后，触摸事件会被添加到由UIApplication管理的事件队列中（即，首先接收到事件的是UIApplication）。 2.UIApplication会从事件队列中取出最前面的事件，把事件传递给应用程序的主窗口（keyWindow）。 3.主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件。（至此，第一步已完成) 4.最合适的view会调用自己的touches方法处理事件 5.touches默认做法是把事件顺着响应者链条向上抛。touches的默认做法： 1234567891011#import &quot;WSView.h&quot;@implementation WSView //只要点击控件,就会调用touchBegin,如果没有重写这个方法,自己处理不了触摸事件// 上一个响应者可能是父控件- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; // 默认会把事件传递给上一个响应者,上一个响应者是父控件,交给父控件处理[super touchesBegan:touches withEvent:event]; // 注意不是调用父控件的touches方法，而是调用父类的touches方法// super是父类 superview是父控件 &#125;@end 事件的传递与响应：1、当一个事件发生后，事件会从父控件传给子控件，也就是说由UIApplication -&gt; UIWindow -&gt; UIView -&gt; initial view,以上就是事件的传递，也就是寻找最合适的view的过程。 2、接下来是事件的响应。首先看initial view能否处理这个事件，如果不能则会将事件传递给其上级视图（inital view的superView）；如果上级视图仍然无法处理则会继续往上传递；一直传递到视图控制器view controller，首先判断视图控制器的根视图view是否能处理此事件；如果不能则接着判断该视图控制器能否处理此事件，如果还是不能则继续向上传 递；（对于第二个图视图控制器本身还在另一个视图控制器中，则继续交给父视图控制器的根视图，如果根视图不能处理则交给父视图控制器处理）；一直到 window，如果window还是不能处理此事件则继续交给application处理，如果最后application还是不能处理此事件则将其丢弃 3、在事件的响应中，如果某个控件实现了touches…方法，则这个事件将由该控件来接受，如果调用了[supertouches….];就会将事件顺着响应者链条往上传递，传递给上一个响应者；接着就会调用上一个响应者的touches….方法 如何做到一个事件多个对象处理：因为系统默认做法是把事件上抛给父控件，所以可以通过重写自己的touches方法和父控件的touches方法来达到一个事件多个对象处理的目的。 123456- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; // 1.自己先处理事件...NSLog(@&quot;do somthing...&quot;);// 2.再调用系统的默认做法，再把事件交给上一个响应者处理[super touchesBegan:touches withEvent:event]; &#125; 事件的传递和响应的区别：事件的传递是从上到下（父控件到子控件），事件的响应是从下到上（顺着响应者链条向上传递：子控件到父控件。 转自VV木公子（简书作者）]]></content>
      <categories>
        <category>UI视图</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[UITableView相关]]></title>
    <url>%2F2018%2F09%2F11%2FUITableView%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[UITableView性能优化当获取到 API JSON 数据后，我会把每条 Cell 需要的数据都在后台线程计算并封装为一个布局对象 CellLayout。CellLayout 包含所有文本的 CoreText 排版结果、Cell 内部每个控件的高度、Cell 的整体高度。每个 CellLayout 的内存占用并不多，所以当生成后，可以全部缓存到内存，以供稍后使用。这样，TableView 在请求各个高度函数时，不会消耗任何多余计算量；当把 CellLayout 设置到 Cell 内部时，Cell 内部也不用再计算布局了。 缓存高度对于通常的 TableView 来说，提前在后台计算好布局结果是非常重要的一个性能优化点。为了达到最高性能，你可能需要牺牲一些开发速度，不要用 Autolayout 等技术，少用 UILabel 等文本控件。但如果你对性能的要求并不那么高，可以尝试用 TableView 的预估高度的功能，并把每个 Cell 高度缓存下来。这里有个来自百度知道团队的开源项目可以很方便的帮你实现这一点：FDTemplateLayoutCell。 tableviewcell高度缓存具体实现方式 预渲染微博的头像在某次改版中换成了圆形，所以我也跟进了一下。当头像下载下来后，我会在后台线程将头像预先渲染为圆形并单独保存到一个 ImageCache 中去。 对于 TableView 来说，Cell 内容的离屏渲染会带来较大的 GPU 消耗。在 Twitter Demo 中，我为了图省事儿用到了不少 layer 的圆角属性，你可以在低性能的设备（比如 iPad 3）上快速滑动一下这个列表，能感受到虽然列表并没有较大的卡顿，但是整体的平均帧数降了下来。用 Instument 查看时能够看到 GPU 已经满负荷运转，而 CPU 却比较清闲。为了避免离屏渲染，你应当尽量避免使用 layer 的 border、corner、shadow、mask 等技术，而尽量在后台线程预先绘制好对应内容。 离屏渲染​ 在使用圆角、阴影和遮罩等视图功能的时候，图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制，所有就需要在屏幕外的上下文中渲染，即离屏渲染。 离屏渲染产生原因离屏渲染之所以会特别消耗性能，是因为要创建一个屏幕外的缓冲区，然后从当屏缓冲区切换到屏幕外的缓冲区，然后再完成渲染；其中，创建缓冲区和切换上下文最消耗性能，而绘制其实不是性能损耗的主要原因。 设置了以下属性时，就会触发离屏绘制： shouldRasterize（光栅化） masks（遮罩） shadows（阴影） edge antialiasing（抗锯齿） group opacity（不透明） 复杂形状设置圆角等 渐变 光栅化光栅化概念:将图转化为一个个栅格组成的图象。 光栅化特点:每个元素对应帧缓冲区中的一像素。 ​ shouldRasterize = YES在其他属性触发离屏渲染的同时,会将光栅化后的内容缓存起来,如果对应的layer及其sublayers没有发生改变,在下一帧的时候可以直接复用。shouldRasterize = YES,这将隐式的创建一个位图,各种阴影遮罩等效果也会保存到位图中并缓存起来,从而减少渲染的频度 当你使用光栅化时,你可以开启“Color Hits Green and Misses Red”来检查该场景下光栅化操作是否是一个好的选择。绿色表示缓存被复用,红色表示缓存在被重复创建。 如果光栅化的层变红得太频繁那么光栅化对优化可能没有多少用处。位图缓存从内存中删除又重新创建得太过频繁,红色表明缓存重建得太迟。可以针对性的选择某个较小而较深的层结构进行光栅化,来尝试减少渲染时间。 我们经常的TableViewCell,因为TableViewCell的重绘是很频繁的(因为Cell的复用),如果Cell的内容不断变化,则Cell需要不断重绘,如果此时设置了cell.layer可光栅化。则会造成大量的离屏渲染,降低图形性能。 有时候我们可以把那些需要屏幕外绘制的图层开启光栅化以作为一个优化方式,前提是这些图层并不会被频繁地重绘。 针对光栅化处理 12345678910//离屏渲染 - 异步绘制 耗电self.layer.drawsAsynchronously = true //栅格化 - 异步绘制之后 ，会生成一张独立的图片 cell 在屏幕上滚动的时候，本质上滚动的是这张图片 //cell 优化，要尽量减少图层的数量，想当于只有一层//停止滚动之后，可以接受监听self.layer.shouldRasterize = true //使用 “栅格化” 必须指定分辨率self.layer.rasterizationScale = UIScreen.main.scale 阴影处理 12// 指定阴影曲线，防止阴影效果带来的离屏渲染 imageView.layer.shadowPath = UIBezierPath(rect: imageView.bounds).cgPath ​ 遮罩masks(遮罩) mask是layer的一个属性. 当透明度改变的时候,这个 mask 就是覆盖上去的那个阴影。该层的layer的alpha决定了多少层背景跟内容通过并显示,完全或者部分不透明的像素允许潜在的内容 通过并显示。 默认是nil,当配置一个遮罩的时候,记得设置遮罩的大小、位置。已确保跟盖图层对齐。如果你想给这个属性赋值,前提是必须没有 superLayer,如果有superLayer,这个行为则是无效的。 shadows(阴影)在项目中,当我们想要设置View的阴影效果时,可以通过shadow*相关方法实现,如: self.layer.shadowOffset = CGSizeMake(4, -2); self.layer.shadowOpacity = 0.5; self.layer.shadowColor = [[UIColor blackColor] colorWithAlphaComponent:0.5].CGColor; shadows可以给视图周边添加阴影,当给一些滑动视图加阴影时,您可能会注意到在动画不是很流畅,有卡顿。这是因为计算阴影需要Core Animation做一个离屏渲染,以View准确的形状确定清楚如何呈现其阴影。 ####屏幕渲染有如下三种 GPU中的屏幕渲染： 1、On-Screen Rendering 意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行 2、Off-Screen Rendering 意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作 3、CPU中的离屏渲染（特殊离屏渲染，即不在GPU中的渲染） 如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染 切圆角优化切圆角是开发app过程中经常会用到的功能，但是使用不同的方式，性能损耗也会不同，下面会介绍3种切圆角的方法；其中，方法三的性能相对最好。 方法一使用cornerRadius进行切圆角，在iOS9之前会产生离屏渲染，比较消耗性能，而之后系统做了优化，则不会产生离屏渲染，但是操作最简单 12iv.layer.cornerRadius = 30;iv.layer.masksToBounds = YES; 方法二利用mask设置圆角，利用的是UIBezierPath和CAShapeLayer来完成 1234CAShapeLayer *mask1 = [[CAShapeLayer alloc] init];mask1.opacity = 0.5;mask1.path = [UIBezierPath bezierPathWithOvalInRect:iv.bounds].CGPath;iv.layer.mask = mask1; 方法三利用CoreGraphics画一个圆形上下文，然后把图片绘制上去，得到一个圆形的图片，达到切圆角的目的。 12345678910111213141516171819- (UIImage *)drawCircleImage:(UIImage*)image&#123; CGFloat side = MIN(image.size.width, image.size.height); UIGraphicsBeginImageContextWithOptions(CGSizeMake(side, side), false, [UIScreen mainScreen].scale); CGContextAddPath(UIGraphicsGetCurrentContext(), [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, side, side)].CGPath); CGContextClip(UIGraphicsGetCurrentContext()); CGFloat marginX = -(image.size.width - side) * 0.5; CGFloat marginY = -(image.size.height - side) * 0.5; [image drawInRect:CGRectMake(marginX, marginY, image.size.width, image.size.height)]; CGContextDrawPath(UIGraphicsGetCurrentContext(), kCGPathFillStroke); UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return newImage;&#125; 异步绘制当想进一步优化tableview性能时可以考虑异步绘制cell及文本控件等。大神的YYAsyncLayer实现了异步绘制的控件。 UITableView优化总结UITableView的优化主要从三个方面入手： 123提前计算并缓存好高度（布局），因为heightForRowAtIndexPath:是调用最频繁的方法；异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口；滑动时按需加载，这个在大量图片展示，网络加载的时候很管用！（SDWebImage已经实现异步加载，配合这条性能杠杠的）。 除了上面最主要的三个方面外，还有很多几乎大伙都很熟知的优化点： 1234567正确使用reuseIdentifier来重用Cells尽量使所有的view opaque，包括Cell自身尽量少用或不用透明图层如果Cell内现实的内容来自web，使用异步加载，缓存请求结果减少subviews的数量在heightForRowAtIndexPath:中尽量不使用cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果尽量少用addView给Cell动态添加View，可以初始化时就添加，然后通过hide来控制是否显示 参考: ibiremeiOS 保持界面流畅的技巧 mo_xiao_moUITableView的优化技巧－异步绘制Cell iOS_小松哥UITableView自动计算cell高度并缓存，再也不用管高度啦]]></content>
      <categories>
        <category>UI视图</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS runtime应用：关联对象]]></title>
    <url>%2F2018%2F01%2F23%2FiOS-runtime%E5%BA%94%E7%94%A8%EF%BC%9A%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[前言给已有类添加方法使用Category就可以了，但如果向分类里添加一个或多个属性的话会报错，使用属性不能正确创建实例及存取方法。 但是我们可以实现runtime的Associated Objects(关联对象)，它可以让对象在运行时关联任何值。 runtime中提供给我们的方法：123456//关联对象void objc_setAssociatedObject(id object,const void *key,id value,objc_AssociationPolicy policy);//获取关联的对象id objc_getAssociatedObject(id object,const void *key);//移除关联的对象void objc_removeAssociatedObjects(id object); 变量说明：1234id object:被关联的对象const void *key:关联的key，要求唯一id value:关联的对象Objc_AssociationPolicy poliy:内存管理策略 Objc_AssociationPolicy policy的enum值有:1234567891011typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123; OBJC_ASSOCIATION_ASSIGN = 0, /**&lt; Specifies a weak reference to the associated object. */ OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object. * The association is not made atomically. */ OBJC_ASSOCIATION_COPY_NONATOMIC = 3, /**&lt; Specifies that the associated object is copied. * The association is not made atomically. */ OBJC_ASSOCIATION_RETAIN = 01401, /**&lt; Specifies a strong reference to the associated object. * The association is made atomically. */ OBJC_ASSOCIATION_COPY = 01403 /**&lt; Specifies that the associated object is copied. * The association is made atomically. */&#125;; 不同的objc_AssociationPolicy对应了不同的属性修饰符。 Objc_AssociationPolicy应用:UIButton扩展之动态添加属性.h文件 1234567#import &lt;UIKit/UIKit.h&gt;typedef void (^block)(void);@interface UIButton (Block)@property(nonatomic,assign) NSString *name;@end .m文件 1234567891011121314151617#import &lt;objc/runtime.h&gt;static const char myKey;@implementation UIButton (Block)- (void)setName:(NSString *)name&#123; //关联对象 objc_setAssociatedObject(self, &amp;myKey, name, OBJC_ASSOCIATION_COPY_NONATOMIC);&#125;- (NSString *)name&#123; //获取关联对象 return objc_getAssociatedObject(self, &amp;myKey);&#125;@end Viewcontroller.m 123456789101112131415161718192021222324#import &quot;ViewController.h&quot;#import &quot;UIButton+Block.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom]; [self.view addSubview:btn]; btn.backgroundColor = [UIColor redColor]; btn.frame = CGRectMake(100, 100, 100, 50); btn.name = @&quot;darling&quot;; [btn addTarget:self action:@selector(message:) forControlEvents:UIControlEventTouchUpInside ]; // Do any additional setup after loading the view, typically from a nib.&#125;- (void)message:(UIButton *)btn&#123; NSLog(@&quot;name = %@&quot;,btn.name);&#125; UIButton扩展之动态添加方法.h文件 123456#import &lt;UIKit/UIKit.h&gt;typedef void (^btnBlock)(void);@interface UIButton (Block)- (void)handelWithBlock:(btnBlock)block;@end .m文件 12345678910111213141516#import &quot;UIButton+Block.h&quot;#import &lt;objc/runtime.h&gt;static const char myKey;@implementation UIButton (Block)- (void)handelWithBlock:(block)block&#123; if (block) &#123; objc_setAssociatedObject(self, &amp;myKey, block, OBJC_ASSOCIATION_COPY_NONATOMIC); &#125; [self addTarget:self action:@selector(btnAction) forControlEvents:UIControlEventTouchUpInside];&#125;- (void)btnAction&#123; block block = objc_getAssociatedObject(self, &amp;myKey); block();&#125;@end ViewController.m文件 1234567891011121314151617181920#import &quot;ViewController.h&quot;#import &quot;UIButton+Block.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom]; [self.view addSubview:btn]; btn.backgroundColor = [UIColor redColor]; btn.frame = CGRectMake(100, 100, 100, 50); [btn handelWithBlock:^&#123; NSLog(@&quot;darling&quot;); &#125;]; // Do any additional setup after loading the view, typically from a nib.&#125; 参考文献 objc_setAssociatedObject与Block的简单使用 objc_setAssociatedObject/objc_getAssociatedObject]]></content>
      <categories>
        <category>runtime应用</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS DES总结]]></title>
    <url>%2F2018%2F01%2F15%2FiOS-DES%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[iOS中使用DES加密总结 常见的对称加密有:DES、3DES、RC4、AES等；加密算法都有几个共同的特点：1.秘钥长度；2.加密模式；3.块加密算法里的填充区分；以下是我对做项目时遇到的问题所做的小结 1234567891011ccStatus = CCCrypt(encryptOperation, kCCAlgorithmDES, kCCOptionPKCS7Padding|kCCOptionECBMode, vkey, kCCKeySizeDES, iv, dataIn, dataInLength, (void *)dataOut, dataOutAvailable, &amp;dataOutMoved); 第一个参数encryptOperation：告诉函数加密还是解密 第二个参数kCCAlgorithmDES：使用DES加密 第三个参数 kCCOptionPKCS7Padding|kCCOptionECBMode使用ECB加密模式和PKCS7Padding填充模式，如果使用kCCOptionPKCS7Padding就代表使用CBC加密模式并且使用PKCS7Padding的填充模式。 在DES中加密数据包单位长度是8字节，在8自己的情况下PKCS7Padding等价于PKCS5Padding。 后台大哥给了一个线上加密的地址让我对。 http://tool.chacuo.net/cryptdes 调试了半天原来是我自己的加密模式不对，使用了CBC模式，而后台用的是ECB。 参考资料： http://blog.csdn.net/u010184533/article/details/38975871]]></content>
      <categories>
        <category>加密</category>
      </categories>
  </entry>
</search>
