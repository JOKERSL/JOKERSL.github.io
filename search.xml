<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS runtime应用：关联对象]]></title>
    <url>%2F2018%2F01%2F23%2FiOS-runtime%E5%BA%94%E7%94%A8%EF%BC%9A%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[前言给已有类添加方法使用Category就可以了，但如果向分类里添加一个或多个属性的话会报错，使用属性不能正确创建实例及存取方法。 但是我们可以实现runtime的Associated Objects(关联对象)，它可以让对象在运行时关联任何值。 runtime中提供给我们的方法：123456//关联对象void objc_setAssociatedObject(id object,const void *key,id value,objc_AssociationPolicy policy);//获取关联的对象id objc_getAssociatedObject(id object,const void *key);//移除关联的对象void objc_removeAssociatedObjects(id object); 变量说明：1234id object:被关联的对象const void *key:关联的key，要求唯一id value:关联的对象Objc_AssociationPolicy poliy:内存管理策略 Objc_AssociationPolicy policy的enum值有:1234567891011typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123; OBJC_ASSOCIATION_ASSIGN = 0, /**&lt; Specifies a weak reference to the associated object. */ OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object. * The association is not made atomically. */ OBJC_ASSOCIATION_COPY_NONATOMIC = 3, /**&lt; Specifies that the associated object is copied. * The association is not made atomically. */ OBJC_ASSOCIATION_RETAIN = 01401, /**&lt; Specifies a strong reference to the associated object. * The association is made atomically. */ OBJC_ASSOCIATION_COPY = 01403 /**&lt; Specifies that the associated object is copied. * The association is made atomically. */&#125;; 不同的objc_AssociationPolicy对应了不同的属性修饰符。 Objc_AssociationPolicy应用:UIButton扩展之动态添加属性.h文件 1234567#import &lt;UIKit/UIKit.h&gt;typedef void (^block)(void);@interface UIButton (Block)@property(nonatomic,assign) NSString *name;@end .m文件 1234567891011121314151617#import &lt;objc/runtime.h&gt;static const char myKey;@implementation UIButton (Block)- (void)setName:(NSString *)name&#123; //关联对象 objc_setAssociatedObject(self, &amp;myKey, name, OBJC_ASSOCIATION_COPY_NONATOMIC);&#125;- (NSString *)name&#123; //获取关联对象 return objc_getAssociatedObject(self, &amp;myKey);&#125;@end Viewcontroller.m 123456789101112131415161718192021222324#import &quot;ViewController.h&quot;#import &quot;UIButton+Block.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom]; [self.view addSubview:btn]; btn.backgroundColor = [UIColor redColor]; btn.frame = CGRectMake(100, 100, 100, 50); btn.name = @&quot;darling&quot;; [btn addTarget:self action:@selector(message:) forControlEvents:UIControlEventTouchUpInside ]; // Do any additional setup after loading the view, typically from a nib.&#125;- (void)message:(UIButton *)btn&#123; NSLog(@&quot;name = %@&quot;,btn.name);&#125; UIButton扩展之动态添加方法.h文件 123456#import &lt;UIKit/UIKit.h&gt;typedef void (^btnBlock)(void);@interface UIButton (Block)- (void)handelWithBlock:(btnBlock)block;@end .m文件 12345678910111213141516#import &quot;UIButton+Block.h&quot;#import &lt;objc/runtime.h&gt;static const char myKey;@implementation UIButton (Block)- (void)handelWithBlock:(block)block&#123; if (block) &#123; objc_setAssociatedObject(self, &amp;myKey, block, OBJC_ASSOCIATION_COPY_NONATOMIC); &#125; [self addTarget:self action:@selector(btnAction) forControlEvents:UIControlEventTouchUpInside];&#125;- (void)btnAction&#123; block block = objc_getAssociatedObject(self, &amp;myKey); block();&#125;@end ViewController.m文件 1234567891011121314151617181920#import &quot;ViewController.h&quot;#import &quot;UIButton+Block.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom]; [self.view addSubview:btn]; btn.backgroundColor = [UIColor redColor]; btn.frame = CGRectMake(100, 100, 100, 50); [btn handelWithBlock:^&#123; NSLog(@&quot;darling&quot;); &#125;]; // Do any additional setup after loading the view, typically from a nib.&#125; 参考文献 objc_setAssociatedObject与Block的简单使用 objc_setAssociatedObject/objc_getAssociatedObject]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS DES总结]]></title>
    <url>%2F2018%2F01%2F15%2FiOS-DES%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[iOS中使用DES加密总结 常见的对称加密有:DES、3DES、RC4、AES等；加密算法都有几个共同的特点：1.秘钥长度；2.加密模式；3.块加密算法里的填充区分；以下是我对做项目时遇到的问题所做的小结 1234567891011ccStatus = CCCrypt(encryptOperation, kCCAlgorithmDES, kCCOptionPKCS7Padding|kCCOptionECBMode, vkey, kCCKeySizeDES, iv, dataIn, dataInLength, (void *)dataOut, dataOutAvailable, &amp;dataOutMoved); 第一个参数encryptOperation：告诉函数加密还是解密 第二个参数kCCAlgorithmDES：使用DES加密 第三个参数 kCCOptionPKCS7Padding|kCCOptionECBMode使用ECB加密模式和PKCS7Padding填充模式，如果使用kCCOptionPKCS7Padding就代表使用CBC加密模式并且使用PKCS7Padding的填充模式。 在DES中加密数据包单位长度是8字节，在8自己的情况下PKCS7Padding等价于PKCS5Padding。 后台大哥给了一个线上加密的地址让我对。 http://tool.chacuo.net/cryptdes 调试了半天原来是我自己的加密模式不对，使用了CBC模式，而后台用的是ECB。 参考资料： http://blog.csdn.net/u010184533/article/details/38975871]]></content>
  </entry>
</search>
