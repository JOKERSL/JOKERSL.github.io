<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.1" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.1">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.4.1',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
<meta property="og:type" content="website">
<meta property="og:title" content="Man Tou Pu&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/iOS面试/index.html">
<meta property="og:site_name" content="Man Tou Pu&#39;s Blog">
<meta property="og:description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Man Tou Pu&#39;s Blog">
<meta name="twitter:description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">






  <link rel="canonical" href="http://yoursite.com/iOS面试/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Man Tou Pu's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Man Tou Pu's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">技术、生活个人博客</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/XMPP的使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/XMPP的使用/" itemprop="url">
                  XMPP的使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 16:47:00 / 修改时间：16:49:19" itemprop="dateCreated datePublished" datetime="2018-09-17T16:47:00+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络相关/" itemprop="url" rel="index"><span itemprop="name">网络相关</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[转自 <a href="https://www.cnblogs.com/QianChia/" target="_blank" rel="noopener">Qian Chia 工作室</a>]（<a href="http://www.cnblogs.com/QianChia/p/6411914.html）" target="_blank" rel="noopener">http://www.cnblogs.com/QianChia/p/6411914.html）</a></p>
<h1 id="iOS-XMPP-的使用"><a href="#iOS-XMPP-的使用" class="headerlink" title="iOS - XMPP 的使用"></a><a href="https://www.cnblogs.com/QianChia/p/6411914.html" target="_blank" rel="noopener">iOS - XMPP 的使用</a></h1><p><strong>本文目录</strong></p>
<ul>
<li><a href="http://www.cnblogs.com/QianChia/p/6411914.html#_label0" target="_blank" rel="noopener">1、XMPP</a></li>
<li><a href="http://www.cnblogs.com/QianChia/p/6411914.html#_label1" target="_blank" rel="noopener">2、XMPPFramework 框架简介</a></li>
<li><a href="http://www.cnblogs.com/QianChia/p/6411914.html#_label2" target="_blank" rel="noopener">3、XMPPFramework 框架使用</a></li>
<li><a href="http://www.cnblogs.com/QianChia/p/6411914.html#_label3" target="_blank" rel="noopener">4、XMPPFramework 实现简单聊天</a></li>
<li><a href="http://www.cnblogs.com/QianChia/p/6411914.html#_label4" target="_blank" rel="noopener">5、XMPPFramework 快速登录</a></li>
<li><a href="http://www.cnblogs.com/QianChia/p/6411914.html#_label5" target="_blank" rel="noopener">6、XMPPFramework 重连以及其他问题</a></li>
</ul>
<p><a href="http://www.cnblogs.com/QianChia/p/6411914.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h1 id="1、XMPP"><a href="#1、XMPP" class="headerlink" title="1、XMPP"></a>1、XMPP</h1><ul>
<li><p>XMPP 是一个基于 Socket 通信的即时通讯的协议，它规范了即时通信在网络上数据的传输格式，比如登录，获取好友列表等等的格式。XMPP 在网络传输的数据是 XML 格式。</p>
</li>
<li><p>开发架构：</p>
<p><img src="https://images2015.cnblogs.com/blog/993906/201702/993906-20170219013850269-115138110.png" alt="IM3"></p>
</li>
<li><p>iOS 框架：<a href="https://github.com/robbiehanson/XMPPFramework" target="_blank" rel="noopener">XMPPFramework</a></p>
</li>
<li><p>服务器：<a href="http://www.igniterealtime.org/downloads/index.jsp" target="_blank" rel="noopener">Openfire</a></p>
</li>
<li><p>数据库：<a href="https://www.mysql.com/downloads/" target="_blank" rel="noopener">MySQL</a></p>
</li>
</ul>
<p><a href="http://www.cnblogs.com/QianChia/p/6411914.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h1 id="2、XMPPFramework-框架简介"><a href="#2、XMPPFramework-框架简介" class="headerlink" title="2、XMPPFramework 框架简介"></a>2、XMPPFramework 框架简介</h1><h2 id="2-1-XMPPFramework-简介"><a href="#2-1-XMPPFramework-简介" class="headerlink" title="2.1 XMPPFramework 简介"></a>2.1 XMPPFramework 简介</h2><ul>
<li><a href="https://github.com/robbiehanson/XMPPFramework" target="_blank" rel="noopener">XMPPFramework</a> 是一个 OS X/iOS 平台的开源项目，使用 Objective-C 实现了 XMPP 协议（RFC-3920），同时还提供了用于读写 XML 的工具，大大简化了基于 XMPP 的通信应用的开发。</li>
</ul>
<h2 id="2-2-XMPPFramework-结构"><a href="#2-2-XMPPFramework-结构" class="headerlink" title="2.2 XMPPFramework 结构"></a>2.2 XMPPFramework 结构</h2><ul>
<li><p>1、XMPPFramework 的目录结构如下：</p>
<p><img src="https://images2015.cnblogs.com/blog/993906/201702/993906-20170226011813366-1554692760.png" alt="IM5"></p>
<p>| 目录             | 说明                                       |<br>| ————– | —————————————- |<br>| Authentication | 授权，与授权验证相关，如用户名密码等                       |<br>| Categories     | 分类，XMPP 自己写的一些分类，尤其是 NSXMLElement+XMPP 扩展是必备的 |<br>| Core           | 核心，这里是 XMPP 的核心文件目录，我们最主要的目光还是要放在这个目录上   |<br>| Extensions     | 扩展，XMPP 的扩展模块，用于扩展各种协议和各种独立的功能，其下每个子目录都是对应的一个单独的子功能 |<br>| Utilities      | 工具，都是辅助类，我们开发者不用关心这里                     |<br>| Vendor         | 第三方库，这个目录是 XMPP 所引用的第三方类库，我们也不用关心这里      |</p>
<ul>
<li><p>虽然这里有很多个目录，但是我们在开发中基本只关心 Core 和 Extensions 这两个目录下的类。</p>
</li>
<li><p>在 Core 中：</p>
<p>| 目录           | 说明                       |<br>| ———— | ———————— |<br>| XMPPElement  | 是一个基类，延展出三个子类            |<br>| XMPPIQ       | 请求，用户登录，用户注册，添加好友等       |<br>| XMPPMessage  | 消息，用来发各种消息等              |<br>| XMPPPresence | 展现，用户上线下线提示等             |<br>| XMPPStream   | 流，非常常用，大部分类的加载都在写在流的懒加载里 |</p>
</li>
<li><p>在 Extensions 中：</p>
<p>| 目录                         | 说明          |<br>| ————————– | ———– |<br>| CoreDataStorage            | coreData 存储 |<br>| Reconnect                  | 重新连接        |<br>| Roster                     | 好友管理        |<br>| SystemInputActivityMonitor | 系统输入的活动监控   |</p>
</li>
<li><p>在 Vendor 中：</p>
<p>| 文件夹              | 说明        |<br>| —————- | ——— |<br>| CocoaAsyncSocket | 异步 Socket |<br>| CocoaLumberjack  | ⽇志相关      |<br>| KissXML          | XML 解析    |</p>
</li>
</ul>
</li>
<li><p>2、XMPPFramework 中常用的类：</p>
<p>| 类                                        | 说明                                    |<br>| —————————————- | ————————————- |<br>| XMPPStream                               | XMPP 基础服务类                            |<br>| XMPPRoster                               | 好友列表类                                 |<br>| XMPPUserCoreDataStorageObject            | 管理用户的类                                |<br>| XMPPRosterCoreDataStorage                | 好友列表（用户账号）在 core data 中的操作类           |<br>| XMPPvCardCoreDataStorage                 | 好友名片（昵称，签名，性别，年龄等信息）在 core data 中的操作类 |<br>| XMPPvCardTemp                            | 好友名片实体类，从数据库里取出来的都是它                  |<br>| xmppvCardAvatarModule                    | 好友头像                                  |<br>| XMPPReconnect                            | 如果失去连接，自动重连                           |<br>| XMPPRoom                                 | 提供多用户聊天支持                             |<br>| XMPPPubSub                               | 发布订阅                                  |<br>| XMPPMessageArchiving                     | 其中有数据表                                |<br>| XMPPMessageArchiving_Message_CoreDataObject | 取出当前信息的类                              |</p>
</li>
<li><p>3、XMPPFramework 几个常用到的扩展协议：</p>
<p>| 协议       | 协议简介                                     |<br>| ——– | —————————————- |<br>| XEP-0006 | 使能与网络上某个 XMPP 实体间的通信                     |<br>| XEP-0009 | 在两个 XMPP 实体间传输 XML-RPC 编码请求和响应           |<br>| XEP-0012 | 最后的活动（判断上线，离开断开）                         |<br>| XEP-0045 | 多人聊天相关协议                                 |<br>| XEP-0054 | 名片格式的标准文档，个人信息设置                         |<br>| XEP-0060 | 提供通用公共订阅功能                               |<br>| XEP-0065 | 两个 XMPP 用户之间建立一个带外流，主要用于文件传输，sockets5 字节流 |<br>| XEP-0066 | 二进制数据传输（特殊信息的发送）                         |<br>| XEP-0082 | 日期和时间信息的标准化表示                            |<br>| XEP-0085 | 聊天对话中通知用户状态，聊天状态通知                       |<br>| XEP-0100 | 表述了 XMPP 客户端与提供传统的 IM 服务的代理网关之间交换的最佳实践   |<br>| XEP-0115 | 广播和动态发现客户端、设备、或一般实体能力                    |<br>| XEP-0136 | 为服务端备份和检索 XMPP 消息定义机制和偏好设置，聊天记录归档        |<br>| XEP-0153 | 用于交换用户头像，基于名片的头像                         |<br>| XEP-0184 | 消息送达回执协议                                 |<br>| XEP-0199 | XMPP ping 协议（用来 ping 服务器和 ping 自己）       |<br>| XEP-0202 | 用于交换实体间的本地时间信息                           |<br>| XEP-0203 | 用于延迟发送                                   |<br>| XEP-0224 | 引起另一个用户注意的协议                             |<br>| XEP-0335 | JSON 容器（可能以后某些信息传输将用 JSON 格式）            |</p>
<ul>
<li>XMPP 的扩展协议 <a href="https://en.wikipedia.org/wiki/Jingle_(protocol" target="_blank" rel="noopener">Jingle</a>) 使得其支持语音和视频，目前 iOS 尚不支持。<ul>
<li>iOS 发送附件（图片，语音，文档…）时比较麻烦，XMPP 框架没有提供发送附件的功能，需要自己实现。</li>
<li>iOS 发送附件实现方法：<ul>
<li>1、将获取到的图片／音频文件通过 base64 加密，直接通过 xmpp 的消息体发送过去，然后解码。</li>
<li>2、通过 http 请求的方式将图片／音频文件上传到服务器，然后将图片／音频文件的下载地址通过 xmpp 消息体发送过去，另外一个客户端下载。</li>
<li>音频文件建议转码为 amr，这种格式的音频文件比较小。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-3-XMPPJID-类"><a href="#2-3-XMPPJID-类" class="headerlink" title="2.3 XMPPJID 类"></a>2.3 XMPPJID 类</h2><ul>
<li>登录需要到账号，而所谓的账号其实就是用户唯一标识符（JID），在 XMPP 中使用 XMPPJID 类来表示。</li>
<li>JID 一般由三部分构成：用户名，域名和资源名，格式为 <code>user@domain/resource</code>，例如：<code>test@example.com/Anthony</code>。对应于 XMPPJID 类中的三个属性 user、domain、resource。</li>
<li>如果没有设置主机名（HOST），则使用 JID 的域名（domain）作为主机名，而端口号是可选的，默认是 5222，一般也没有必要改动它。</li>
</ul>
<h2 id="2-4-XMPPStream-类"><a href="#2-4-XMPPStream-类" class="headerlink" title="2.4 XMPPStream 类"></a>2.4 XMPPStream 类</h2><ul>
<li><p>我们要与服务器连接，就必须通过 XMPPStream 类了，它提供了很多的 API 和属性设置，通过 socket 来实现的。Verdor 目录包含了 CocoaAsyncSocket 这个非常有名的 socket 编程库。XMPPStream 类还遵守并实现了 GCDAsyncSocketDelegate 代理，用于客户端与服务器交互。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface XMPPStream : NSObject &lt;GCDAsyncSocketDelegate&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当我们创建 XMPPStream 对象后，我们需要设置代理，才能回调我们的代理方法，这个是支持 multicast delegate，也就是说对于一个 XMPPStream 对象，可以设置多个代理对象，其中协议是XMPPStreamDelegate。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)addDelegate:(id)delegate delegateQueue:(dispatch_queue_t)delegateQueue;</span><br></pre></td></tr></table></figure>
</li>
<li><p>而当我们不希望某个 XMPPStream 对象继续接收到代理回调时，我们通过这样的方式来移除代理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeDelegate:(id)delegate delegateQueue:(dispatch_queue_t)delegateQueue;</span><br><span class="line">- (void)removeDelegate:(id)delegate;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来，我们要设置主机和端口，通过设置这两个属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 主机，可选设置，如果没有设置默认会使用 domain</span><br><span class="line">@property (readwrite, copy) NSString *hostName;</span><br><span class="line"></span><br><span class="line">// 端口号，默认为 5222</span><br><span class="line">@property (readwrite, assign) UInt16 hostPort;</span><br></pre></td></tr></table></figure>
</li>
<li><p>XMPPStream 有 XMPPJID 类对象作为属性，标识用户，因为我们后续很多操作都需要到 myJID。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (readwrite, copy) XMPPJID *myJID;</span><br></pre></td></tr></table></figure>
</li>
<li><p>而管理用户在线状态的就交由 XMPPPresence 类了，它同样被作为 XMPPStream 的属性，组合到 XMPPStream 中，后续很多关于用户的操作是需要到处理用户状态的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (strong, readonly) XMPPPresence *myPresence;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-5-XMPPStreamDelegate"><a href="#2-5-XMPPStreamDelegate" class="headerlink" title="2.5 XMPPStreamDelegate"></a>2.5 XMPPStreamDelegate</h2><ul>
<li><p>这个协议是非常关键的，我们的很多主要操作都集中在这个协议的代理回调上。它分为好几种类型的代理 API，比如授权的、注册的、安全的等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">@protocol XMPPStreamDelegate</span><br><span class="line">@optional</span><br><span class="line"></span><br><span class="line">// 将要与服务器连接</span><br><span class="line">- (void)xmppStreamWillConnect:(XMPPStream *)sender;</span><br><span class="line"></span><br><span class="line">// 已经与服务器连接，</span><br><span class="line">// 当 TCP Socket 已经与远程主机连接上时会回调此方法</span><br><span class="line">// 若 App 要求在后台运行，需要设置 XMPPStream&apos;s enableBackgroundingOnSocket 属性</span><br><span class="line">- (void)xmppStream:(XMPPStream *)sender socketDidConnect:(GCDAsyncSocket *)socket;</span><br><span class="line"></span><br><span class="line">// 当 TCP 与服务器建立连接后会回调此方法</span><br><span class="line">- (void)xmppStreamDidStartNegotiation:(XMPPStream *)sender;</span><br><span class="line"></span><br><span class="line">// TLS 传输层协议在将要验证安全设置时会回调</span><br><span class="line">// 参数 settings 会被传到 startTLS，此方法可以不实现的</span><br><span class="line">// 若服务端使用自签名的证书，需要在 settings 中添加 GCDAsyncSocketManuallyEvaluateTrust = YES</span><br><span class="line">- (void)xmppStream:(XMPPStream *)sender willSecureWithSettings:(NSMutableDictionary *)settings;</span><br><span class="line"></span><br><span class="line">// 上面的方法执行后，下一步就会执行这个代理回调</span><br><span class="line">// 用于在 TCP 握手时手动验证是否受信任</span><br><span class="line">- (void)xmppStream:(XMPPStream *)sender didReceiveTrust:(SecTrustRef)trust</span><br><span class="line">                                      completionHandler:(void (^)(BOOL shouldTrustPeer))completionHandler;</span><br><span class="line"></span><br><span class="line">// 当 stream 通过了 SSL/TLS 的安全验证时，会回调此代理方法</span><br><span class="line">- (void)xmppStreamDidSecure:(XMPPStream *)sender;</span><br><span class="line"></span><br><span class="line">// 当 XML 流已经完全打开时（也就是与服务器的连接完成时）会回调此代理方法。此时可以安全地与服务器通信了</span><br><span class="line">- (void)xmppStreamDidConnect:(XMPPStream *)sender;</span><br><span class="line"></span><br><span class="line">// 注册新用户成功时的回调</span><br><span class="line">- (void)xmppStreamDidRegister:(XMPPStream *)sender;</span><br><span class="line"></span><br><span class="line">// 注册新用户失败时的回调</span><br><span class="line">- (void)xmppStream:(XMPPStream *)sender didNotRegister:(NSXMLElement *)error;</span><br><span class="line"></span><br><span class="line">// 授权通过时的回调，也就是登录成功的回调</span><br><span class="line">- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender;</span><br><span class="line"></span><br><span class="line">// 授权失败时的回调，也就是登录失败时的回调</span><br><span class="line">- (void)xmppStream:(XMPPStream *)sender didNotAuthenticate:(NSXMLElement *)error;</span><br><span class="line"></span><br><span class="line">// 将要绑定 JID resource 时的回调，这是授权程序的标准部分</span><br><span class="line">// 当验证 JID 用户名通过时，下一步就验证 resource。若使用标准绑定处理，return nil 或者不要实现此方法</span><br><span class="line">- (id &lt;XMPPCustomBinding&gt;)xmppStreamWillBind:(XMPPStream *)sender;</span><br><span class="line"></span><br><span class="line">// 如果服务器出现 resouce 冲突而导致不允许 resource 选择时，会回调此代理方法</span><br><span class="line">// 返回指定的 resource 或者返回 nil 让服务器自动帮助我们来选择。一般不用实现它</span><br><span class="line">- (NSString *)xmppStream:(XMPPStream *)sender alternativeResourceForConflictingResource:(NSString *)conflictingResource;</span><br><span class="line"></span><br><span class="line">// 将要接收 IQ（消息查询）时的回调</span><br><span class="line">- (XMPPIQ *)xmppStream:(XMPPStream *)sender willReceiveIQ:(XMPPIQ *)iq;</span><br><span class="line"></span><br><span class="line">// 将要接收到消息时的回调</span><br><span class="line">- (XMPPMessage *)xmppStream:(XMPPStream *)sender willReceiveMessage:(XMPPMessage *)message;</span><br><span class="line"></span><br><span class="line">// 将要接收到用户在线状态时的回调</span><br><span class="line">- (XMPPPresence *)xmppStream:(XMPPStream *)sender willReceivePresence:(XMPPPresence *)presence;</span><br><span class="line"></span><br><span class="line">// 通过实现此代理方法，可以知道被过滤的原因，有一定的帮助</span><br><span class="line">// 当 xmppStream:willReceiveX: (也就是前面这三个 API 回调后)，过滤了 stanza，会回调此代理方法</span><br><span class="line">- (void)xmppStreamDidFilterStanza:(XMPPStream *)sender;</span><br><span class="line"></span><br><span class="line">// 在接收了 IQ（消息查询后）会回调此代理方法</span><br><span class="line">- (BOOL)xmppStream:(XMPPStream *)sender didReceiveIQ:(XMPPIQ *)iq;</span><br><span class="line"></span><br><span class="line">// 在接收了消息后会回调此代理方法</span><br><span class="line">- (void)xmppStream:(XMPPStream *)sender didReceiveMessage:(XMPPMessage *)message;</span><br><span class="line"></span><br><span class="line">// 在接收了用户在线状态消息后会回调此代理方法</span><br><span class="line">- (void)xmppStream:(XMPPStream *)sender didReceivePresence:(XMPPPresence *)presence;</span><br><span class="line"></span><br><span class="line">// 在接收 IQ/messag、presence 出错时，会回调此代理方法</span><br><span class="line">- (void)xmppStream:(XMPPStream *)sender didReceiveError:(NSXMLElement *)error;</span><br><span class="line"></span><br><span class="line">// 将要发送 IQ（消息查询时）时会回调此代理方法</span><br><span class="line">- (XMPPIQ *)xmppStream:(XMPPStream *)sender willSendIQ:(XMPPIQ *)iq;</span><br><span class="line"></span><br><span class="line">// 在将要发送消息时，会回调此代理方法</span><br><span class="line">- (XMPPMessage *)xmppStream:(XMPPStream *)sender willSendMessage:(XMPPMessage *)message;</span><br><span class="line"></span><br><span class="line">// 在将要发送用户在线状态信息时，会回调此方法</span><br><span class="line">- (XMPPPresence *)xmppStream:(XMPPStream *)sender willSendPresence:(XMPPPresence *)presence;</span><br><span class="line"></span><br><span class="line">// 在发送 IQ（消息查询）成功后会回调此代理方法</span><br><span class="line">- (void)xmppStream:(XMPPStream *)sender didSendIQ:(XMPPIQ *)iq;</span><br><span class="line"></span><br><span class="line">// 在发送消息成功后，会回调此代理方法</span><br><span class="line">- (void)xmppStream:(XMPPStream *)sender didSendMessage:(XMPPMessage *)message;</span><br><span class="line"></span><br><span class="line">// 在发送用户在线状态信息成功后，会回调此方法</span><br><span class="line">- (void)xmppStream:(XMPPStream *)sender didSendPresence:(XMPPPresence *)presence;</span><br><span class="line"></span><br><span class="line">// 在发送 IQ（消息查询）失败后会回调此代理方法</span><br><span class="line">- (void)xmppStream:(XMPPStream *)sender didFailToSendIQ:(XMPPIQ *)iq error:(NSError *)error;</span><br><span class="line"></span><br><span class="line">// 在发送消息失败后，会回调此代理方法</span><br><span class="line">- (void)xmppStream:(XMPPStream *)sender didFailToSendMessage:(XMPPMessage *)message error:(NSError *)error;</span><br><span class="line"></span><br><span class="line">// 在发送用户在线状态失败信息后，会回调此方法</span><br><span class="line">- (void)xmppStream:(XMPPStream *)sender didFailToSendPresence:(XMPPPresence *)presence error:(NSError *)error;</span><br><span class="line"></span><br><span class="line">// 当修改了 JID 信息时，会回调此代理方法</span><br><span class="line">- (void)xmppStreamDidChangeMyJID:(XMPPStream *)xmppStream;</span><br><span class="line"></span><br><span class="line">// 当 Stream 被告知与服务器断开连接时会回调此代理方法</span><br><span class="line">- (void)xmppStreamWasToldToDisconnect:(XMPPStream *)sender;</span><br><span class="line"></span><br><span class="line">// 当发送了 &lt;/stream:stream&gt; 节点时，会回调此代理方法</span><br><span class="line">- (void)xmppStreamDidSendClosingStreamStanza:(XMPPStream *)sender;</span><br><span class="line"></span><br><span class="line">// 连接超时时会回调此代理方法</span><br><span class="line">- (void)xmppStreamConnectDidTimeout:(XMPPStream *)sender;</span><br><span class="line"></span><br><span class="line">// 当与服务器断开连接后，会回调此代理方法</span><br><span class="line">- (void)xmppStreamDidDisconnect:(XMPPStream *)sender withError:(NSError *)error;</span><br><span class="line"></span><br><span class="line">// P2P 类型相关的</span><br><span class="line">- (void)xmppStream:(XMPPStream *)sender didReceiveP2PFeatures:(NSXMLElement *)streamFeatures;</span><br><span class="line">- (void)xmppStream:(XMPPStream *)sender willSendP2PFeatures:(NSXMLElement *)streamFeatures;</span><br><span class="line"></span><br><span class="line">- (void)xmppStream:(XMPPStream *)sender didRegisterModule:(id)module;</span><br><span class="line">- (void)xmppStream:(XMPPStream *)sender willUnregisterModule:(id)module;</span><br><span class="line"></span><br><span class="line">// 当发送非 XMPP 元素节点时，会回调此代理方法</span><br><span class="line">// 也就是说，如果发送的 element 不是 &lt;iq&gt;, &lt;message&gt; 或者 &lt;presence&gt;，那么就会回调此代理方法</span><br><span class="line">- (void)xmppStream:(XMPPStream *)sender didSendCustomElement:(NSXMLElement *)element;</span><br><span class="line"></span><br><span class="line">// 当接收到非 XMPP 元素节点时，会回调此代理方法</span><br><span class="line">// 也就是说，如果接收的element不是 &lt;iq&gt;, &lt;message&gt; 或者 &lt;presence&gt;，那么就会回调此代理方法</span><br><span class="line">- (void)xmppStream:(XMPPStream *)sender didReceiveCustomElement:(NSXMLElement *)element;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-6-XMPPIQ-类"><a href="#2-6-XMPPIQ-类" class="headerlink" title="2.6 XMPPIQ 类"></a>2.6 XMPPIQ 类</h2><ul>
<li><p>消息查询（IQ）就是通过此类来处理的了。XMPP 给我们提供了 IQ 方便创建的类，用于快速生成 XML 数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@interface XMPPIQ : XMPPElement</span><br><span class="line"></span><br><span class="line">// 生成 IQ</span><br><span class="line"></span><br><span class="line">+ (XMPPIQ *)iq;</span><br><span class="line">+ (XMPPIQ *)iqWithType:(NSString *)type;</span><br><span class="line">+ (XMPPIQ *)iqWithType:(NSString *)type to:(XMPPJID *)jid;</span><br><span class="line">+ (XMPPIQ *)iqWithType:(NSString *)type to:(XMPPJID *)jid elementID:(NSString *)eid;</span><br><span class="line">+ (XMPPIQ *)iqWithType:(NSString *)type to:(XMPPJID *)jid elementID:(NSString *)eid child:(NSXMLElement *)childElement;</span><br><span class="line">+ (XMPPIQ *)iqWithType:(NSString *)type elementID:(NSString *)eid;</span><br><span class="line">+ (XMPPIQ *)iqWithType:(NSString *)type elementID:(NSString *)eid child:(NSXMLElement *)childElement;</span><br><span class="line">+ (XMPPIQ *)iqWithType:(NSString *)type child:(NSXMLElement *)childElement;</span><br><span class="line"></span><br><span class="line">- (id)init;</span><br><span class="line">- (id)initWithType:(NSString *)type;</span><br><span class="line">- (id)initWithType:(NSString *)type to:(XMPPJID *)jid;</span><br><span class="line">- (id)initWithType:(NSString *)type to:(XMPPJID *)jid elementID:(NSString *)eid;</span><br><span class="line">- (id)initWithType:(NSString *)type to:(XMPPJID *)jid elementID:(NSString *)eid child:(NSXMLElement *)childElement;</span><br><span class="line">- (id)initWithType:(NSString *)type elementID:(NSString *)eid;</span><br><span class="line">- (id)initWithType:(NSString *)type elementID:(NSString *)eid child:(NSXMLElement *)childElement;</span><br><span class="line">- (id)initWithType:(NSString *)type child:(NSXMLElement *)childElement;</span><br><span class="line"></span><br><span class="line">// IQ 类型</span><br><span class="line">- (NSString *)type;</span><br><span class="line"></span><br><span class="line">// 判断 type 类型</span><br><span class="line"></span><br><span class="line">- (BOOL)isGetIQ;</span><br><span class="line">- (BOOL)isSetIQ;</span><br><span class="line">- (BOOL)isResultIQ;</span><br><span class="line">- (BOOL)isErrorIQ;</span><br><span class="line"></span><br><span class="line">// 当 type 为 get 或者 set 时，这个 API 是很有用的，用于指定是否要求有响应</span><br><span class="line">- (BOOL)requiresResponse;</span><br><span class="line"></span><br><span class="line">- (NSXMLElement *)childElement;</span><br><span class="line">- (NSXMLElement *)childErrorElement;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>IQ 是一种请求／响应机制，从一个实体发送请求，另外一个实体接受请求并进行响应。例如，Client 在 stream 的上下文中插入一个元素，向 Server 请求得到自己的好友列表，Server 返回一个，里面是请求的结果。</p>
</li>
<li><p><code>&lt;type&gt;&lt;/type&gt;</code> 有以下类别（可选设置如：<code>&lt;type&gt;get&lt;/type&gt;</code>）</p>
<p>| type   | 说明                             |<br>| —— | —————————— |<br>| get    | 获取当前域值。类似于 http get 方法         |<br>| set    | 设置或替换 get 查询的值。类似于 http put 方法 |<br>| result | 说明成功的响应了先前的查询。类似于 http 状态码 200 |<br>| error  | 查询和响应中出现的错误                    |</p>
</li>
<li><p>下面是一个 IQ 例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;iqfrom=&quot;huangyibiao@welcome.com/ios&quot;  </span><br><span class="line">    id=&quot;xxxxxxx&quot; </span><br><span class="line">    to=&quot;biaoge@welcome.com/ios&quot;  </span><br><span class="line">    type=&quot;get&quot;&gt; </span><br><span class="line">  &lt;queryxmlns=&quot;jabber:iq:roster&quot;/&gt; </span><br><span class="line">&lt;/iq&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-7-XMPPPresence-类"><a href="#2-7-XMPPPresence-类" class="headerlink" title="2.7 XMPPPresence 类"></a>2.7 XMPPPresence 类</h2><ul>
<li><p>这个类代表节点，我们通过此类提供的方法来生成 XML 数据。presence 它代表用户在线状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@interface XMPPPresence : XMPPElement</span><br><span class="line"></span><br><span class="line">// Converts an NSXMLElement to an XMPPPresence element in place (no memory allocations or copying)</span><br><span class="line">+ (XMPPPresence *)presenceFromElement:(NSXMLElement *)element;</span><br><span class="line"></span><br><span class="line">+ (XMPPPresence *)presence;</span><br><span class="line">+ (XMPPPresence *)presenceWithType:(NSString *)type;</span><br><span class="line"></span><br><span class="line">// type：用户在线状态，to：接收方的 JID</span><br><span class="line">+ (XMPPPresence *)presenceWithType:(NSString *)type to:(XMPPJID *)to;</span><br><span class="line"></span><br><span class="line">- (id)init;</span><br><span class="line">- (id)initWithType:(NSString *)type;</span><br><span class="line">- (id)initWithType:(NSString *)type to:(XMPPJID *)to;</span><br><span class="line"></span><br><span class="line">- (NSString *)type;</span><br><span class="line"></span><br><span class="line">- (NSString *)show;</span><br><span class="line">- (NSString *)status;</span><br><span class="line"></span><br><span class="line">- (int)priority;</span><br><span class="line"></span><br><span class="line">- (int)intShow;</span><br><span class="line"></span><br><span class="line">- (BOOL)isErrorPresence;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>presence 用来表明用户的状态，如：online、offline、away、dnd (请勿打扰) 等。当改变自己的状态时，就会在 stream 的上下文中插入一个 Presence 元素，来表明自身的状态。要想接受 presence 消息，必须经过一个叫做 presence subscription 的授权过程。</p>
</li>
<li><p><code>&lt;type&gt;&lt;/type&gt;</code> 有以下类别（可选设置如：<code>&lt;type&gt;subscribe&lt;/type&gt;</code>）：</p>
<p>| type           | 说明                |<br>| ————– | —————– |<br>| available      | 上线                |<br>| unavailable    | 下线                |<br>| away           | 离开                |<br>| do not disturb | 忙碌                |<br>| subscribe      | 订阅其他用户的状态         |<br>| probe          | 请求获取其他用户的状态       |<br>| unavailable    | 不可用，离线（offline）状态 |</p>
</li>
<li><p><code>&lt;show&gt;&lt;/show&gt;</code> 节点有以下类别，如 <code>&lt;show&gt;dnd&lt;/show&gt;</code> ：</p>
<p>| show | 说明                |<br>| —- | —————– |<br>| chat | 聊天中               |<br>| away | 暂时离开              |<br>| xa   | eXtend Away，长时间离开 |<br>| dnd  | 勿打扰               |</p>
</li>
<li><p><code>&lt;status&gt;&lt;/status&gt;</code> 节点</p>
<ul>
<li>这个节点表示状态信息，内容比较自由，几乎可以是所有类型的内容。常用来表示用户当前心情，活动，听的歌曲，看的视频，所在的聊天室，访问的网页，玩的游戏等等。</li>
</ul>
</li>
<li><p><code>&lt;priority&gt;&lt;/priority&gt;</code> 节点</p>
<ul>
<li>范围 -128~127。高优先级的 resource 能接受发送到 bare JID 的消息，低优先级的 resource 不能。优先级为负数的 resource 不能收到发送到 bare JID 的消息。</li>
</ul>
</li>
<li><p>发送一个用户在线状态的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;presencefrom=&quot;alice@wonderland.lit/pda&quot;&gt; </span><br><span class="line">  &lt;show&gt;dnd&lt;/show&gt; </span><br><span class="line">  &lt;status&gt;浏览器搜索&lt;/status&gt; </span><br><span class="line">&lt;/presence&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-8-XMPPMessage-类"><a href="#2-8-XMPPMessage-类" class="headerlink" title="2.8 XMPPMessage 类"></a>2.8 XMPPMessage 类</h2><ul>
<li><p>XMPPMessage 是 XMPP 框架给我们提供的，方便用于生成 XML 消息的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@interface XMPPMessage : XMPPElement</span><br><span class="line"></span><br><span class="line">// Converts an NSXMLElement to an XMPPMessage element in place (no memory allocations or copying)</span><br><span class="line">+ (XMPPMessage *)messageFromElement:(NSXMLElement *)element;</span><br><span class="line"></span><br><span class="line">+ (XMPPMessage *)message;</span><br><span class="line">+ (XMPPMessage *)messageWithType:(NSString *)type;</span><br><span class="line">+ (XMPPMessage *)messageWithType:(NSString *)type to:(XMPPJID *)to;</span><br><span class="line">+ (XMPPMessage *)messageWithType:(NSString *)type to:(XMPPJID *)jid elementID:(NSString *)eid;</span><br><span class="line">+ (XMPPMessage *)messageWithType:(NSString *)type to:(XMPPJID *)jid elementID:(NSString *)eid child:(NSXMLElement *)childElement;</span><br><span class="line">+ (XMPPMessage *)messageWithType:(NSString *)type elementID:(NSString *)eid;</span><br><span class="line">+ (XMPPMessage *)messageWithType:(NSString *)type elementID:(NSString *)eid child:(NSXMLElement *)childElement;</span><br><span class="line">+ (XMPPMessage *)messageWithType:(NSString *)type child:(NSXMLElement *)childElement;</span><br><span class="line"></span><br><span class="line">- (id)init;</span><br><span class="line">- (id)initWithType:(NSString *)type;</span><br><span class="line">- (id)initWithType:(NSString *)type to:(XMPPJID *)to;</span><br><span class="line">- (id)initWithType:(NSString *)type to:(XMPPJID *)jid elementID:(NSString *)eid;</span><br><span class="line">- (id)initWithType:(NSString *)type to:(XMPPJID *)jid elementID:(NSString *)eid child:(NSXMLElement *)childElement;</span><br><span class="line">- (id)initWithType:(NSString *)type elementID:(NSString *)eid;</span><br><span class="line">- (id)initWithType:(NSString *)type elementID:(NSString *)eid child:(NSXMLElement *)childElement;</span><br><span class="line">- (id)initWithType:(NSString *)type child:(NSXMLElement *)childElement;</span><br><span class="line"></span><br><span class="line">- (NSString *)type;</span><br><span class="line">- (NSString *)subject;</span><br><span class="line">- (NSString *)body;</span><br><span class="line">- (NSString *)bodyForLanguage:(NSString *)language;</span><br><span class="line">- (NSString *)thread;</span><br><span class="line"></span><br><span class="line">- (void)addSubject:(NSString *)subject;</span><br><span class="line">- (void)addBody:(NSString *)body;</span><br><span class="line">- (void)addBody:(NSString *)body withLanguage:(NSString *)language;</span><br><span class="line">- (void)addThread:(NSString *)thread;</span><br><span class="line"></span><br><span class="line">- (BOOL)isChatMessage;</span><br><span class="line">- (BOOL)isChatMessageWithBody;</span><br><span class="line">- (BOOL)isErrorMessage;</span><br><span class="line">- (BOOL)isMessageWithBody;</span><br><span class="line"></span><br><span class="line">- (NSError *)errorMessage;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>message 是一种基本 推送 消息方法，它不要求响应。主要用于 IM、groupChat、alert 和 notification 之类的应用中。</p>
</li>
<li><p><code>&lt;type&gt;&lt;/type&gt;</code> 有以下类别（可选设置如：<code>&lt;type&gt;chat&lt;/type&gt;</code>）：</p>
<p>| type      | 说明                                     |<br>| ——— | ————————————– |<br>| normal    | 类似于 email，主要特点是不要求响应                   |<br>| chat      | 类似于 qq 里的好友即时聊天，主要特点是实时通讯              |<br>| groupchat | 类似于聊天室里的群聊                             |<br>| headline  | 用于发送 alert 和 notification              |<br>| error     | 如果发送 message 出错，发现错误的实体会用这个类别来通知发送者出错了 |</p>
</li>
<li><p><code>&lt;body&gt;&lt;/body&gt;</code> 节点</p>
<ul>
<li>所要发送的内容就放在 body 节点下</li>
</ul>
</li>
<li><p>消息节点的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;messageto=&quot;lily@jabber.org/contact&quot; type=&quot;chat&quot;&gt; </span><br><span class="line">    &lt;body&gt;您好？&lt;/body&gt;</span><br><span class="line">&lt;/message&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="http://www.cnblogs.com/QianChia/p/6411914.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h1 id="3、XMPPFramework-框架使用"><a href="#3、XMPPFramework-框架使用" class="headerlink" title="3、XMPPFramework 框架使用"></a>3、XMPPFramework 框架使用</h1><h2 id="3-1-CocoaPods-导入框架"><a href="#3-1-CocoaPods-导入框架" class="headerlink" title="3.1 CocoaPods 导入框架"></a>3.1 CocoaPods 导入框架</h2><ul>
<li><p>1、通过 CocoaPods 导入第三方框架 XMPPFramework。</p>
<ul>
<li><p>在 Podfile 文件中加入如下代码，在终端中，使用命令 <code>pod install</code> 下载添加 XMPPFramework 框架。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &apos;8.0&apos;</span><br><span class="line"></span><br><span class="line">target &apos;XMPPDemo&apos; do</span><br><span class="line"></span><br><span class="line">    use_frameworks!</span><br><span class="line">    pod &apos;XMPPFramework&apos;, &apos;~&gt; 3.7.0&apos;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>2、在需要使用 XMPPFramework 的文件中导入以下头文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;XMPPFramework/XMPPFramework.h&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-2-导入框架过程中问题解决"><a href="#3-2-导入框架过程中问题解决" class="headerlink" title="3.2 导入框架过程中问题解决"></a>3.2 导入框架过程中问题解决</h2><ul>
<li><p>1、用 Cocoapods 集成 XMPPFramework 遇 Module ‘KissXML’ not found 等问题解决方法。</p>
<ul>
<li><p>一般来说，通过 Coacopods 集成集成第三方框架，不会再有依赖库方面的问题，所以需要检查导入方式是否正确，最终找到原因，仔细看 githup 上导入说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Install</span><br><span class="line"></span><br><span class="line">The minimum deployment target is iOS 8.0 / macOS 10.8.</span><br><span class="line"></span><br><span class="line">The easiest way to install XMPPFramework is using CocoaPods. Remember to add to the top of your Podfile the </span><br><span class="line">use_frameworks! line (even if you are not using swift):</span><br></pre></td></tr></table></figure>
</li>
<li><p>因此，Podfile 里必须写入这一句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use_frameworks!</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>2、Xcode8 之后 XMPP 重定义 Redefinition of module ‘dnssd’ 问题解决方法。</p>
<ul>
<li><p>在升级 Xcode 到 8 之后，原来的关于 XMPP 的项目运行报错，错误信息为： Redefinition of module ‘dnssd’。系统和XMPP框架同时用到了 ‘dnssd’，大概就是错误的原因。</p>
</li>
<li><p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># The version pushed to CocoaPods is very out of date, use master branch for now </span><br><span class="line">pod &apos;XMPPFramework&apos;, :git =&gt; &quot;https://github.com/robbiehanson/XMPPFramework.git&quot;, :branch =&gt; &apos;master&apos;</span><br><span class="line"></span><br><span class="line">大概意思是需要更新 XMPP 框架，需要把 Podfile 文件中的 </span><br><span class="line">    pod &apos;XMPPFramework&apos;, &apos;~&gt; 3.6.6&apos; </span><br><span class="line">用 </span><br><span class="line">    pod &apos;XMPPFramework&apos;, :git =&gt; &quot;https://github.com/robbiehanson/XMPPFramework.git&quot;, :branch =&gt; &apos;master&apos;</span><br><span class="line">来替换</span><br><span class="line"></span><br><span class="line">或者直接改成 </span><br><span class="line">    pod &apos;XMPPFramework&apos;, &apos;~&gt; 3.7.0&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>3、在 pod update 的过程中有的童鞋会遇到下面这样的错误。</p>
<p><img src="https://images2015.cnblogs.com/blog/993906/201702/993906-20170226012041710-1117027944.png" alt="IM6"></p>
<ul>
<li><p>这个是因为更新的 XMPP 框架中支持的最低版本为 iOS 8.0 / macOS 10.8。The minimum deployment target is iOS 8.0 / macOS 10.8.</p>
</li>
<li><p>把 Podfile 文件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">platform：ios, &apos;7.0&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li>的 7.0 改为 8.0 或以上。</li>
</ul>
</li>
</ul>
</li>
<li><p>4、pod 更新完成了，出现下面这样的错误。</p>
<p><img src="https://images2015.cnblogs.com/blog/993906/201702/993906-20170226012052507-1749105216.png" alt="IM7"></p>
<ul>
<li><p>到报错的工程里面搜一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enable Strict Checking of objc_msgSend Calls</span><br></pre></td></tr></table></figure>
<ul>
<li>改成相反的值就行了，别改没有报错的工程。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a href="http://www.cnblogs.com/QianChia/p/6411914.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h1 id="4、XMPPFramework-实现简单聊天"><a href="#4、XMPPFramework-实现简单聊天" class="headerlink" title="4、XMPPFramework 实现简单聊天"></a>4、XMPPFramework 实现简单聊天</h1><ul>
<li>聊天实现的原理就是，一个客户端通过 XMPP 协议把信息传给服务器，服务器再发消息发给另一个客户端。</li>
</ul>
<h2 id="4-1-用户注册"><a href="#4-1-用户注册" class="headerlink" title="4.1 用户注册"></a>4.1 用户注册</h2><ul>
<li><p>初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/// 包含头文件</span><br><span class="line">#import &lt;XMPPFramework/XMPPFramework.h&gt;</span><br><span class="line"></span><br><span class="line">/// 遵守协议</span><br><span class="line">&lt;XMPPStreamDelegate&gt;</span><br><span class="line"></span><br><span class="line">/// 定义 XMPP 服务器相关信息</span><br><span class="line">#define HOST_DOMAIN     @&quot;jhq0228-macbookair.local&quot;</span><br><span class="line">#define HOST_NAME       @&quot;jhq0228-macbookair.local&quot;</span><br><span class="line">#define HOST_PORT       5222</span><br><span class="line"></span><br><span class="line">/// 注册的账号</span><br><span class="line">@property (nonatomic, copy) NSString *registerUserName;</span><br><span class="line"></span><br><span class="line">/// 注册的密码</span><br><span class="line">@property (nonatomic, copy) NSString *registerPassWord;</span><br><span class="line"></span><br><span class="line">/// XMPP 流</span><br><span class="line">@property (nonatomic, strong) XMPPStream *stream;</span><br><span class="line"></span><br><span class="line">/// 初始化</span><br><span class="line">self.stream = [[XMPPStream alloc] init];</span><br><span class="line">self.stream.hostName = HOST_NAME;</span><br><span class="line">self.stream.hostPort = HOST_PORT;</span><br><span class="line">[self.stream addDelegate:self delegateQueue:dispatch_get_main_queue()];</span><br></pre></td></tr></table></figure>
</li>
<li><p>与服务器建立链接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/// 与服务器建立链接</span><br><span class="line">[self connectToSercerWithUserName:self.registerUserName resource:nil];</span><br><span class="line"></span><br><span class="line">#pragma mark 与服务器连接通信</span><br><span class="line"></span><br><span class="line">    /// 与服务器建立链接，自定义方法</span><br><span class="line">    - (void)connectToSercerWithUserName:(NSString *)userName resource:(NSString *)resource &#123;</span><br><span class="line"></span><br><span class="line">        if ([self.stream isConnected]) &#123;</span><br><span class="line">            [self disconnectWithServer];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // jid</span><br><span class="line">        self.stream.myJID = [XMPPJID jidWithUser:userName domain:HOST_DOMAIN resource:resource];</span><br><span class="line"></span><br><span class="line">        NSError *error = nil;</span><br><span class="line"></span><br><span class="line">        // 进行链接</span><br><span class="line">        [self.stream connectWithTimeout:30.0 error:&amp;error];</span><br><span class="line"></span><br><span class="line">        if (error != nil) &#123;</span><br><span class="line">            NSLog(@&quot;连接出现问题&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进行注册</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark XMPPStreamDelegate 协议方法</span><br><span class="line"></span><br><span class="line">    /// 与服务器连接成功</span><br><span class="line">    - (void)xmppStreamDidConnect:(XMPPStream *)sender &#123;</span><br><span class="line"></span><br><span class="line">        NSError *error1 = nil;</span><br><span class="line"></span><br><span class="line">        // 进行注册</span><br><span class="line">        [self.stream registerWithPassword:self.registerPassWord error:&amp;error1];</span><br><span class="line"></span><br><span class="line">        if (error1 != nil) &#123;</span><br><span class="line">            NSLog(@&quot;注册出现问题&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 与服务器连接超时</span><br><span class="line">    - (void)xmppStreamConnectDidTimeout:(XMPPStream *)sender &#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;连接服务器超时，请检查网络链接后再试！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 注册成功</span><br><span class="line">    - (void)xmppStreamDidRegister:(XMPPStream *)sender &#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;注册成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 注册失败</span><br><span class="line">    - (void)xmppStream:(XMPPStream *)sender didNotRegister:(DDXMLElement *)error &#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;注册失败&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-2-用户登录、注销"><a href="#4-2-用户登录、注销" class="headerlink" title="4.2 用户登录、注销"></a>4.2 用户登录、注销</h2><ul>
<li><p>初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/// 包含头文件</span><br><span class="line">#import &lt;XMPPFramework/XMPPFramework.h&gt;</span><br><span class="line"></span><br><span class="line">/// 遵守协议</span><br><span class="line">&lt;XMPPStreamDelegate&gt;</span><br><span class="line"></span><br><span class="line">/// 定义 XMPP 服务器相关信息</span><br><span class="line">#define HOST_DOMAIN     @&quot;jhq0228-macbookair.local&quot;</span><br><span class="line">#define HOST_NAME       @&quot;jhq0228-macbookair.local&quot;</span><br><span class="line">#define HOST_PORT       5222</span><br><span class="line"></span><br><span class="line">/// 登录的账号</span><br><span class="line">@property (nonatomic, copy) NSString *loginUserName;</span><br><span class="line"></span><br><span class="line">/// 登录的密码</span><br><span class="line">@property (nonatomic, copy) NSString *loginPassWord;</span><br><span class="line"></span><br><span class="line">/// XMPP 流</span><br><span class="line">@property (nonatomic, strong) XMPPStream *stream;</span><br><span class="line"></span><br><span class="line">/// 初始化</span><br><span class="line">self.stream = [[XMPPStream alloc] init];</span><br><span class="line">self.stream.hostName = HOST_NAME;</span><br><span class="line">self.stream.hostPort = HOST_PORT;</span><br><span class="line">[self.stream addDelegate:self delegateQueue:dispatch_get_main_queue()];</span><br></pre></td></tr></table></figure>
</li>
<li><p>与服务器建立链接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/// 与服务器建立链接</span><br><span class="line">[self connectToSercerWithUserName:self.loginUserName resource:nil];</span><br><span class="line"></span><br><span class="line">#pragma mark 与服务器连接通信</span><br><span class="line"></span><br><span class="line">    /// 与服务器建立链接，自定义方法</span><br><span class="line">    - (void)connectToSercerWithUserName:(NSString *)userName resource:(NSString *)resource &#123;</span><br><span class="line"></span><br><span class="line">        if ([self.stream isConnected]) &#123;</span><br><span class="line">            [self disconnectWithServer];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // jid</span><br><span class="line">        self.stream.myJID = [XMPPJID jidWithUser:userName domain:HOST_DOMAIN resource:resource];</span><br><span class="line"></span><br><span class="line">        NSError *error = nil;</span><br><span class="line"></span><br><span class="line">        // 进行连接</span><br><span class="line">        [self.stream connectWithTimeout:30.0 error:&amp;error];</span><br><span class="line"></span><br><span class="line">        if (error != nil) &#123;</span><br><span class="line">            NSLog(@&quot;连接出现问题&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进行登录认证</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark XMPPStreamDelegate 协议方法</span><br><span class="line"></span><br><span class="line">    /// 与服务器连接成功</span><br><span class="line">    - (void)xmppStreamDidConnect:(XMPPStream *)sender &#123;</span><br><span class="line"></span><br><span class="line">        NSError *error = nil;</span><br><span class="line"></span><br><span class="line">        // 进行登录认证</span><br><span class="line">        [self.stream authenticateWithPassword:self.loginPassWord error:&amp;error];</span><br><span class="line"></span><br><span class="line">        if (error != nil) &#123;</span><br><span class="line">            NSLog(@&quot;登录认证出现问题&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 与服务器连接超时</span><br><span class="line">    - (void)xmppStreamConnectDidTimeout:(XMPPStream *)sender &#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;连接服务器超时，请检查网络链接后再试！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 登录成功</span><br><span class="line">    - (void)xmppStreamDidAuthenticate:(XMPPStream *)sender &#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;登录成功&quot;);</span><br><span class="line"></span><br><span class="line">        // 设置用户在线状态，如果没有添加，别人给你发的消息服务器默认为离线状态，是不会给你发送的</span><br><span class="line">        XMPPPresence *presence = [XMPPPresence presenceWithType:@&quot;available&quot;];</span><br><span class="line">        [self.stream sendElement:presence];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 登录失败</span><br><span class="line">    - (void)xmppStream:(XMPPStream *)sender didNotAuthenticate:(DDXMLElement *)error &#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;登录失败&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>与服务器断开链接，用户注销</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark 与服务器连接通信</span><br><span class="line"></span><br><span class="line">    /// 与服务器断开链接，用户注销，自定义方法</span><br><span class="line">    - (void)disconnectWithServer &#123;</span><br><span class="line"></span><br><span class="line">        // 断开链接</span><br><span class="line">        [self.stream disconnect];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#pragma mark XMPPStreamDelegate 协议方法</span><br><span class="line"></span><br><span class="line">    /// 注销成功</span><br><span class="line">    - (void)xmppStreamDidDisconnect:(XMPPStream *)sender withError:(NSError *)error &#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;注销成功&quot;);</span><br><span class="line"></span><br><span class="line">        // 设置用户下线状态</span><br><span class="line">        XMPPPresence *presene = [XMPPPresence presenceWithType:@&quot;unavailable&quot;];</span><br><span class="line">        [self.stream sendElement:presene];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户登录信息本地化存储</p>
<ul>
<li>添加第三方框架 <a href="https://github.com/soffes/SAMKeychain" target="_blank" rel="noopener">SAMKeychain</a>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/// 包含头文件</span><br><span class="line">#import &lt;SAMKeychain/SAMKeychain.h&gt;</span><br><span class="line"></span><br><span class="line">/// 用户名和密码</span><br><span class="line">@property (nonatomic, copy) NSString *userName;</span><br><span class="line">@property (nonatomic, copy) NSString *userPasswd;</span><br><span class="line"></span><br><span class="line">/// 是否记住密码</span><br><span class="line">@property (nonatomic, assign, getter=isSavePasswd) BOOL savePasswd;</span><br><span class="line"></span><br><span class="line">/// 保存用户登录信息</span><br><span class="line">- (void)saveUserLoginInfo &#123;</span><br><span class="line"></span><br><span class="line">    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line"></span><br><span class="line">    [userDefaults setObject:self.userName forKey:@&quot;userNameKey&quot;];</span><br><span class="line">    [userDefaults setBool:self.isSavePasswd forKey:@&quot;isSavePwdKey&quot;];</span><br><span class="line">    [userDefaults synchronize];</span><br><span class="line"></span><br><span class="line">    if (self.isSavePasswd) &#123;</span><br><span class="line">        [SAMKeychain setPassword:self.userPasswd forService:[NSBundle mainBundle].bundleIdentifier account:self.userName];</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;保存用户登录信息&quot;);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        self.userPasswd = nil;</span><br><span class="line">        [SAMKeychain deletePasswordForService:[NSBundle mainBundle].bundleIdentifier account:self.userName];</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;不保存用户登录信息&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 读取用户登录信息</span><br><span class="line">- (void)loadUserLoginInfo &#123;</span><br><span class="line"></span><br><span class="line">    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line"></span><br><span class="line">    self.userName = [userDefaults objectForKey:@&quot;userNameKey&quot;];</span><br><span class="line">    self.savePasswd = [userDefaults boolForKey:@&quot;isSavePwdKey&quot;];</span><br><span class="line"></span><br><span class="line">    self.userPasswd = [SAMKeychain passwordForService:[NSBundle mainBundle].bundleIdentifier account:self.userName];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-3-好友管理"><a href="#4-3-好友管理" class="headerlink" title="4.3 好友管理"></a>4.3 好友管理</h2><ul>
<li><p>初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/// 遵守协议</span><br><span class="line">&lt;XMPPStreamDelegate, XMPPRosterDelegate, XMPPRosterMemoryStorageDelegate&gt;</span><br><span class="line"></span><br><span class="line">/// 好友列表</span><br><span class="line">@property (nonatomic, strong) XMPPRoster *roster;</span><br><span class="line"></span><br><span class="line">/// 本地好友存储器</span><br><span class="line">@property (nonatomic, strong) XMPPRosterMemoryStorage *rosterMemoryStorage;</span><br><span class="line"></span><br><span class="line">// 添加好友模块</span><br><span class="line">self.rosterMemoryStorage = [[XMPPRosterMemoryStorage alloc] init];</span><br><span class="line">self.roster = [[XMPPRoster alloc] initWithRosterStorage:self.rosterMemoryStorage</span><br><span class="line">                                          dispatchQueue:dispatch_get_global_queue(0, 0)];</span><br><span class="line">[self.roster activate:self.stream];                                       // 激活</span><br><span class="line">[self.roster addDelegate:self delegateQueue:dispatch_get_main_queue()];   // 设置代理</span><br><span class="line">[self.roster setAutoFetchRoster:YES];                                     // 设置好友同步策略，XMPP 一旦连接成功，自动同步好友到本地</span><br><span class="line">[self.roster setAutoAcceptKnownPresenceSubscriptionRequests:NO];          // 关掉自动接收好友请求，默认开启自动同意</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取好友列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 手动同步好友列表到本地好友存储器</span><br><span class="line">[self.roster fetchRoster];</span><br><span class="line"></span><br><span class="line">// 获取好友列表，从本地好友存储器中读取好友信息</span><br><span class="line">NSArray *users = self.rosterMemoryStorage.unsortedUsers;</span><br><span class="line"></span><br><span class="line">// 获取好友账号名称</span><br><span class="line">NSString *userName = [user[0] jid].user;</span><br><span class="line"></span><br><span class="line">// 获取好友昵称</span><br><span class="line">NSString *userName = [users[0] nickname];</span><br><span class="line"></span><br><span class="line">// 获取好友在线状态</span><br><span class="line">BOOL userStatus = [user[0] isOnline];</span><br><span class="line"></span><br><span class="line">#pragma mark XMPPRosterDelegate 协议方法</span><br><span class="line"></span><br><span class="line">    /// 开始同步好友列表到本地</span><br><span class="line">    - (void)xmppRosterDidBeginPopulating:(XMPPRoster *)sender withVersion:(NSString *)version &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 同步到一个好友节点到本地</span><br><span class="line">    - (void)xmppRoster:(XMPPRoster *)sender didReceiveRosterItem:(NSXMLElement *)item &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 同步好友列表到本地完成</span><br><span class="line">    - (void)xmppRosterDidEndPopulating:(XMPPRoster *)sender &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>刷新好友列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - XMPPRosterMemoryStorageDelegate 协议方法</span><br><span class="line"></span><br><span class="line">    /// 本地好友存储器发生改变</span><br><span class="line">    - (void)xmppRosterDidChange:(XMPPRosterMemoryStorage *)sender &#123;</span><br><span class="line"></span><br><span class="line">        // 如果设置了自动同步，当服务器的好友列表发生改变时，会自动同步存入本地好友存储器 </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>刷新好友状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark XMPPStreamDelegate 协议方法</span><br><span class="line"></span><br><span class="line">    /// 好友状态改变</span><br><span class="line">    - (void)xmppStream:(XMPPStream *)sender didReceivePresence:(XMPPPresence *)presence &#123;</span><br><span class="line"></span><br><span class="line">        // 收到对方取消定阅我的消息，对方删除我、对方状态改变</span><br><span class="line"></span><br><span class="line">        if ([presence.type isEqualToString:@&quot;unsubscribe&quot;]) &#123;</span><br><span class="line"></span><br><span class="line">            // 从我的本地好友存储器中将对方移除</span><br><span class="line">            [self.roster removeUser:presence.from];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加好友</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/// 添加好友，自定义方法</span><br><span class="line">- (void)addFriendWithUserName:(NSString *)userName remarkName:(NSString *)remarkName &#123;</span><br><span class="line"></span><br><span class="line">    NSString *jidString = userName;</span><br><span class="line"></span><br><span class="line">    // 判断有没有域名，如果没有域名，自己添加形成完整的 jid</span><br><span class="line">    NSString *domainString = [NSString stringWithFormat:@&quot;@%@&quot;, HOST_DOMAIN];</span><br><span class="line">    if (![jidString containsString:domainString]) &#123;</span><br><span class="line">        jidString = [jidString stringByAppendingString:domainString];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    XMPPJID *friendJID = [XMPPJID jidWithString:jidString];</span><br><span class="line"></span><br><span class="line">    // 添加好友，remarkName 为备注名称</span><br><span class="line">    [self.roster addUser:friendJID withNickname:remarkName];</span><br><span class="line"></span><br><span class="line">    // [self.roster subscribePresenceToUser:friendJID];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>收到添加好友申请</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark XMPPRosterDelegate 协议方法</span><br><span class="line"></span><br><span class="line">    /// 收到添加好友请求</span><br><span class="line">    - (void)xmppRoster:(XMPPRoster *)sender didReceivePresenceSubscriptionRequest:(XMPPPresence *)presence &#123;</span><br><span class="line"></span><br><span class="line">        NSString *name = [NSString stringWithFormat:@&quot;添加 %@ 为好友？&quot;, presence.from.user];</span><br><span class="line"></span><br><span class="line">        // 同意并添加对方为好友，YES 存入本地好友存储器</span><br><span class="line">        [self.roster acceptPresenceSubscriptionRequestFrom:presence.from andAddToRoster:YES];</span><br><span class="line"></span><br><span class="line">        // 拒绝添加对方为好友</span><br><span class="line">        [self.roster rejectPresenceSubscriptionRequestFrom:presence.from];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除好友</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/// 删除好友，自定义方法</span><br><span class="line">- (void)removeFriendWithUserName:(NSString *)userName &#123;</span><br><span class="line"></span><br><span class="line">    NSString *jidString = userName;</span><br><span class="line"></span><br><span class="line">    // 判断有没有域名，如果没有域名，自己添加形成完整的 jid</span><br><span class="line">    NSString *domainString = [NSString stringWithFormat:@&quot;@%@&quot;, HOST_DOMAIN];</span><br><span class="line">    if (![jidString containsString:domainString]) &#123;</span><br><span class="line">        jidString = [jidString stringByAppendingString:domainString];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    XMPPJID *friendJID = [XMPPJID jidWithString:jidString];</span><br><span class="line"></span><br><span class="line">    // 删除好友</span><br><span class="line">    [self.roster removeUser:friendJID];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-4-文本消息管理"><a href="#4-4-文本消息管理" class="headerlink" title="4.4 文本消息管理"></a>4.4 文本消息管理</h2><ul>
<li><p>初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/// 遵守协议</span><br><span class="line">&lt;XMPPStreamDelegate&gt;</span><br><span class="line"></span><br><span class="line">/// 定义 XMPP 服务器相关信息</span><br><span class="line">#define HOST_DOMAIN     @&quot;jhq0228-macbookair.local&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送文本消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/// 发送文本消息，自定义方法</span><br><span class="line">- (void)sendMessage:(NSString *)message toUser:(NSString *)userName &#123;</span><br><span class="line"></span><br><span class="line">    // 消息结构</span><br><span class="line">    /*</span><br><span class="line">        &lt;message type=&quot;chat&quot; to=&quot;xiaoming@example.com&quot;&gt;</span><br><span class="line">            &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">        &lt;/message&gt;</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    NSString *jidString = userName;                                             // 设置消息接收者</span><br><span class="line">    NSString *domainString = [NSString stringWithFormat:@&quot;@%@&quot;, HOST_DOMAIN];</span><br><span class="line">    if (![jidString containsString:domainString]) &#123;</span><br><span class="line">        jidString = [jidString stringByAppendingString:domainString];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 构建消息</span><br><span class="line">    NSXMLElement *msg = [NSXMLElement elementWithName:@&quot;message&quot;];</span><br><span class="line">    [msg addAttributeWithName:@&quot;type&quot; stringValue:@&quot;chat&quot;];</span><br><span class="line">    [msg addAttributeWithName:@&quot;to&quot; stringValue:jidString];</span><br><span class="line"></span><br><span class="line">    NSXMLElement *body = [NSXMLElement elementWithName:@&quot;body&quot;];</span><br><span class="line">    [body setStringValue:message];                                              // 设置文本消息内容</span><br><span class="line"></span><br><span class="line">    [msg addChild:body];</span><br><span class="line"></span><br><span class="line">    // 发送</span><br><span class="line">    [self.stream sendElement:msg];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接收文本消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark XMPPStreamDelegate 协议方法</span><br><span class="line"></span><br><span class="line">    /// 接收到消息</span><br><span class="line">    - (void)xmppStream:(XMPPStream *)sender didReceiveMessage:(XMPPMessage *)message &#123;</span><br><span class="line"></span><br><span class="line">        NSString *msg = [[message elementForName:@&quot;body&quot;] stringValue];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息回执</p>
<ul>
<li><p>这个是 XEP－0184 协议的内容。</p>
</li>
<li><p>发送消息时附加回执请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 消息结构</span><br><span class="line">/*</span><br><span class="line">    &lt;message</span><br><span class="line">        from=&quot;northumberland@shakespeare.lit/westminster&quot;</span><br><span class="line">        id=&quot;richars2-4.1.247&quot;</span><br><span class="line">        to=&quot;kingrichard@royalty.england.lit/throne&quot;&gt;</span><br><span class="line">        &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">        &lt;request xmlns=&quot;urn:xmpp:receipts&quot;/&gt;</span><br><span class="line">    &lt;/message&gt;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">NSString *jidString = userName;                                             // 设置消息接收者</span><br><span class="line">NSString *domainString = [NSString stringWithFormat:@&quot;@%@&quot;, HOST_DOMAIN];</span><br><span class="line">if (![jidString containsString:domainString]) &#123;</span><br><span class="line">    jidString = [jidString stringByAppendingString:domainString];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 构建消息</span><br><span class="line">NSString *siID = [XMPPStream generateUUID];</span><br><span class="line">XMPPJID *jid = [XMPPJID jidWithString:jidString];</span><br><span class="line"></span><br><span class="line">XMPPMessage *msg = [XMPPMessage messageWithType:@&quot;chat&quot; to:jid elementID:siID];</span><br><span class="line"></span><br><span class="line">NSXMLElement *receipt = [NSXMLElement elementWithName:@&quot;request&quot; xmlns:@&quot;urn:xmpp:receipts&quot;];</span><br><span class="line">[msg addChild:receipt];                                                     // 设置消息回执</span><br><span class="line"></span><br><span class="line">[msg addBody:message];                                                      // 设置消息内容</span><br><span class="line"></span><br><span class="line">// 发送</span><br><span class="line">[self.stream sendElement:msg];</span><br></pre></td></tr></table></figure>
</li>
<li><p>收到回执请求的消息，发送回执</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/// 接收到消息，XMPPStreamDelegate 协议方法</span><br><span class="line">- (void)xmppStream:(XMPPStream *)sender didReceiveMessage:(XMPPMessage *)message &#123;</span><br><span class="line"></span><br><span class="line">    // 消息结构</span><br><span class="line">    /*</span><br><span class="line">        &lt;message</span><br><span class="line">            from=&quot;kingrichard@royalty.england.lit/throne&quot;</span><br><span class="line">            id=&quot;bi29sg183b4v&quot;</span><br><span class="line">            to=&quot;northumberland@shakespeare.lit/westminster&quot;&gt;</span><br><span class="line">            &lt;received xmlns=&quot;urn:xmpp:receipts&quot; id=&quot;richars2-4.1.247&quot;&gt;</span><br><span class="line">        &lt;/message&gt;</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    // 回执判断</span><br><span class="line">    NSXMLElement *request = [message elementForName:@&quot;request&quot;];</span><br><span class="line"></span><br><span class="line">    if (request) &#123;</span><br><span class="line"></span><br><span class="line">        // 消息回执</span><br><span class="line">        if ([request.xmlns isEqualToString:@&quot;urn:xmpp:receipts&quot;]) &#123;</span><br><span class="line"></span><br><span class="line">            // 组装消息回执</span><br><span class="line">            XMPPMessage *msg = [XMPPMessage messageWithType:[message attributeStringValueForName:@&quot;type&quot;]</span><br><span class="line">                                                         to:message.from</span><br><span class="line">                                                  elementID:[message attributeStringValueForName:@&quot;id&quot;]];</span><br><span class="line"></span><br><span class="line">            NSXMLElement *recieved = [NSXMLElement elementWithName:@&quot;received&quot; xmlns:@&quot;urn:xmpp:receipts&quot;];</span><br><span class="line">            [msg addChild:recieved];</span><br><span class="line"></span><br><span class="line">            // 发送回执</span><br><span class="line">            [self.stream sendElement:msg];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        NSXMLElement *received = [message elementForName:@&quot;received&quot;];</span><br><span class="line"></span><br><span class="line">        if (received) &#123;</span><br><span class="line"></span><br><span class="line">            // 消息回执</span><br><span class="line">            if ([received.xmlns isEqualToString:@&quot;urn:xmpp:receipts&quot;]) &#123;</span><br><span class="line"></span><br><span class="line">                // 发送成功</span><br><span class="line">                NSLog(@&quot;message send success!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 消息处理</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="4-5-图片消息管理"><a href="#4-5-图片消息管理" class="headerlink" title="4.5 图片消息管理"></a>4.5 图片消息管理</h2><ul>
<li><p>图片和语音文件发送的基本思路：</p>
<ul>
<li>先将图片/语音转化成二进制文件，然后将二进制文件进行 base64 编码，编码成字符串。在即将发送的 message 内添加一个子节点，节点的 stringValue（节点的值）设置这个编码后的字符串。</li>
<li>然后消息发出后取出消息文件的时候，通过 messageType 先判断是不是图片/语音信息，如果是图片/语音信息先通过自己之前设置的节点名称，把这个子节点的 stringValue 取出来，应该是一个 base64 之后的字符串。</li>
</ul>
</li>
<li><p>选择图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/// 遵守协议</span><br><span class="line">&lt;UIImagePickerControllerDelegate, UINavigationControllerDelegate&gt;</span><br><span class="line"></span><br><span class="line">UIImagePickerController *picker = [[UIImagePickerController alloc]init];</span><br><span class="line">picker.delegate = self;</span><br><span class="line">[self presentViewController:picker animated:YES completion:nil];</span><br><span class="line"></span><br><span class="line">#pragma mark - UIImagePickerControllerDelegate 代理方法</span><br><span class="line"></span><br><span class="line">    - (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary *)info &#123;</span><br><span class="line"></span><br><span class="line">        UIImage *image = info[UIImagePickerControllerOriginalImage];</span><br><span class="line">        NSData *imageData = UIImagePNGRepresentation(image);</span><br><span class="line"></span><br><span class="line">        // 发送图片消息，自定义方法</span><br><span class="line">        [[XMPPManager defaultManager] sendMessage:imageData msgType:@&quot;image&quot; toUser:self.userName];</span><br><span class="line"></span><br><span class="line">        [self dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送图片消息</p>
<ul>
<li>msgType 自定义消息类型，image：图片消息，audio：音频消息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 发送图片消息</span><br><span class="line">[[XMPPManager defaultManager] sendMessage:imageData msgType:@&quot;image&quot; toUser:self.userName];</span><br><span class="line"></span><br><span class="line">/// 发送图片/音频消息，自定义方法</span><br><span class="line">- (void)sendMessage:(NSData *)msgData msgType:(NSString *)type toUser:(NSString *)userName &#123;</span><br><span class="line"></span><br><span class="line">    NSString *jidString = userName;                                             // 设置消息接收者</span><br><span class="line">    NSString *domainString = [NSString stringWithFormat:@&quot;@%@&quot;, HOST_DOMAIN];</span><br><span class="line">    if (![jidString containsString:domainString]) &#123;</span><br><span class="line">        jidString = [jidString stringByAppendingString:domainString];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    XMPPJID *jid = [XMPPJID jidWithString:jidString];</span><br><span class="line">    XMPPMessage *msg = [XMPPMessage messageWithType:@&quot;chat&quot; to:jid];</span><br><span class="line"></span><br><span class="line">    [msg addBody:type];</span><br><span class="line"></span><br><span class="line">    // 转换成 base64 的编码</span><br><span class="line">    NSString *base64str = [msgData base64EncodedStringWithOptions:0];</span><br><span class="line"></span><br><span class="line">    // 设置节点内容</span><br><span class="line">    XMPPElement *attachment = [XMPPElement elementWithName:@&quot;attachment&quot; stringValue:base64str];</span><br><span class="line"></span><br><span class="line">    // 包含子节点</span><br><span class="line">    [msg addChild:attachment];</span><br><span class="line"></span><br><span class="line">    // 发送消息</span><br><span class="line">    [self.stream sendElement:msg];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接收图片消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark XMPPStreamDelegate 协议方法</span><br><span class="line"></span><br><span class="line">    /// 接收到消息</span><br><span class="line">    - (void)xmppStream:(XMPPStream *)sender didReceiveMessage:(XMPPMessage *)message &#123;</span><br><span class="line"></span><br><span class="line">        if ([message.body isEqualToString:@&quot;image&quot;]) &#123;</span><br><span class="line"></span><br><span class="line">            for (XMPPElement *node in message.children) &#123;</span><br><span class="line"></span><br><span class="line">                // 取出消息的解码</span><br><span class="line">                NSString *base64str = node.stringValue;</span><br><span class="line">                NSData *data = [[NSData alloc] initWithBase64EncodedString:base64str options:0];</span><br><span class="line"></span><br><span class="line">                UIImage *image = [[UIImage alloc] initWithData:data];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-6-语音消息管理"><a href="#4-6-语音消息管理" class="headerlink" title="4.6 语音消息管理"></a>4.6 语音消息管理</h2><ul>
<li><p>图片和语音文件发送的基本思路：</p>
<ul>
<li>先将图片/语音转化成二进制文件，然后将二进制文件进行 base64 编码，编码成字符串。在即将发送的 message 内添加一个子节点，节点的 stringValue（节点的值）设置这个编码后的字符串。</li>
<li>然后消息发出后取出消息文件的时候，通过 messageType 先判断是不是图片/语音信息，如果是图片/语音信息先通过自己之前设置的节点名称，把这个子节点的 stringValue 取出来，应该是一个 base64 之后的字符串。</li>
</ul>
</li>
<li><p>录制／播放语音</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/// 包含头文件</span><br><span class="line">#import &lt;AVFoundation/AVFoundation.h&gt;</span><br><span class="line"></span><br><span class="line">/// 录音器</span><br><span class="line">@property(nonatomic, strong) AVAudioRecorder *recorder;</span><br><span class="line"></span><br><span class="line">/// 录音时长</span><br><span class="line">@property(nonatomic, assign) NSTimeInterval recordTime;</span><br><span class="line"></span><br><span class="line">/// 录音地址</span><br><span class="line">@property(nonatomic, strong) NSURL *recordURL;</span><br><span class="line"></span><br><span class="line">/// 播放器</span><br><span class="line">@property(nonatomic, strong) AVAudioPlayer *player;</span><br><span class="line"></span><br><span class="line">/// 开始录音</span><br><span class="line"></span><br><span class="line">    // 自定义方法</span><br><span class="line">    - (IBAction)startRecord:(UIButton *)sender &#123;</span><br><span class="line"></span><br><span class="line">        // 创建录音文件保存路径</span><br><span class="line">        NSString *urlStr = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class="line">        self.recordURL = [NSURL URLWithString:[urlStr stringByAppendingPathComponent:@&quot;myRecord.caf&quot;]];</span><br><span class="line"></span><br><span class="line">        // 创建录音格式设置</span><br><span class="line">        NSMutableDictionary *dicM = [NSMutableDictionary dictionary];</span><br><span class="line">        [dicM setObject:@(kAudioFormatLinearPCM) forKey:AVFormatIDKey];     // 设置录音格式</span><br><span class="line">        [dicM setObject:@(8000) forKey:AVSampleRateKey];                    // 设置录音采样率，8000 是电话采样率，对于一般录音已经够了</span><br><span class="line">        [dicM setObject:@(1) forKey:AVNumberOfChannelsKey];                 // 设置通道，这里采用单声道</span><br><span class="line">        [dicM setObject:@(8) forKey:AVLinearPCMBitDepthKey];                // 每个采样点位数，分为 8、16、24、32</span><br><span class="line">        [dicM setObject:@(YES) forKey:AVLinearPCMIsFloatKey];               // 是否使用浮点数采样</span><br><span class="line">        NSDictionary *setting = [dicM copy];</span><br><span class="line"></span><br><span class="line">        // 创建录音机</span><br><span class="line">        self.recorder = [[AVAudioRecorder alloc] initWithURL:self.recordURL settings:setting error:NULL];</span><br><span class="line"></span><br><span class="line">        // 开始录音</span><br><span class="line">        [self.recorder record];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">/// 停止录音</span><br><span class="line"></span><br><span class="line">    // 自定义方法</span><br><span class="line">    - (IBAction)stopRecord:(UIButton *)sender &#123;</span><br><span class="line"></span><br><span class="line">        NSTimeInterval time = self.recorder.currentTime;</span><br><span class="line">        [self.recorder stop];</span><br><span class="line"></span><br><span class="line">        if (time &lt; 1.5) &#123;</span><br><span class="line">            NSLog(@&quot;时间太短&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            NSLog(@&quot;录音完成&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">/// 播放录音</span><br><span class="line"></span><br><span class="line">    // 自定义方法</span><br><span class="line">    - (void)playAudioData:(NSData *)data &#123;</span><br><span class="line"></span><br><span class="line">        self.player = [[AVAudioPlayer alloc] initWithData:data error:NULL];</span><br><span class="line">        self.player.numberOfLoops = 0;</span><br><span class="line">        [self.player prepareToPlay];</span><br><span class="line">        [self.player play];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送语音消息</p>
<ul>
<li>msgType 自定义消息类型，image：图片消息，audio：音频消息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 发送语音消息</span><br><span class="line">NSData *audioData = [NSData dataWithContentsOfURL:self.recordURL];</span><br><span class="line">NSString *type = [NSString stringWithFormat:@&quot;audio:%.1f秒&quot;, self.recordTime];</span><br><span class="line">[[XMPPManager defaultManager] sendMessage:audioData msgType:type toUser:self.userName];</span><br><span class="line"></span><br><span class="line">/// 发送图片/音频消息，自定义方法</span><br><span class="line">- (void)sendMessage:(NSData *)msgData msgType:(NSString *)type toUser:(NSString *)userName &#123;</span><br><span class="line"></span><br><span class="line">    NSString *jidString = userName;                                             // 设置消息接收者</span><br><span class="line">    NSString *domainString = [NSString stringWithFormat:@&quot;@%@&quot;, HOST_DOMAIN];</span><br><span class="line">    if (![jidString containsString:domainString]) &#123;</span><br><span class="line">        jidString = [jidString stringByAppendingString:domainString];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    XMPPJID *jid = [XMPPJID jidWithString:jidString];</span><br><span class="line">    XMPPMessage *msg = [XMPPMessage messageWithType:@&quot;chat&quot; to:jid];</span><br><span class="line"></span><br><span class="line">    [msg addBody:type];</span><br><span class="line"></span><br><span class="line">    // 转换成 base64 的编码</span><br><span class="line">    NSString *base64str = [msgData base64EncodedStringWithOptions:0];</span><br><span class="line"></span><br><span class="line">    // 设置节点内容</span><br><span class="line">    XMPPElement *attachment = [XMPPElement elementWithName:@&quot;attachment&quot; stringValue:base64str];</span><br><span class="line"></span><br><span class="line">    // 包含子节点</span><br><span class="line">    [msg addChild:attachment];</span><br><span class="line"></span><br><span class="line">    // 发送消息</span><br><span class="line">    [self.stream sendElement:msg];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接收语音消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark XMPPStreamDelegate 协议方法</span><br><span class="line"></span><br><span class="line">    /// 接收到消息</span><br><span class="line">    - (void)xmppStream:(XMPPStream *)sender didReceiveMessage:(XMPPMessage *)message &#123;</span><br><span class="line"></span><br><span class="line">        if ([message.body hasPrefix:@&quot;audio&quot;]) &#123;</span><br><span class="line"></span><br><span class="line">            for (XMPPElement *node in message.children) &#123;</span><br><span class="line"></span><br><span class="line">                // 取出消息的解码</span><br><span class="line">                NSString *base64str = node.stringValue;</span><br><span class="line">                NSData *data = [[NSData alloc] initWithBase64EncodedString:base64str options:0];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-7-心跳检测"><a href="#4-7-心跳检测" class="headerlink" title="4.7 心跳检测"></a>4.7 心跳检测</h2><ul>
<li><p>为了监听服务器是否有效，增加心跳监听，用 XEP-0199 协议。</p>
</li>
<li><p>在 XMPPFrameWork 框架下，封装了 XMPPAutoPing 和 XMPPPing 两个类都可以使用，因为 XMPPAutoPing 已经组合进了 XMPPPing 类，所以 XMPPAutoPing 使用起来更方便。</p>
</li>
<li><p>初始化并启动 ping</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/// 包含头文件</span><br><span class="line">#import &lt;XMPPFramework/XMPPFramework.h&gt;</span><br><span class="line"></span><br><span class="line">/// 遵守协议</span><br><span class="line">&lt;XMPPAutoPingDelegate&gt;&gt;</span><br><span class="line"></span><br><span class="line">/// 心跳检测</span><br><span class="line">@property (nonatomic, strong) XMPPAutoPing *autoPing;</span><br><span class="line"></span><br><span class="line">// 添加心跳检测模块</span><br><span class="line">self.autoPing = [[XMPPAutoPing alloc] init];    // 发送的是一个 stream:ping，对方如果想表示自己是活跃的，应该返回一个 pong</span><br><span class="line">[self.autoPing activate:self.stream];           // 激活</span><br><span class="line">[self.autoPing addDelegate:self delegateQueue:dispatch_get_main_queue()];</span><br><span class="line">self.autoPing.pingInterval = 1000;              // 定时发送 ping 时间</span><br><span class="line">self.autoPing.respondsToQueries = YES;          // 不仅仅是服务器来得响应，如果是普通的用户，一样会响应</span><br><span class="line">self.autoPing.targetJID = [XMPPJID jidWithString:HOST_DOMAIN];      // 设置 ping 目标服务器</span><br><span class="line">                                                                   // 如果为 nil，则监听 stream 当前连接上的那个服务器</span><br><span class="line"></span><br><span class="line">#pragma mark - XMPPAutoPingDelegate 协议方法</span><br><span class="line"></span><br><span class="line">    /// 已经发送 ping</span><br><span class="line">    - (void)xmppAutoPingDidSendPing:(XMPPAutoPing *)sender &#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;xmppAutoPingDidSendPing&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 接收到 pong</span><br><span class="line">    - (void)xmppAutoPingDidReceivePong:(XMPPAutoPing *)sender &#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;xmppAutoPingDidReceivePong&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// ping 超时</span><br><span class="line">    - (void)xmppAutoPingDidTimeout:(XMPPAutoPing *)sender &#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;xmppAutoPingDidTimeout&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止 ping</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 停止 ping</span><br><span class="line">[self.autoPing deactivate];</span><br><span class="line">[self.autoPing removeDelegate:self];</span><br><span class="line">self.autoPing = nil;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-8-自动重连"><a href="#4-8-自动重连" class="headerlink" title="4.8 自动重连"></a>4.8 自动重连</h2><ul>
<li><p>当意外与服务器断开连接，自动重新连接上去，并且将上一次的信息自动加上去。</p>
</li>
<li><p>初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/// 包含头文件</span><br><span class="line">#import &lt;XMPPFramework/XMPPFramework.h&gt;</span><br><span class="line"></span><br><span class="line">/// 遵守协议</span><br><span class="line">&lt;XMPPReconnectDelegate&gt;&gt;</span><br><span class="line"></span><br><span class="line">/// 自动重连</span><br><span class="line">@property (nonatomic, strong) XMPPReconnect *reconnect;</span><br><span class="line"></span><br><span class="line">// 添加自动重连模块</span><br><span class="line">self.reconnect = [[XMPPReconnect alloc] init];</span><br><span class="line">[self.reconnect activate:self.stream];          // 激活</span><br><span class="line">[self.reconnect addDelegate:self delegateQueue:dispatch_get_main_queue()];</span><br><span class="line">self.reconnect.autoReconnect = YES;             // 设置是否自动重新连接</span><br><span class="line"></span><br><span class="line">#pragma mark - XMPPReconnectDelegate 协议方法</span><br><span class="line"></span><br><span class="line">    /// 设置是否自动重新连接</span><br><span class="line">    - (BOOL)xmppReconnect:(XMPPReconnect *)sender shouldAttemptAutoReconnect:(SCNetworkConnectionFlags)connectionFlags &#123;</span><br><span class="line"></span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 意外断开连接</span><br><span class="line">    - (void)xmppReconnect:(XMPPReconnect *)sender didDetectAccidentalDisconnect:(SCNetworkConnectionFlags)connectionFlags &#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;didDetectAccidentalDisconnect&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="http://www.cnblogs.com/QianChia/p/6411914.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h1 id="5、XMPPFramework-快速登录"><a href="#5、XMPPFramework-快速登录" class="headerlink" title="5、XMPPFramework 快速登录"></a>5、XMPPFramework 快速登录</h1><ul>
<li>具体讲解<a href="http://www.jianshu.com/p/cb6046376ccf" target="_blank" rel="noopener">链接</a></li>
</ul>
<p><a href="http://www.cnblogs.com/QianChia/p/6411914.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h1 id="6、XMPPFramework-重连以及其他问题"><a href="#6、XMPPFramework-重连以及其他问题" class="headerlink" title="6、XMPPFramework 重连以及其他问题"></a>6、XMPPFramework 重连以及其他问题</h1><ul>
<li>具体讲解<a href="http://www.jianshu.com/p/d9de0267c52a#" target="_blank" rel="noopener">链接</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/XMPP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/XMPP/" itemprop="url">
                  XMPP
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 16:43:44 / 修改时间：16:45:17" itemprop="dateCreated datePublished" datetime="2018-09-17T16:43:44+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络相关/" itemprop="url" rel="index"><span itemprop="name">网络相关</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[转自 <a href="https://www.jianshu.com/u/19f68e4b47ce" target="_blank" rel="noopener">iOS_成才录</a>]（<a href="https://www.jianshu.com/p/561224d0e91d）" target="_blank" rel="noopener">https://www.jianshu.com/p/561224d0e91d）</a></p>
<h2 id="一、即时通讯技术"><a href="#一、即时通讯技术" class="headerlink" title="一、即时通讯技术"></a>一、即时通讯技术</h2><ul>
<li><code>即时通讯技术</code>（<code>IM</code>– Instant Messaging）-&gt; 支持用户在线实时交谈</li>
<li>有许多的IM系统，如AOL、Yahoo IM、 MSN以及QQ，它们<code>最大的区别在于各自通讯协议的实现</code>，所以<code>n即时通讯技术的核心在于它的传输协议</code></li>
<li><code>协议</code>-&gt; 用来说明信息在网络上如何传输<ul>
<li>如果有了统一的传输协议，那么应当可以实现各个IM之间的直接通讯</li>
<li>为了创建即时通讯的统一标准，目前已经出现过的IM协议包括：<ul>
<li>IETF的对话初始协议（SIP）: SIP是建立VOIP连接的IETF标准，而VOIP就是网络电话</li>
<li>即时通讯对话初始协议和表示扩展协议（SIMPLE）</li>
<li>应用交换协议（APEX）、显示和即时通讯协议（PRIM）</li>
<li><code>基于XML且开放的可扩展通讯和表示协议（XMPP）协议</code>（常称为 Jabber 协议）</li>
</ul>
</li>
<li>人们多次努力，试图统一各大主要IM供应商的标准（AOL、Yahoo 及 Microsoft），但无一成功，且每一种IM仍然继续使用自己所拥有的协议</li>
</ul>
</li>
</ul>
<h2 id="二、XMPP简介"><a href="#二、XMPP简介" class="headerlink" title="二、XMPP简介"></a>二、XMPP简介</h2><blockquote>
<p>XMPP诞生的由来</p>
</blockquote>
<ul>
<li>都是遵守XMPP即时通讯协议<ul>
<li>设计一款全世界都使用的即时通讯协议，无论使用什么即时通讯软件，都可以互联互通</li>
</ul>
</li>
</ul>
<blockquote>
<p>XMPP起源</p>
</blockquote>
<ul>
<li><p><code>XMPP是基于XML的协议</code>，用于即时消息（IM）以及在线现场探测。最初，XMPP作为一个框架开发，目标是支持企业环境内的即时消息传递和联机状态应用程序。</p>
</li>
<li><p>XMPP的<code>前身是Jabber</code>（1998年），是一个开源组织定义的网络即时通信协议</p>
</li>
<li><p>XMPP是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个分散型通信网络</span><br></pre></td></tr></table></figure>
<ul>
<li>这意味着，只要网络基础设施允许，任何XMPP用户都可以向其他任何XMPP用户传递消息。</li>
<li>多个XMPP服务器也可以通过一个专门的“服务器-服务器”协议相互通信，提供了创建分散型社交网络和协作框架的可能性</li>
</ul>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/831339-66b057beede52e52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/567" alt="img"></p>
<p>XMPP工作原理示意图.png</p>
<blockquote>
<p>XMPP概述</p>
</blockquote>
<ul>
<li><code>XMPP是一种基于XML的协议</code><ul>
<li>它继承了在XML(可扩展标记语言)环境中灵活的发展性。这表明<code>XMPP是可扩展的</code>。</li>
<li><code>XMPP包含了针对服务器端的软件协议</code>，使之能与另一个进行通话，这使得开发者更容易建立客户应用程序或给一个配置好的系统添加功能</li>
</ul>
</li>
<li>XMPP的核心<code>XML流</code>传输协议的定义<ul>
<li>使得XMPP能够在一个比以往网络通信协议更规范的平台上。借助于XML易于解析和阅读的特性，使得XMPP的协议能够非常漂亮</li>
</ul>
</li>
<li>XMPP的扩展协议Jingle使得其支持语音和视频，目前iOS尚不支持</li>
<li>XMPP的官方文档是RFC 3920</li>
<li>XMPP协议曾经是Google力推的即时通信协议，<code>其代表作品是GTalk</code></li>
</ul>
<blockquote>
<p>Google Talk（GTalk）</p>
</blockquote>
<ul>
<li>Google Talk是Google的IM工具，除了具有IM功能外，另外还加上了Voip功能，“界面清新大方”，可直接链接Gmail，接受查看邮件</li>
<li>由于Google Talk是<code>基于Jabber开源标准，这种标准允许用户和其它的即时讯息系统相连</code>，比如苹果电脑的iChat，GAIM，Trillian Pro以及Psi。<code>Google Talk只能够在Windows平台上运行</code></li>
<li>Google Talk的用户无法使用这种软件与AIM，MSN Messenger或者雅虎Messenger的用户进行互通</li>
<li>2013年5月，在Google I/O大会上，Google推出统一跨平台聊天应用<code>Hangouts（环聊）取代Google Talk</code></li>
<li><code>Google Hangouts不支持XMPP协议</code>，Google Hangouts用户与如XMPP协议的强有力支持者jabber.org之间的交流无法进行</li>
<li>Hangouts目前在中国大陆无法使用，尚不支持iOS7.0</li>
<li><code>目前，Google Wave是基于XMPP协议的</code>，并且Google还开发Jingle扩展进行基于XMPP协议的视频聊天。尽管Google尚未宣布Talk的关闭日期，不过从Google关闭Reader和iCal支持来看，Talk关闭之日不会太远</li>
</ul>
<h1 id="三、XMPP定义"><a href="#三、XMPP定义" class="headerlink" title="三、XMPP定义"></a>三、XMPP定义</h1><ul>
<li>XMPP：<ul>
<li>The Extensible Messaging and Presence Protocol（<code>可扩展通讯和表示协议</code>）</li>
</ul>
</li>
<li>XMPP可用于服务类<code>实时通讯、表示和需求响应</code>服务中的XML数据元<code>流式传输</code>。<ul>
<li>XMPP以Jabber协议为基础，而Jabber是即时通讯中常用的开放式协议</li>
</ul>
</li>
<li>XMPP是基于XML的协议，<code>用于即时消息（IM）以及在线现场探测</code>。<ul>
<li>促进服务器之间的准即时操作。这个协议可能最终允许因特网用户向因特网上的其他任何人发送即时消息，即使其操作系统和浏览器不同</li>
</ul>
</li>
</ul>
<h1 id="四、XMPP的基本结构：典型的C-S架构"><a href="#四、XMPP的基本结构：典型的C-S架构" class="headerlink" title="四、XMPP的基本结构：典型的C/S架构"></a>四、XMPP的基本结构：典型的C/S架构</h1><ul>
<li><p>XMPP是一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">典型的C/S架构</span><br></pre></td></tr></table></figure>
<ul>
<li>而不是像大多数即时通讯软件一样，使用P2P客户端到客户端的架构</li>
<li>也就是说在大多数情况下，当两个客户端进行通讯时， 他们的消息都是通过服务器传递的。</li>
<li>优点：采用这种架构，主要是为了简化客户端，将大多数工作放在服务器端进行</li>
</ul>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/831339-20820e713477b568.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/944" alt="img"></p>
<p>架构.png</p>
<ul>
<li>XMPP中定义了三个角色：客户端，服务器，网关<ul>
<li>通信能够在这三者的任意两个之间双向发生</li>
<li>服务器 ： 同时承担了客户端信息记录，连接管理和信息的路由功能</li>
<li>网关 ： 承担着与异构即时通信系统的互联互通，异构系统可以包括SMS（短信），MSN，ICQ等</li>
</ul>
</li>
<li>基本的网络形式：<ul>
<li><code>单客户端通过TCP/IP连接到单服务器</code>，然后在之上<code>传输XML流</code></li>
</ul>
</li>
</ul>
<h1 id="五、XMPP工作原理"><a href="#五、XMPP工作原理" class="headerlink" title="五、XMPP工作原理"></a>五、XMPP工作原理</h1><ul>
<li>节点连接到服务器</li>
<li>服务器利用本地目录系统中的证书对其认证</li>
<li>节点指定目标地址，让服务器告知目标状态</li>
<li>服务器查找、连接并进行相互认证</li>
<li>节点之间进行交互</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/831339-66b057beede52e52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/567" alt="img"></p>
<p>XMPP工作原理示意图.png</p>
<h1 id="六、传输内容"><a href="#六、传输内容" class="headerlink" title="六、传输内容"></a>六、传输内容</h1><ul>
<li><p>XMPP应用传输的是与<code>即时通讯相关的指令</code></p>
</li>
<li><p>而XMPP传输的即时通讯指令的逻辑与以往相仿，只是协议的形式变成了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XML格式的纯文本</span><br></pre></td></tr></table></figure>
<p>。</p>
<ul>
<li>这不但使得解析容易了，人也容易阅读了，方便了开发和查错</li>
</ul>
</li>
<li><p>而XMPP的核心部分就是一个<code>在网络上分片段发送XML的流协议</code>。这个流协议是XMPP的即时通讯指令的传递基础，也是一个非常重要的可以被进一步利用的网络基础协议，可以说<code>XMPP用TCP传的是XML流</code></p>
</li>
</ul>
<h1 id="七、XMPP的优缺点"><a href="#七、XMPP的优缺点" class="headerlink" title="七、XMPP的优缺点"></a>七、XMPP的优缺点</h1><blockquote>
<p>优点</p>
</blockquote>
<ul>
<li>开放</li>
<li>标准（XMPP的技术规格已被定义在RFC 3920及RFC 3921）</li>
<li>证实可用，谷歌证实了GTalk</li>
<li>分散</li>
<li>安全</li>
<li>可扩展</li>
</ul>
<blockquote>
<p>缺点</p>
</blockquote>
<ul>
<li>数据负载过重XML</li>
<li>没有二进制传输</li>
</ul>
<h1 id="八、XMPP的传输小结"><a href="#八、XMPP的传输小结" class="headerlink" title="八、XMPP的传输小结"></a>八、XMPP的传输小结</h1><ul>
<li><p>XMPP是一种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类似于HTTP协议</span><br></pre></td></tr></table></figure>
<p>的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一种数据传输协议</span><br></pre></td></tr></table></figure>
<p>，</p>
<ul>
<li>其过程就如同“解包装–〉包装”的过程。只需要理解其接收的类型及返回的类型，便可以很好的利用XMPP来进行数据通讯</li>
</ul>
</li>
<li><p>XMPP官方网站——<a href="https://link.jianshu.com/?t=http://xmpp.org" target="_blank" rel="noopener">http://xmpp.org</a></p>
</li>
</ul>
<h1 id="九、XMPP——JID"><a href="#九、XMPP——JID" class="headerlink" title="九、XMPP——JID"></a>九、XMPP——JID</h1><ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个 XMPP客户端用户必须拥有一个全局惟一标识符。</span><br></pre></td></tr></table></figure>
<ul>
<li>基于历史原因，这些标识符称为<code>Jabber ID或JID</code>。鉴于协议的分布式特征，JID应包含联系用户所需的所有信息，JID的结构类似于电子邮件地址，但不要求 JID同时也是有效的电子邮件收件人</li>
</ul>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端和服务器节点，被统称为XMPP实体，都拥有JID</span><br></pre></td></tr></table></figure>
<p>。例如：SomeCorp公司的员工 John Doe可能拥有JID：用户名@服务器名称</p>
<ul>
<li>John.Doe@somecorp.com<ul>
<li>其中somecorp.com是 SomeCorp公司的<code>XMPP服务器的地址</code></li>
<li>John.Doe是John Doe的<code>用户名</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="十、环境搭建"><a href="#十、环境搭建" class="headerlink" title="十、环境搭建"></a>十、环境搭建</h1><ul>
<li><p>开发客户端：ios 、Xcode开发选择</p>
</li>
<li><p>服务器：Openfire选择</p>
</li>
<li><p>数据库：MySql选择</p>
<p>​</p>
<p>​</p>
<p><img src="http://upload-images.jianshu.io/upload_images/831339-8b20b7aea3780565.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/936" alt="img"></p>
<p>环境选择.png</p>
</li>
<li><p>安装MySQL管理工具——mysql-workbench</p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/Socket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/Socket/" itemprop="url">
                  Socket
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 16:38:42 / 修改时间：16:41:03" itemprop="dateCreated datePublished" datetime="2018-09-17T16:38:42+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络相关/" itemprop="url" rel="index"><span itemprop="name">网络相关</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[转自 <a href="https://blog.csdn.net/YEYUANGEN" target="_blank" rel="noopener">yeyuangen</a>]（<a href="https://blog.csdn.net/yeyuangen/article/details/6799575）" target="_blank" rel="noopener">https://blog.csdn.net/yeyuangen/article/details/6799575）</a></p>
<p>一、问题的引入——socket的引入是为了解决不同计算机间进程间通信的问题**</p>
<p><strong>1.socket与进程的关系</strong></p>
<p>1).socket与进程间的关系:socket   用来让一个进程和其他的进程互通信息(IPC)，而Socket接口是TCP/IP网络的API接口函数。</p>
<p>2).进程间通信（本机内）</p>
<p>进程间通信（不同计算机，要联网）</p>
<p><strong>2、**</strong>socket与文件的关系——<strong>**如何理解socket是种特殊的I/O?</strong></p>
<p>1）Socket最先应用于Unix操作系统,如果了解Unix系统的I/O的话，就很容易了解Socket了，因为Socket数据传输其实就是一种特殊的I/O。 </p>
<p>2）可对其进行文件操作</p>
<p>3）有文件描述符。而文件描述符的本质是一个非负整数。只是用于区分。类似的还有进程ID。</p>
<p><strong>3.服务器端口与连接个数的关系</strong><br>1）服务端在8088上监听，然后生成一个新的socket与client通讯。(注意：服务器端监听端口是<br>不变的，但socket连接可以一直生成，一个线程对应一个socket.)<br>同一时刻，一个端口只能建立一个连接。<br>在一个端口监听，但是在监听端口的同时，生成一个等待队列，每一个来自客户端的连接都会送入等待队列中，服务器利用一定的算法进行选择相应的连接请求处理，所以在一个端口可以监听多各请求嘛。如果同时的连接过多，服务器相应每个连接的时间就会相应的变长。就会变慢。<br>2）QQ的实现方法就是在登陆的时候告诉服务器你已经登陆，发送消息的时候，首先你会发送一个包给服务器，服务器查看你需要发送的对方是否在线，如果在线就返回包告诉你对方在线，然后你就会和对方建立一个连接，然后直接发消息给对方，如果对方不在线，那么就会通过服务器转发你这次的消息<br>3）网络IO数与你的CPU数目一致将是比较好的选择（考虑到多线程多进程可以提高效率）。<br>没有必要每个客户分配一个端口。绝对是一种无谓的浪费。 </p>
<p><strong>4.有人知道socket监听的一个端口.最多可以有多少个客户连接? </strong><br>1）listen()中有个参数，应该是确定并行连接客户数？！<br>2）The   maximum   length   of   the   queue   of   pending   connections.   If   this   value   is   SOMAXCONN,   then   the   underlying   service   provider   responsible   for   socket   s   will   set   the   backlog   to   a   maximum   “reasonable “   value.   There   is   no   standard   provision   to   find   out   the   actual   backlog   value.<br>3）linux2.4下，最多可以有1024个socket连接<br>4）同时连接请求好像是5个（是连接请求，不是连接），可保持的链接理论上是65535（2字节的SOCKET端口号），</p>
<p>3.Socket是网络上运行的两个程序间双向通讯的一端，它既可以接受请求，也可以发送请求，利用它可以较为方便的编写网络上数据的传递。</p>
<p><strong>5.问：现在server与client想建立socket连接，server仅知道client的IP，端口号不知道，能建立连接吗?怎么建立呢？有没有代码看看？</strong><br>答：C和S是相对而言的，发起连接的一方就是C，而监听端口接受连接的一方就是S，C如果不知道S监听的端口，怎么发起连接呢，<br>另外，对于S而言，端口是S上各个服务的区分标志，如果用错误的端口号去连接，是不能获得正确的服务的。<br><strong>client的端口是不需要指定的，Server绑定端口，然后监听，client使用server的IP和端口建立socket连接 </strong></p>
<hr>
<p><strong>6.精彩问答</strong></p>
<p><strong>问：看到的文章上说“每个网络通信循环地进出主计算机的TCP   应用层。它被两个所连接的号码唯一地识别。这两个号码合起来叫做套接字.组成套接字的这两个号码就是机器的IP   地址和TCP   软件所使用的端口号。” 又说“通过socket（）函数可以创建一个套接字，然后再把它绑定到端口号…” 那么套接字socket的概念究竟到哪里为止呢？是仅限于socket()返回的文件描述符？还是是IP和端口号的组合？如果是，那么socket()调用之后产生的套接字描述符的作用是什么呢？   套接字描述符，IP地址，端口号三者间的关系是怎样的？ 谢谢各位前辈解答。答：一个socket句柄代表两个地址对   “本地ip:port”–“远程ip:port”问：那么socket的概念到底到那里为止呢？比如，利用socket()可以产生一个套接字句柄，可是在bind()   或者   connect   ()   之前它只是一个文件描述符，和linux中其他的文件描述符一样。 如果说socket代表一个两个地址对，那么句柄的作用是不是仅仅是在bind()   或者   connect   ()   之后的用于区分和标记这样的地址对呢？因为这样他才能和网络的概念联系起来。这样的话，socket的意义应该是说用文件描述符描述的通信双方的IP地址和端口号地址对？（而文件描述符是区分这些地址对的标记？)答：socket为内核对象，由操作系统内核来维护其缓冲区，引用计数，并且可以在多个进程中使用。 至于称它为“句柄”“文件描述符”都是一样的，它只不过是内核开放给用户进程使用的整数而已问：谢谢楼上，是我没描述清楚。对于“句柄”和“文件描述符”我没有异议。 我想我的问题是在于句柄和ip、port的关系，不知道我这样说对否： 1.   每一个socket   本质上都是指一个ip地址和端口对 2.   为了操作这样的地址对，使用了文件描述符 3.   socket（）函数只创建了一个普通的文件描述符，在进行bind（）或者connect()之前并不能说创建了用于网络通讯的套接字 4.   只有在进行了bind（）或者connect()之后socket才被创立起来答：socket（）创建了一个socket内核对象。 accept或者connect后，才可以对socket句柄读写。因为只有在   connect或者bind,listen,accept后才会设置好socket内核对象里边的ip和端口 </strong></p>
<p><strong>二、**</strong>socket和端口理解**</p>
<p>一个socket句柄代表两个地址对 “本地ip:port”–“远程ip:port”<br>在windows下叫句柄，在linux下叫文件描述符<br>socket为内核对象，由操作系统内核来维护其缓冲区，引用计数，并且可以在多个进程中使用。 至于称它为“句柄”“文件描述符”都是一样的<br>我假定读者已经对于socket连接的建立过程和各种状态转换比较熟悉了，因为这篇文档的目的是澄清概念，而不是介绍概念。<br>在使用socket编程时，我们都知道在网络通信以前首先要建立连接，而连接的建立是通过对socket的一些操作来完成的。那么，建立连接的过程大致可以分为以下几步：<br>1） 建立socket套接字。<br>2） 给套接字赋予地址，这个地址不是通常的网络地址的概念。<br>3） 建立socket连接。<br>1． 建立socket套接字。<br>使用socket建立套接字的时候，我们实际上是建立了一个数据结构。这个数据结构最主要<br>的信息是指定了连接的种类和使用的协议，此外还有一些关于连接队列操作的结构字段<br>（这里就先不涉及他们了）。<br>当我们使用socket函数以后，如果成功的话会返回一个int型的描述符，它指向前面那个<br>被维护在内核里的socket数据结构。我们的任何操作都是通过这个描述符而作用到那个数<br>据结构上的。这就像是我们在建立一个文件后得到一个文件描述符一样，对文件的操作都<br>是通过文件描述符来进行的，而不是直接作用到inode数据结构上。我之所以用文件描述<br>符举例，是因为socket数据结构也是和inode数据结构密切相关，它不是独立存在于内核<br>中的，而是位于一个VFS inode结构中。所以，有一些比较抽象的特性，我们可以用文件<br>操作来不恰当的进行类比以加深理解。<br>如前所述，当建立了这个套接字以后，我们可以获得一个象文件描述符那样的套接字描述<br>符。就象我们对文件进行操作那样，我们可以通过向套接字里面写数据将数据传送到我们<br>指定的地方，这个地方可以是远端的主机，也可以是本地的主机。如果你有兴趣的话，还<br>可以用socket机制来实现IPC，不过效率比较低，试试也就行了（我没有试过）。<br>2． 给套接字赋予地址。<br>依照建立套接字的目的不同，赋予套接字地址的方式有两种：服务器端使用bind，客户端<br>使用connetc。<br>Bind:<br>我们都知道，只要使用IP, prot就可以区分一个tcp/ip连接（当然这个连接指的是一个<br>连接通道，如果要区分特定的主机间的连接，还需要第三个属性 hostname）。<br>我们可以使用bind函数来为一个使用在服务器端例程中的套接字赋予通信的地址和端口。<br>在这里我们称通信的IP地址和端口合起来构成了一个socket地址，而指定一个socket使<br>用特定的IP和port组合来进行通行的过程就是赋予这个socket一个地址。<br>要赋予socket地址，就得使用一个数据结构来指明特定的socket地址，这个数据结构就<br>是struct sockaddr。对它的使用我就不说了，因为这篇文档的目的是澄清概念而不是说<br>明使用方法。Bind函数的作用就是将这个特定的标注有socket地址信息的数据结构和<br>socket套接字联系起来，即赋予这个套接字一个地址。但是在具体实现上，他们两个是怎<br>么联系在一起的，我还不知道。<br>一个特定的socket的地址的生命期是bind成功以后到连接断开前。你可以建立一个<br>socket数据结构和socket地址的数据结构，但是在没有bind以前他们两个是没有关系<br>的，在bind以后他们两个才有了关系。这种关系一直维持到连接的结束，当一个连接结束<br>时，socket数据结构和socket地址的数据结构还都存在，但是他们两个已经没有关系<br>了。如果你要是用这个套接字在socket地址上重新进行连接时，需重新bind他们两个。再<br>注明一次，我说的这个连接是一个连接通道，而不是特定的主机之间的连接。<br>Bind指定的IP通常是本地IP（一般不特别指定，而使用INADDR_ANY来声明），而最主要<br>的作用是指定端口。在服务器端的socket进行了bind以后就是用listen来在这个socket<br>地址上准备进行连接。<br>connect:<br>对于客户端来说，是不会使用bind的（并不是不能用，但没什么意义），他们会通过<br>connet函数来建立socket和socket地址之间的关系。其中的socket地址是它想要连接的<br>服务器端的socket地址。在connect建立socket和socket地址两者关系的同时，它也在<br>尝试着建立远端的连接。<br>3． 建立socket连接。<br>对于准备建立一个连接，服务器端要两个步骤：bind, listen；客户端一个步骤：<br>connct。如果服务器端accept一个connect，而客户端得到了这个accept的确认，那么<br>一个连接就建立了。</p>
<p><strong>三、客户/</strong><a href="http://server.chinaitlab.com/" target="_blank" rel="noopener"><strong>服务器</strong></a><strong>模式模式的理解</strong></p>
<p>​    客户/服务器模式采取的是主动请求方式：</p>
<p>​    首先服务器方要先启动，并根据请求提供相应服务：</p>
<p>​    1. 打开一通信通道并告知本地主机，它愿意在某一公认地址上（周知口，如FTP为21）接收客户请求；</p>
<p>​    2. 等待客户请求到达该端口；</p>
<p>​    3. 接收到重复服务请求，处理该请求并发送应答信号。接收到并发服务请求，要激活一新进程来处理这个客户请求（如UNIX系统中用fork、exec）。新进程处理此客户请求，并不需要对其它请求作出应答。服务完成后，关闭此新进程与客户的通信链路，并终止。</p>
<p>​    4. 返回第二步，等待另一客户请求。</p>
<p>​    5. 关闭服务器</p>
<p>​    客户方：</p>
<p>​    1. 打开一通信通道，并连接到服务器所在主机的特定端口；</p>
<p>​    2. 向服务器发服务请求报文，等待并接收应答；继续提出请求……</p>
<p>​    3. 请求结束后关闭通信通道并终止。</p>
<p>​    从上面所描述过程可知：</p>
<p>​    1. 客户与服务器进程的作用是非对称的，因此编码不同。</p>
<p>​    2. 服务进程一般是先涌纪纪户请求而启动的。只要系统运行，该服务进程一直存在，直到正常或强迫终止。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/SDWebImage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/SDWebImage/" itemprop="url">
                  SDWebImage
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 16:21:42 / 修改时间：16:23:08" itemprop="dateCreated datePublished" datetime="2018-09-17T16:21:42+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/第三方源码/" itemprop="url" rel="index"><span itemprop="name">第三方源码</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.jianshu.com/p/be9a0a088feb" target="_blank" rel="noopener">转自 <a href="https://www.jianshu.com/u/cea4fc286dd3" target="_blank" rel="noopener">要上班的斌哥</a></a></p>
<p>在 iOS 的图片加载框架中，<strong>SDWebImage</strong>可谓是占据大半壁江山。它支持从网络中下载且缓存图片，并设置图片到对应的 UIImageView 控件或者 UIButton 控件。在项目中使用 SDWebImage 来管理图片加载相关操作可以极大地提高开发效率，让我们更加专注于业务逻辑实现。</p>
<h2 id="SDWebImage-概论"><a href="#SDWebImage-概论" class="headerlink" title="SDWebImage 概论"></a>SDWebImage 概论</h2><p>1.提供了一个 UIImageView 的 category 用来加载网络图片并且对网络图片的缓存进行管理<br>2.采用异步方式来下载网络图片<br>3.采用异步方式，使用 memory＋disk 来缓存网络图片，自动管理缓存。<br>4.支持 GIF 动画<br>5.支持 WebP 格式<br>6.同一个 URL 的网络图片不会被重复下载<br>7.失效的 URL 不会被无限重试<br>8.耗时操作都在子线程，确保不会阻塞主线程<br>9.使用 GCD 和 ARC<br>10.支持 Arm64</p>
<h2 id="SDWebImage-使用"><a href="#SDWebImage-使用" class="headerlink" title="SDWebImage 使用"></a>SDWebImage 使用</h2><p>1.使用 ImageView+WebCache category 来加载 UITableView 中 cell 的图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[cell.imageView sd_setImageWithURL:[NSURL URLWithString:@&quot;http://www.domain.com/path/to/image.jpg&quot;] placeholderImage:[UIImage imageNamed:@&quot;placeholder.png&quot;]];</span><br></pre></td></tr></table></figure>
<p>2.使用 block,采用这个方案可以在网络图片加载过程中得知图片的下载进度和图片加载成功与否</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[cell.imageView sd_setImageWithURL:[NSURL URLWithString:@&quot;http://www.domain.com/path/to/image.jpg&quot;] placeholderImage:[UIImage imageNamed:@&quot;placeholder.png&quot;] completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) &#123;</span><br><span class="line">    //... completion code here ... </span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure>
<p>3.使用 SDWebImageManager,SDWebImageManager 为UIImageView+WebCache category 的实现提供接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SDWebImageManager *manager = [SDWebImageManager sharedManager] ;</span><br><span class="line">[manager downloadImageWithURL:imageURL options:0 progress:^(NSInteger   receivedSize, NSInteger expectedSize) &#123; </span><br><span class="line">      // progression tracking code</span><br><span class="line"> &#125;  completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType,   BOOL finished, NSURL *imageURL) &#123; </span><br><span class="line">   if (image) &#123; </span><br><span class="line">    // do something with image</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure>
<p>4.加载图片还有使用 SDWebImageDownloader 和 SDImageCache 方式，但那个并不是我们经常用到的。基本上面所讲的3个方法都能满足需求。</p>
<h2 id="SDWebImage-流程"><a href="#SDWebImage-流程" class="headerlink" title="SDWebImage 流程"></a>SDWebImage 流程</h2><p><img src="http://upload-images.jianshu.io/upload_images/656644-7dfe370a86e157e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/559" alt="img"></p>
<p>UIImageView的图片加载流程</p>
<h2 id="SDWebImage-接口"><a href="#SDWebImage-接口" class="headerlink" title="SDWebImage 接口"></a>SDWebImage 接口</h2><p>SDWebImage 是一个成熟而且比较庞大的框架，但是在使用过程中并不需要太多的接口,这算是一种代码封装程度的体现。这里就介绍比较常用的几个接口。</p>
<ol>
<li><p>给 UIImageView 设置图片的接口，SDWebImage 有提供多个给UIImageView 设置图片的接口，最终所有的接口都会调用下图的这个接口，这是大多数框架的做法。</p>
<p>​</p>
<p>​</p>
<p><img src="http://upload-images.jianshu.io/upload_images/656644-0ba1638e8a0a7286.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>给UIImageView设置图片的接口</p>
</li>
<li><p>获取 SDWebImage 的磁盘缓存大小,在项目中有时候会需要统计应用的磁盘缓存内容大小，那么获取图片的缓存大小就是使用这个接口来实现</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[SDImageCache sharedImageCache] getSize];</span><br></pre></td></tr></table></figure>
<ol>
<li>清理内存缓存，清理内存中缓存的图片资源，释放内存资源。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[SDImageCache sharedImageCache] clearMemory];</span><br></pre></td></tr></table></figure>
<ol>
<li>有了清理内存缓存，自然也有清理磁盘缓存的接口</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[SDImageCache sharedImageCache] clearDisk];</span><br></pre></td></tr></table></figure>
<h2 id="SDWebImage-解析"><a href="#SDWebImage-解析" class="headerlink" title="SDWebImage 解析"></a>SDWebImage 解析</h2><p>解析主要围绕着 SDWebImage 的图片加载流程来分析，介绍SDWebImage 这个框架加载图片过程中的一些处理方法和设计思路。</p>
<ol>
<li><p>给 UIImageView 设置图片，然后 SDWebImage 调用这个最终的图片加载方法。</p>
<p>​</p>
<p>​</p>
<p><img src="http://upload-images.jianshu.io/upload_images/656644-2d901e0dff51aa2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>1 给UIImageView设置图片</p>
</li>
<li><p>开始加载之前图片先取消对应的 UIImageView 先前的图片下载操作。试想，如果我们给 UIImageView 设置了一张新的图片，那么我们还会在意该 UIImageVIew 先前是要加载哪一张图片么？应该是不在意的吧！那是不是应该尝试把该 UIImageView 先前的加载图片相关操作给取消掉呢?</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self sd_cancelCurrentImageLoad]</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/656644-11f5f798d3eea349.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>2 取消对应的UIImageView先前的图片下载操作</p>
<p>该方法经过周转，最后调用了以下方法，框架将图片对应的下载操作放到 UIView 的一个自定义字典属性 (operationDictionary) 中，取消下载操作第一步也是从这个 UIView 的自定义字典属性 (operationDictionary)中取出所有的下载操作，然后依次调用取消方法，最后将取消的操作从(operationDictionary) 字典属性中移除。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/656644-40612c8707dadb6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>最终的取消下载方法</p>
<p>3.移除之前没用的图片下载操作之后就创建一个新的图片下载操作，然后设置到 UIView 的一个自定义字典属性 (operationDictionary) 中。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/656644-2f571ad0bca60941.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>3 创建一个新的图片下载操作</p>
<p>4.看看如何创建一个新的图片下载操作,框架保存了一个失效的 url 列表，如果 url 失效了就会被加入这个列表，保证不会重复多次请求失效的 url。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/656644-6716a3ce4a660db1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>4 图片下载操作</p>
<p>根据给定的 url 生成一个唯一的 key ,之后利用这个 key 到缓存中查找对应的图片缓存。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/656644-e48fccf6e177fe15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>查找图片缓存</p>
<p>5.读取图片缓存,根据 key 先从内存中读取图片缓存，若没有命中内存缓存则读取磁盘缓存，如果磁盘缓存命中，那么将磁盘缓存读到内存中成为内存缓存。如果都没有命中缓存的话，那么就在执行的 doneBlock中开始下载图片。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/656644-68973ac3182fb40d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>5 读取图片缓存</p>
<p>6.图片下载操作完成后会将图片对应的数据通过 completedBlock 进行回调</p>
<p><img src="http://upload-images.jianshu.io/upload_images/656644-47cc23ae80d5d2fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>6 图片下载操作</p>
<p>在图片下载方法中，调用了一个方法用于添加创建和下载过程中的各类block 回调。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/656644-e191252d338aafb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>图片下载方法</p>
<p>添加该 url 加载过程的状态回调 block</p>
<p><img src="http://upload-images.jianshu.io/upload_images/656644-7920b864207377fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>状态回调Block</p>
<p>如果该 url 是第一次加载的话，那么就会执行 createCallback 这个回调block ,然后在 createCallback 里面开始构建网络请求，在下载过程中执行各类进度 block 回调。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/656644-0f04efcf3ac46f8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>构建网络请求</p>
<p>7.当图片下载完成之后会回到 done 的 block 回调中做图片转换处理和缓存操作</p>
<p><img src="http://upload-images.jianshu.io/upload_images/656644-18294fe3db2ed79a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>7 图片转换处理和缓存操作</p>
<p>回到 UIImageView 控件的设置图片方法 block 回调中，给对应的UIImageView 设置图片，操作流程到此完成。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/656644-c570c9791bb857d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>Block中设置图片</p>
<p>8.304 的处理<br>SDWebImage在加载图片网络请求的 NSURLConnection 的代理中对httpCode 做了判断，当 httpCode 为 304 的时候放弃下载，读取缓存。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/656644-6a8e47b73f5f0137.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>304处理</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SDWebImage 作为一个优秀的图片加载框架，提供的使用方法和接口对开发者来说非常友好。其内部实现多是采用 block 的方式来实现回调，代码阅读起来可能没有那么直观。此文章旨在给大家讲解 SDWebImage 这个框架的图片大概加载流程，其中具体细节限于篇幅无法详细深究。能力有限，文章中难免有错误，若大家在阅读过程中有发现不合理或者错误的地方恳请在评论中指出，我会在第一时间进行修正,不胜感激。</p>
<p>## </p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/AFNetworking（终）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/AFNetworking（终）/" itemprop="url">
                  AFNetworking（终）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 16:13:41 / 修改时间：16:18:58" itemprop="dateCreated datePublished" datetime="2018-09-17T16:13:41+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/第三方源码/" itemprop="url" rel="index"><span itemprop="name">第三方源码</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.jianshu.com/p/7ed7c0be15b4" target="_blank" rel="noopener">转自 <a href="https://www.jianshu.com/u/14431e509ae8" target="_blank" rel="noopener">涂耀辉</a></a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-426b7ad3b6d4e3ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/850" alt="img"></p>
<h6 id="写在开头："><a href="#写在开头：" class="headerlink" title="写在开头："></a>写在开头：</h6><ul>
<li>大概回忆下，之前我们讲了<code>AFNetworking</code>整个网络请求的流程，包括<code>request</code>的拼接，<code>session</code>代理的转发，<code>response</code>的解析。以及对一些<code>bug</code>的适配，如果你还没有看过，可以点这里：<br><a href="https://www.jianshu.com/p/856f0e26279d" target="_blank" rel="noopener">AFNetworking到底做了什么?</a><br><a href="https://www.jianshu.com/p/f32bd79233da" target="_blank" rel="noopener">AFNetworking到底做了什么（二）?</a></li>
<li>除此之外我们还单独的开了一篇讲了AF对<code>https</code>的处理：<br><a href="https://www.jianshu.com/p/a84237b07611" target="_blank" rel="noopener">AFNetworking之于https认证</a></li>
<li>还有一篇讲了讲AF对UIKit的扩展：<br><a href="https://www.jianshu.com/p/4ffeb1ba3046" target="_blank" rel="noopener">AFNetworking之UIKit扩展与缓存实现</a></li>
<li>本文将<strong>涉及AF2.x的核心实现，与AF3.x最新版本之间的对比，以及本系列的一个最终总结：AFNetworking到底做了什么？</strong></li>
</ul>
<h6 id="开始正文"><a href="#开始正文" class="headerlink" title="开始正文"></a>开始正文</h6><p>首先我们来看看AF2.x的项目目录:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-8c760bc6c51943f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>AF2.X源码结构图.png</p>
<p>除了UIKit扩展外，大概就是上述这么多类，其中最重要的有3个类：</p>
<p>1)<code>AFURLConnectionOperation</code><br>2)<code>AFHTTPRequestOperation</code><br>3)<code>AFHTTPRequestOperationManager</code></p>
<ul>
<li>大家都知道，AF2.x是基于<code>NSURLConnection</code>来封装的，而<code>NSURLConnection</code>的创建以及数据请求，就被封装在<code>AFURLConnectionOperation</code>这个类中。所以这个类基本上是AF2.x最底层也是最核心的类。</li>
<li>而<code>AFHTTPRequestOperation</code>是继承自<code>AFURLConnectionOperation</code>，对它父类一些方法做了些封装。</li>
<li><code>AFHTTPRequestOperationManager</code>则是一个管家，去管理这些这些<code>operation</code>。</li>
</ul>
<h6 id="我们接下来按照网络请求的流程去看看AF2-x的实现："><a href="#我们接下来按照网络请求的流程去看看AF2-x的实现：" class="headerlink" title="我们接下来按照网络请求的流程去看看AF2.x的实现："></a>我们接下来按照网络请求的流程去看看AF2.x的实现：</h6><p>注：本文会涉及一些<code>NSOperationQueue</code>、<code>NSOperation</code>方面的知识，如果对这方面的内容不了解的话，可以先看看雷纯峰的这篇：<br><a href="https://link.jianshu.com/?t=http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/" target="_blank" rel="noopener">iOS 并发编程之 Operation Queues</a></p>
<h6 id="首先，我们来写一个get或者post请求："><a href="#首先，我们来写一个get或者post请求：" class="headerlink" title="首先，我们来写一个get或者post请求："></a>首先，我们来写一个get或者post请求：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];</span><br><span class="line">[manager GET:url parameters:params</span><br><span class="line">     success:^(AFHTTPRequestOperation *operation, id responseObject) &#123;</span><br><span class="line">         </span><br><span class="line">     &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123;</span><br><span class="line">         </span><br><span class="line">     &#125;];</span><br></pre></td></tr></table></figure>
<p>就这么简单的几行代码，完成了一个网络请求。</p>
<p>接着我们来看看<code>AFHTTPRequestOperationManager</code>的初始化方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)manager &#123;</span><br><span class="line">    return [[self alloc] initWithBaseURL:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    return [self initWithBaseURL:nil];    </span><br><span class="line">&#125;</span><br><span class="line">- (instancetype)initWithBaseURL:(NSURL *)url &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (!self) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    // Ensure terminal slash for baseURL path, so that NSURL +URLWithString:relativeToURL: works as expected</span><br><span class="line">    if ([[url path] length] &gt; 0 &amp;&amp; ![[url absoluteString] hasSuffix:@&quot;/&quot;]) &#123;</span><br><span class="line">        url = [url URLByAppendingPathComponent:@&quot;&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    self.baseURL = url;</span><br><span class="line">    self.requestSerializer = [AFHTTPRequestSerializer serializer];</span><br><span class="line">    self.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line">    self.securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line">    self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line">    //用来调度所有请求的queue</span><br><span class="line">    self.operationQueue = [[NSOperationQueue alloc] init];</span><br><span class="line">    //是否做证书验证</span><br><span class="line">    self.shouldUseCredentialStorage = YES;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化方法很简单，基本和AF3.x类似，除了一下两点：<br>1)设置了一个<code>operationQueue</code>，这个队列，用来调度里面所有的<code>operation</code>，在AF2.x中，每一个<code>operation</code>就是一个网络请求。<br>2)设置<code>shouldUseCredentialStorage</code>为YES，这个后面会传给<code>operation</code>，<code>operation</code>会根据这个值，去返回给代理，系统是否做https的证书验证。</p>
<h6 id="然后我们来看看get方法："><a href="#然后我们来看看get方法：" class="headerlink" title="然后我们来看看get方法："></a>然后我们来看看get方法：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (AFHTTPRequestOperation *)GET:(NSString *)URLString</span><br><span class="line">                     parameters:(id)parameters</span><br><span class="line">                        success:(void (^)(AFHTTPRequestOperation *operation, id responseObject))success</span><br><span class="line">                        failure:(void (^)(AFHTTPRequestOperation *operation, NSError *error))failure</span><br><span class="line">&#123;</span><br><span class="line">    //拿到request</span><br><span class="line">    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:@&quot;GET&quot; URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:nil];</span><br><span class="line">    </span><br><span class="line">    AFHTTPRequestOperation *operation = [self HTTPRequestOperationWithRequest:request success:success failure:failure];</span><br><span class="line"></span><br><span class="line">    [self.operationQueue addOperation:operation];</span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法很简单，如下：<br>1）用<code>self.requestSerializer</code>生成了一个request，至于如何生成，可以参考之前的文章，这里就不赘述了。<br>2）生成了一个<code>AFHTTPRequestOperation</code>，然后把这个<code>operation</code>加到我们一开始创建的<code>queue</code>中。</p>
<p>其中创建<code>AFHTTPRequestOperation</code>方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (AFHTTPRequestOperation *)HTTPRequestOperationWithRequest:(NSURLRequest *)request</span><br><span class="line">                                                    success:(void (^)(AFHTTPRequestOperation *operation, id responseObject))success</span><br><span class="line">                                                    failure:(void (^)(AFHTTPRequestOperation *operation, NSError *error))failure</span><br><span class="line">&#123;</span><br><span class="line">    //创建自定义的AFHTTPRequestOperation</span><br><span class="line">    AFHTTPRequestOperation *operation = [[AFHTTPRequestOperation alloc] initWithRequest:request];</span><br><span class="line">    operation.responseSerializer = self.responseSerializer;</span><br><span class="line">    operation.shouldUseCredentialStorage = self.shouldUseCredentialStorage;</span><br><span class="line">    operation.credential = self.credential;</span><br><span class="line">    //设置自定义的安全策略</span><br><span class="line">    operation.securityPolicy = self.securityPolicy;</span><br><span class="line"></span><br><span class="line">    [operation setCompletionBlockWithSuccess:success failure:failure];</span><br><span class="line">    operation.completionQueue = self.completionQueue;</span><br><span class="line">    operation.completionGroup = self.completionGroup;</span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法创建了一个<code>AFHTTPRequestOperation</code>，并把自己的一些参数交给了这个<code>operation</code>处理。</p>
<h6 id="接着往里看："><a href="#接着往里看：" class="headerlink" title="接着往里看："></a>接着往里看：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithRequest:(NSURLRequest *)urlRequest &#123;</span><br><span class="line">    self = [super initWithRequest:urlRequest];</span><br><span class="line">    if (!self) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self.responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了设置了一个<code>self.responseSerializer</code>，实际上是调用了父类，也是我们最核心的类<code>AFURLConnectionOperation</code>的初始化方法，首先我们要明确<strong>这个类是继承自NSOperation的</strong>，然后我们接着往下看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//初始化</span><br><span class="line">- (instancetype)initWithRequest:(NSURLRequest *)urlRequest &#123;</span><br><span class="line">    NSParameterAssert(urlRequest);</span><br><span class="line"></span><br><span class="line">    self = [super init];</span><br><span class="line">    if (!self) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //设置为ready</span><br><span class="line">    _state = AFOperationReadyState;</span><br><span class="line">    //递归锁</span><br><span class="line">    self.lock = [[NSRecursiveLock alloc] init];</span><br><span class="line">    self.lock.name = kAFNetworkingLockName;</span><br><span class="line">    self.runLoopModes = [NSSet setWithObject:NSRunLoopCommonModes];</span><br><span class="line">    self.request = urlRequest;</span><br><span class="line">    </span><br><span class="line">    //是否应该咨询证书存储连接</span><br><span class="line">    self.shouldUseCredentialStorage = YES;</span><br><span class="line"></span><br><span class="line">    //https认证策略</span><br><span class="line">    self.securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化方法中，初始化了一些属性，下面我们来简单的介绍一下这些属性：</p>
<ol>
<li><code>_state</code>设置为<code>AFOperationReadyState</code> 准备就绪状态，这是个枚举：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, AFOperationState) &#123;</span><br><span class="line">    AFOperationPausedState      = -1,  //停止</span><br><span class="line">    AFOperationReadyState       = 1,   //准备就绪</span><br><span class="line">    AFOperationExecutingState   = 2,  //正在进行中</span><br><span class="line">    AFOperationFinishedState    = 3,  //完成</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个<code>_state</code>标志着这个网络请求的状态，一共如上4种状态。这些状态其实对应着<code>operation</code>如下的状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//映射这个operation的各个状态</span><br><span class="line">static inline NSString * AFKeyPathFromOperationState(AFOperationState state) &#123;</span><br><span class="line">    switch (state) &#123;</span><br><span class="line">        case AFOperationReadyState:</span><br><span class="line">            return @&quot;isReady&quot;;</span><br><span class="line">        case AFOperationExecutingState:</span><br><span class="line">            return @&quot;isExecuting&quot;;</span><br><span class="line">        case AFOperationFinishedState:</span><br><span class="line">            return @&quot;isFinished&quot;;</span><br><span class="line">        case AFOperationPausedState:</span><br><span class="line">            return @&quot;isPaused&quot;;</span><br><span class="line">        default: &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wunreachable-code&quot;</span><br><span class="line">            return @&quot;state&quot;;</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且还复写了这些属性的get方法，用来和自定义的state一一对应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//复写这些方法，与自己的定义的state对应</span><br><span class="line"> - (BOOL)isReady &#123;</span><br><span class="line">    return self.state == AFOperationReadyState &amp;&amp; [super isReady];</span><br><span class="line">&#125;</span><br><span class="line"> - (BOOL)isExecuting &#123;</span><br><span class="line">    return self.state == AFOperationExecutingState;</span><br><span class="line">&#125;</span><br><span class="line"> - (BOOL)isFinished &#123;</span><br><span class="line">    return self.state == AFOperationFinishedState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>self.lock</code>这个锁是用来提供给本类一些数据操作的线程安全，至于为什么要用递归锁，是因为有些方法可能会存在递归调用的情况，例如有些需要锁的方法可能会在一个大的操作环中，形成递归。<strong>而AF使用了递归锁，避免了这种情况下死锁的发生</strong>。</li>
<li>初始化了<code>self.runLoopModes</code>，默认为<code>NSRunLoopCommonModes</code>。</li>
<li>生成了一个默认的 <code>self.securityPolicy</code>,关于这个policy执行的https认证，可以见楼主之前的文章。</li>
</ol>
<p>这个类为了自定义<code>operation</code>的各种状态，而且更好的掌控它的生命周期，复写了<code>operation</code>的<code>start</code>方法，当这个<code>operation</code>在一个新线程被调度执行的时候，首先就调入这个<code>start</code>方法中，接下来我们它的实现看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)start &#123;</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    </span><br><span class="line">    //如果被取消了就调用取消的方法</span><br><span class="line">    if ([self isCancelled]) &#123;</span><br><span class="line">        //在AF常驻线程中去执行</span><br><span class="line">        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    //准备好了，才开始</span><br><span class="line">    else if ([self isReady]) &#123;</span><br><span class="line">        //改变状态，开始执行</span><br><span class="line">        self.state = AFOperationExecutingState;</span><br><span class="line">        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    //注意，发起请求和取消请求都是在同一个线程！！包括回调都是在一个线程</span><br><span class="line">    </span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法判断了当前的状态，是取消还是准备就绪，然后去调用了各自对应的方法。</p>
<ul>
<li>注意这些方法都是在另外一个线程中去调用的，我们来看看这个线程：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> + (void)networkRequestThreadEntryPoint:(id)__unused object &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];</span><br><span class="line"></span><br><span class="line">        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</span><br><span class="line">        //添加端口，防止runloop直接退出</span><br><span class="line">        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> + (NSThread *)networkRequestThread &#123;</span><br><span class="line">    static NSThread *_networkRequestThread = nil;</span><br><span class="line">    static dispatch_once_t oncePredicate;</span><br><span class="line">    dispatch_once(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    return _networkRequestThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个方法基本上是被许多人举例用过无数次了…</p>
<ul>
<li>这是一个单例，用<code>NSThread</code>创建了一个线程，并且为这个线程添加了一个<code>runloop</code>，并且加了一个<code>NSMachPort</code>，来防止<code>runloop</code>直接退出。</li>
<li><strong>这条线程就是AF用来发起网络请求，并且接受网络请求回调的线程，仅仅就这一条线程</strong>（到最后我们来讲为什么要这么做）。和我们之前讲的AF3.x发起请求，并且接受请求回调时的处理方式，遥相呼应。</li>
</ul>
<p>我们接着来看如果准备就绪，start调用的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//改变状态，开始执行</span><br><span class="line">self.state = AFOperationExecutingState;</span><br><span class="line">[self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</span><br></pre></td></tr></table></figure>
<p>接着在常驻线程中,并且不阻塞的方式，在我们<code>self.runLoopModes</code>的模式下调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)operationDidStart &#123;</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    //如果没取消</span><br><span class="line">    if (![self isCancelled]) &#123;</span><br><span class="line">        //设置为startImmediately YES 请求发出，回调会加入到主线程的 Runloop 下，RunloopMode 会默认为 NSDefaultRunLoopMode</span><br><span class="line">        self.connection = [[NSURLConnection alloc] initWithRequest:self.request delegate:self startImmediately:NO];</span><br><span class="line">        </span><br><span class="line">        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</span><br><span class="line">        for (NSString *runLoopMode in self.runLoopModes) &#123;</span><br><span class="line">            //把connection和outputStream注册到当前线程runloop中去，只有这样，才能在这个线程中回调</span><br><span class="line">            [self.connection scheduleInRunLoop:runLoop forMode:runLoopMode];</span><br><span class="line">            [self.outputStream scheduleInRunLoop:runLoop forMode:runLoopMode];</span><br><span class="line">        &#125;</span><br><span class="line">        //打开输出流</span><br><span class="line">        [self.outputStream open];</span><br><span class="line">        //开启请求</span><br><span class="line">        [self.connection start];</span><br><span class="line">    &#125;</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingOperationDidStartNotification object:self];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法做了以下几件事：</p>
<ol>
<li>首先这个方法创建了一个<code>NSURLConnection</code>，设置代理为自己，startImmediately为NO，至于这个参数干什么用的，我们来看看官方文档：</li>
</ol>
<blockquote>
<p>startImmediately<br>YES if the connection should begin loading data immediately, otherwise NO. If you pass NO, the connection is not scheduled with a run loop. You can then schedule the connection in the run loop and mode of your choice by calling scheduleInRunLoop:forMode: .</p>
</blockquote>
<p>大意是，这个值默认为YES，而且任务完成的结果会在主线程的runloop中回调。如果我们设置为NO，则需要调用我们下面看到的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.connection scheduleInRunLoop:runLoop forMode:runLoopMode];</span><br></pre></td></tr></table></figure>
<p>去注册一个runloop和mode，它会在我们指定的这个runloop所在的线程中回调结果。</p>
<ol>
<li>值得一提的是这里调用了:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.outputStream scheduleInRunLoop:runLoop forMode:runLoopMode];</span><br></pre></td></tr></table></figure>
<p>这个<code>outputStream</code>在get方法中被初始化了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> - (NSOutputStream *)outputStream &#123;</span><br><span class="line">    if (!_outputStream) &#123;</span><br><span class="line">        //一个写入到内存中的流，可以通过NSStreamDataWrittenToMemoryStreamKey拿到写入后的数据</span><br><span class="line">        self.outputStream = [NSOutputStream outputStreamToMemory];</span><br><span class="line">    &#125;</span><br><span class="line">    return _outputStream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里数据请求和拼接并没有用<code>NSMutableData</code>，而是用了<code>outputStream</code>，而且把写入的数据，放到内存中。</p>
<ul>
<li>其实讲道理来说<code>outputStream</code>的优势在于下载大文件的时候，可以以流的形式，将文件直接保存到本地，<strong>这样可以为我们节省很多的内存</strong>，调用如下方法设置：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSOutputStream outputStreamToFileAtPath:@&quot;filePath&quot; append:YES];</span><br></pre></td></tr></table></figure>
<ul>
<li>但是这里是把流写入内存中，这样其实这个节省内存的意义已经不存在了。那为什么还要用呢？这里我猜测的是就是为了用它这个可以注册在某一个<code>runloop</code>的指定<code>mode</code>下。 虽然AF使用这个<code>outputStream</code>是肯定在这个常驻线程中的，不会有线程安全的问题。但是要注意它是被声明在.h中的：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) NSOutputStream *outputStream;</span><br></pre></td></tr></table></figure>
<p>难保外部不会在其他线程对这个数据做什么操作，所以它相对于<code>NSMutableData</code>作用就体现出来了，就算我们在外部其它线程中去操作它，也不会有线程安全的问题。</p>
<ol>
<li>这个<code>connection</code>开始执行了。</li>
<li>到主线程发送一个任务开始执行的通知。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-7b6d90f1e5106673.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>分割图.png</p>
<h6 id="接下来网络请求开始执行了，就开始触发connection的代理方法了："><a href="#接下来网络请求开始执行了，就开始触发connection的代理方法了：" class="headerlink" title="接下来网络请求开始执行了，就开始触发connection的代理方法了："></a>接下来网络请求开始执行了，就开始触发<code>connection</code>的代理方法了：</h6><p><img src="https://upload-images.jianshu.io/upload_images/2702646-189b9c6e86564129.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>代理方法.png</p>
<p>AF2.x一共实现了如上这么多代理方法，这些代理方法，作用大部分和我们之前讲的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSURLSession</span><br></pre></td></tr></table></figure>
<p>的代理方法类似，我们只挑几个去讲，如果需要了解其他的方法作用，可以参考楼主之前的文章。</p>
<h6 id="重点讲下面这四个代理："><a href="#重点讲下面这四个代理：" class="headerlink" title="重点讲下面这四个代理："></a>重点讲下面这四个代理：</h6><p>注意，有一点需要说明，我们之前是把connection注册在我们常驻线程的runloop中了，<strong>所以以下所有的代理方法，都是在这仅有的一条常驻线程中回调。</strong></p>
<h6 id="第一个代理"><a href="#第一个代理" class="headerlink" title="第一个代理"></a>第一个代理</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//收到响应，响应头类似相关数据</span><br><span class="line">- (void)connection:(NSURLConnection __unused *)connection</span><br><span class="line">didReceiveResponse:(NSURLResponse *)response</span><br><span class="line">&#123;</span><br><span class="line">    self.response = response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没什么好说的，就是收到响应后，把response赋给自己的属性。</p>
<h6 id="第二个代理"><a href="#第二个代理" class="headerlink" title="第二个代理"></a>第二个代理</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//拼接获取到的数据</span><br><span class="line">- (void)connection:(NSURLConnection __unused *)connection</span><br><span class="line">    didReceiveData:(NSData *)data</span><br><span class="line">&#123;</span><br><span class="line">    NSUInteger length = [data length];</span><br><span class="line">    while (YES) &#123;</span><br><span class="line">        NSInteger totalNumberOfBytesWritten = 0;</span><br><span class="line">        //如果outputStream 还有空余空间</span><br><span class="line">        if ([self.outputStream hasSpaceAvailable]) &#123;</span><br><span class="line">           </span><br><span class="line">            //创建一个buffer流缓冲区，大小为data的字节数</span><br><span class="line">            const uint8_t *dataBuffer = (uint8_t *)[data bytes];</span><br><span class="line"></span><br><span class="line">            NSInteger numberOfBytesWritten = 0;</span><br><span class="line">           </span><br><span class="line">            //当写的长度小于数据的长度，在循环里</span><br><span class="line">            while (totalNumberOfBytesWritten &lt; (NSInteger)length) &#123;</span><br><span class="line">                //往outputStream写数据，系统的方法，一次就写一部分，得循环写</span><br><span class="line">                numberOfBytesWritten = [self.outputStream write:&amp;dataBuffer[(NSUInteger)totalNumberOfBytesWritten] maxLength:(length - (NSUInteger)totalNumberOfBytesWritten)];</span><br><span class="line">                //如果 numberOfBytesWritten写入失败了。跳出循环</span><br><span class="line">                if (numberOfBytesWritten == -1) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //加上每次写的长度</span><br><span class="line">                totalNumberOfBytesWritten += numberOfBytesWritten;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //出错</span><br><span class="line">        if (self.outputStream.streamError) &#123;</span><br><span class="line">            //取消connection</span><br><span class="line">            [self.connection cancel];</span><br><span class="line">            //调用失败的方法</span><br><span class="line">            [self performSelector:@selector(connection:didFailWithError:) withObject:self.connection withObject:self.outputStream.streamError];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //主线程回调下载数据大小</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        self.totalBytesRead += (long long)length;</span><br><span class="line"></span><br><span class="line">        if (self.downloadProgress) &#123;</span><br><span class="line">            self.downloadProgress(length, self.totalBytesRead, self.response.expectedContentLength);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法看起来长，其实容易理解而且简单，它只做了3件事：</p>
<ol>
<li>给<code>outputStream</code>拼接数据，具体如果拼接，大家可以读注释自行理解下。</li>
<li>如果出错则调用：<code>connection:didFailWithError:</code>也就是网络请求失败的代理，我们一会下面就会讲。</li>
<li>在主线程中回调下载进度。</li>
</ol>
<h6 id="第三个代理"><a href="#第三个代理" class="headerlink" title="第三个代理"></a>第三个代理</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//完成了调用</span><br><span class="line">- (void)connectionDidFinishLoading:(NSURLConnection __unused *)connection &#123;</span><br><span class="line"></span><br><span class="line">    //从outputStream中拿到数据 NSStreamDataWrittenToMemoryStreamKey写入到内存中的流</span><br><span class="line">    self.responseData = [self.outputStream propertyForKey:NSStreamDataWrittenToMemoryStreamKey];</span><br><span class="line"></span><br><span class="line">    //关闭outputStream</span><br><span class="line">    [self.outputStream close];</span><br><span class="line">    </span><br><span class="line">    //如果响应数据已经有了，则outputStream置为nil</span><br><span class="line">    if (self.responseData) &#123;</span><br><span class="line">       self.outputStream = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    //清空connection</span><br><span class="line">    self.connection = nil;</span><br><span class="line">    [self finish];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个代理是任务完成之后调用。我们从<code>outputStream</code>拿到了最后下载数据，然后关闭置空了<code>outputStream</code>。并且清空了<code>connection</code>。调用了<code>finish</code>:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> - (void)finish &#123;</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    //修改状态</span><br><span class="line">    self.state = AFOperationFinishedState;</span><br><span class="line">    [self.lock unlock];</span><br><span class="line"></span><br><span class="line">    //发送完成的通知</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingOperationDidFinishNotification object:self];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把当前任务状态改为已完成，并且到主线程发送任务完成的通知。，<strong>这里我们设置状态为已完成。其实调用了我们本类复写的set的方法</strong>（前面遗漏了，在这里补充）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> - (void)setState:(AFOperationState)state &#123;</span><br><span class="line">    </span><br><span class="line">    //判断从当前状态到另一个状态是不是合理，在加上现在是否取消。。大神的框架就是屌啊，这判断严谨的。。一层层</span><br><span class="line">    if (!AFStateTransitionIsValid(self.state, state, [self isCancelled])) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [self.lock lock];</span><br><span class="line">    </span><br><span class="line">    //拿到对应的父类管理当前线程周期的key</span><br><span class="line">    NSString *oldStateKey = AFKeyPathFromOperationState(self.state);</span><br><span class="line">    NSString *newStateKey = AFKeyPathFromOperationState(state);</span><br><span class="line">    </span><br><span class="line">    //发出KVO</span><br><span class="line">    [self willChangeValueForKey:newStateKey];</span><br><span class="line">    [self willChangeValueForKey:oldStateKey];</span><br><span class="line">    _state = state;</span><br><span class="line">    [self didChangeValueForKey:oldStateKey];</span><br><span class="line">    [self didChangeValueForKey:newStateKey];</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法改变<code>state</code>的时候，并且发送了<code>KVO</code>。大家了解<code>NSOperationQueue</code>就知道，如果对应的operation的属性<code>finnished</code>被设置为YES，则代表当前<code>operation</code>结束了，会把<code>operation</code>从队列中移除，并且调用<code>operation</code>的<code>completionBlock</code>。<strong>这点很重要，因为我们请求到的数据就是从这个completionBlock中传递回去的</strong>（下面接着讲这个完成Block，就能从这里对接上了）。</p>
<h6 id="第四个代理"><a href="#第四个代理" class="headerlink" title="第四个代理"></a>第四个代理</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//请求失败的回调，在cancel connection的时候，自己也主动调用了</span><br><span class="line">- (void)connection:(NSURLConnection __unused *)connection</span><br><span class="line">  didFailWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    //拿到error</span><br><span class="line">    self.error = error;</span><br><span class="line">    //关闭outputStream</span><br><span class="line">    [self.outputStream close];</span><br><span class="line">    //如果响应数据已经有了，则outputStream置为nil</span><br><span class="line">    if (self.responseData) &#123;</span><br><span class="line">        self.outputStream = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    self.connection = nil;</span><br><span class="line">    [self finish];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>唯一需要说一下的就是这里给<code>self.error</code>赋值，之后完成Block会根据这个error，去判断这次请求是成功还是失败。</p>
<p>至此我们把<code>AFURLConnectionOperation</code>的业务主线讲完了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-814a8ae5225854f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>分割图.png</p>
<p>我们此时数据请求完了，数据在<code>self.responseData</code>中，接下来我们来看它是怎么回到我们手里的。<br>我们回到<code>AFURLConnectionOperation</code>子类<code>AFHTTPRequestOperation</code>，有这么一个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- (void)setCompletionBlockWithSuccess:(void (^)(AFHTTPRequestOperation *operation, id responseObject))success</span><br><span class="line">                              failure:(void (^)(AFHTTPRequestOperation *operation, NSError *error))failure</span><br><span class="line">&#123;</span><br><span class="line">    // completionBlock is manually nilled out in AFURLConnectionOperation to break the retain cycle.</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-retain-cycles&quot;</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</span><br><span class="line">    self.completionBlock = ^&#123;</span><br><span class="line">        if (self.completionGroup) &#123;</span><br><span class="line">            dispatch_group_enter(self.completionGroup);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatch_async(http_request_operation_processing_queue(), ^&#123;</span><br><span class="line">            if (self.error) &#123;</span><br><span class="line">                if (failure) &#123;</span><br><span class="line">                    dispatch_group_async(self.completionGroup ?: http_request_operation_completion_group(), self.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                        failure(self, self.error);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                id responseObject = self.responseObject;</span><br><span class="line">                if (self.error) &#123;</span><br><span class="line">                    if (failure) &#123;</span><br><span class="line">                        dispatch_group_async(self.completionGroup ?: http_request_operation_completion_group(), self.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                            failure(self, self.error);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (success) &#123;</span><br><span class="line">                        dispatch_group_async(self.completionGroup ?: http_request_operation_completion_group(), self.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                            success(self, responseObject);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (self.completionGroup) &#123;</span><br><span class="line">                dispatch_group_leave(self.completionGroup);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始我们在<code>AFHTTPRequestOperationManager</code>中是调用过这个方法的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[operation setCompletionBlockWithSuccess:success failure:failure];</span><br></pre></td></tr></table></figure>
<ul>
<li>我们在把成功和失败的Block传给了这个方法。</li>
<li>这个方法也很好理解，就是设置我们之前提到过得<code>completionBlock</code>，<strong>当自己数据请求完成，就会调用这个Block。然后我们在这个Block中调用传过来的成功或者失败的Block。</strong>如果error为空，说明请求成功，把数据传出去，否则为失败，把error信息传出。</li>
<li>这里也类似AF3.x，可以自定义一个完成组和完成队列。数据可以在我们自定义的完成组和队列中回调出去。</li>
<li>除此之外，还有一个有意思的地方：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-retain-cycles&quot;</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</span><br><span class="line">#pragma clang diagnostic pop</span><br></pre></td></tr></table></figure>
<p>之前我们说过，这是在忽略编译器的一些警告。</p>
<ul>
<li><code>-Wgnu</code>就不说了，是忽略？：。</li>
<li>值得提下的是<code>-Warc-retain-cycles</code>，这里忽略了循环引用的警告。我们仔细看看就知道<code>self</code>持有了<code>completionBlock</code>，而<code>completionBlock</code>内部持有<code>self</code>。这里确实循环引用了。那么AF是如何解决这个循环引用的呢？</li>
</ul>
<p>我们在回到<code>AFURLConnectionOperation</code>，还有一个方法我们之前没讲到，它复写了setCompletionBlock这个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//复写setCompletionBlock</span><br><span class="line">- (void)setCompletionBlock:(void (^)(void))block &#123;</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    if (!block) &#123;</span><br><span class="line">        [super setCompletionBlock:nil];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        __weak __typeof(self)weakSelf = self;</span><br><span class="line">        [super setCompletionBlock:^ &#123;</span><br><span class="line">            __strong __typeof(weakSelf)strongSelf = weakSelf;</span><br><span class="line"></span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</span><br><span class="line">            //看有没有自定义的完成组，否则用AF的组</span><br><span class="line">            dispatch_group_t group = strongSelf.completionGroup ?: url_request_operation_completion_group();</span><br><span class="line">            //看有没有自定义的完成queue，否则用主队列</span><br><span class="line">            dispatch_queue_t queue = strongSelf.completionQueue ?: dispatch_get_main_queue();</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">            </span><br><span class="line">            //调用设置的Block,在这个组和队列中</span><br><span class="line">            dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">                block();</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            //结束时候置nil，防止循环引用</span><br><span class="line">            dispatch_group_notify(group, url_request_operation_completion_queue(), ^&#123;</span><br><span class="line">                [strongSelf setCompletionBlock:nil];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，它在我们设置的block调用结束的时候，主动的调用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[strongSelf setCompletionBlock:nil];</span><br></pre></td></tr></table></figure>
<p>把Block置空，这样循环引用不复存在了。</p>
<p>好像我们还遗漏了一个东西，就是返回的数据做类型的解析。其实还真不是楼主故意这样东一块西一块的，AF2.x有些代码确实是这样零散。。当然仅仅是相对3.x来说。AFNetworking整体代码质量，以及架构思想已经强过绝大多数开源项目太多了。。这一点毋庸置疑。</p>
<h6 id="我们来接着看看数据解析在什么地方被调用的把："><a href="#我们来接着看看数据解析在什么地方被调用的把：" class="headerlink" title="我们来接着看看数据解析在什么地方被调用的把："></a>我们来接着看看数据解析在什么地方被调用的把：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (id)responseObject &#123;</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    if (!_responseObject &amp;&amp; [self isFinished] &amp;&amp; !self.error) &#123;</span><br><span class="line">        NSError *error = nil;</span><br><span class="line">        //做数据解析</span><br><span class="line">        self.responseObject = [self.responseSerializer responseObjectForResponse:self.response data:self.responseData error:&amp;error];</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            self.responseSerializationError = error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">    return _responseObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AFHTTPRequestOperation</code> 复写了 <code>responseObject</code> 的get方法，<br>并且把数据按照我们需要的类型（json、xml等等）进行解析。至于如何解析，可以参考楼主之前AF系列的文章，这里就不赘述了。</p>
<p>有些小伙伴可能会说，楼主你是不是把<code>AFSecurityPolicy</code>给忘了啊，其实并没有，它被在 <code>AFURLConnectionOperation</code>中https认证的代理中被调用，我们之前系列的文章已经讲的非常详细了，感兴趣的朋友可以翻到前面的文章去看看。</p>
<p>至此，AF2.x整个业务流程就结束了。</p>
<p>接下来，我们来总结总结AF2.x整个业务请求的流程：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-eb8527a94ca620f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>AF2.x请求流程图.png</p>
<p>PS.图片是用page画的，第一次用，画了半个小时有没有…有没有感受到楼主很走心…最近发现写文图太少了，以后会多配图的。来加深大家的理解…</p>
<h6 id="如上图，我们来梳理一下整个流程："><a href="#如上图，我们来梳理一下整个流程：" class="headerlink" title="如上图，我们来梳理一下整个流程："></a>如上图，我们来梳理一下整个流程：</h6><ul>
<li>最上层的是<code>AFHTTPRequestOperationManager</code>,我们调用它进行get、post等等各种类型的网络请求</li>
<li>然后它去调用<code>AFURLRequestSerialization</code>做request参数拼装。然后生成了一个<code>AFHTTPRequestOperation</code>实例，并把request交给它。然后把<code>AFHTTPRequestOperation</code>添加到一个<code>NSOperationQueue</code>中。</li>
<li>接着<code>AFHTTPRequestOperation</code>拿到request后，会去调用它的父类<code>AFURLConnectionOperation</code>的初始化方法，并且把相关参数交给它，除此之外，当父类完成数据请求后，它调用了<code>AFURLResponseSerialization</code>把数据解析成我们需要的格式（json、XML等等）。</li>
<li>最后就是我们AF最底层的类<code>AFURLConnectionOperation</code>，它去数据请求，并且如果是https请求，会在请求的相关代理中，调用<code>AFSecurityPolicy</code>做https认证。最后请求到的数据返回。</li>
</ul>
<p>这就是AF2.x整个做网络请求的业务流程。</p>
<h6 id="我们来解决解决之前遗留下来的问题：为什么AF2-x需要一条常驻线程？"><a href="#我们来解决解决之前遗留下来的问题：为什么AF2-x需要一条常驻线程？" class="headerlink" title="我们来解决解决之前遗留下来的问题：为什么AF2.x需要一条常驻线程？"></a>我们来解决解决之前遗留下来的问题：为什么AF2.x需要一条常驻线程？</h6><p>首先如果我们用<code>NSURLConnection</code>，我们为了获取请求结果有以下三种选择：</p>
<ol>
<li>在主线程调异步接口</li>
<li>每一个请求用一个线程，对应一个runloop，然后等待结果回调。</li>
<li>只用一条线程，一个runloop，所有结果回调在这个线程上。</li>
</ol>
<p>很显然AF选择的是第3种方式，创建了一条常驻线程专门处理所有请求的回调事件，这个模型跟<code>nodejs</code>有点类似，我们来讨论讨论不选择另外两种方式的原因：</p>
<ol>
<li>试想如果我们所有的请求都在主线程中异步调用，好像没什么不可以？那为什么AF不这么做呢…在这里有两点原因（楼主个人总结的，有不同意见，欢迎讨论）：</li>
</ol>
<ul>
<li>第一是，如果我们放到主线程去做，势必要这么写：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSURLConnection alloc] initWithRequest:request delegate:self startImmediately:YES]</span><br></pre></td></tr></table></figure>
<p>这样NSURLConnection的回调会被放在主线程中<code>NSDefaultRunLoopMode</code>中，这样我们在其它类似<code>UITrackingRunLoopMode</code>模式下，我们是得不到网络请求的结果的，这显然不是我们想要的，那么我们势必需要调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[connection scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure>
<p>把它加入<code>`NSRunLoopCommonModes</code>中，试想如果有大量的网络请求，同时回调回来，就会影响我们的UI体验了。</p>
<ul>
<li>另外一点原因是，如果我们请求数据返回，势必要进行数据解析，解析成我们需要的格式，那么这些解析都在主线程中做，给主线程增加额外的负担。<br>又或者我们回调回来开辟一个新的线程去做数据解析，那么我们有n个请求回来开辟n条线程带来的性能损耗，以及线程间切换带来的损耗，是不是一笔更大的开销。</li>
</ul>
<p>所以综述两点原因，我们并不适合在主线程中回调。</p>
<ol>
<li>我们一开始就开辟n条线程去做请求，然后设置runloop保活住线程，等待结果回调。</li>
</ol>
<ul>
<li>其实看到这，大家想想都觉得这个方法很傻，为了等待不确定的请求结果，阻塞住线程，白白浪费n条线程的开销。</li>
</ul>
<p>综上所述，这就是<strong>AF2.x需要一条常驻线程的原因了</strong>。</p>
<h6 id="至此我们把AF2-x核心流程分析完了。"><a href="#至此我们把AF2-x核心流程分析完了。" class="headerlink" title="至此我们把AF2.x核心流程分析完了。"></a>至此我们把AF2.x核心流程分析完了。</h6><p><img src="https://upload-images.jianshu.io/upload_images/2702646-1e041546f1129535.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>分割图.png</p>
<p>接着到我们本系列一个最终总结了: <strong>AFNetworking到底做了什么？</strong></p>
<ul>
<li>相信如果从头看到尾的小伙伴，心里都有了一个属于自己的答案。其实在楼主心里，实在不想去总结它，因为<code>AFNetworking</code>中凝聚了太多大牛的思想，根本不是你看完几遍源码所能去议论的。但是想想也知道，如果我说不总结，估计有些看到这的朋友杀人的心都有…</li>
<li>所以我还是赶鸭子上架，来总结总结它。</li>
</ul>
<h6 id="AFNetworking的作用总结："><a href="#AFNetworking的作用总结：" class="headerlink" title="AFNetworking的作用总结："></a>AFNetworking的作用总结：</h6><p>一. 首先我们需要明确一点的是：<br><strong>相对于AFNetworking2.x，AFNetworking3.x确实没那么有用了。</strong>AFNetworking之前的核心作用就是为了帮我们去调度所有的请求。但是最核心地方却被苹果的<code>NSURLSession</code>给借鉴过去了，嗯…是借鉴。这些请求的调度，现在完全由<code>NSURLSession</code>给做了，AFNetworking3.x的作用被大大的削弱了。<br>二. 但是除此之外，其实它还是很有用的：</p>
<ol>
<li><strong>首先它帮我们做了各种请求方式request的拼接。</strong>想想如果我们用<code>NSURLSession</code>，我们去做请求，是不是还得自己去考虑各种请求方式下，拼接参数的问题。</li>
</ol>
<ul>
<li><strong>它还帮我们做了一些公用参数（session级别的），和一些私用参数（task级别的）的分离</strong>。它用Block的形式，支持我们自定义一些代理方法，如果没有实现的话，AF还帮我们做了一些默认的处理。而如果我们用<code>NSURLSession</code>的话，还得参照AF这么一套代理转发的架构模式去封装。</li>
<li><strong>它帮我们做了自定义的https认证处理</strong>。看过楼主之前那篇<a href="https://www.jianshu.com/p/a84237b07611" target="_blank" rel="noopener">AFNetworking之于https认证</a>的朋友就知道，如果我们自己用<code>NSURLSession</code>实现那几种自定义认证，需要多写多少代码…</li>
<li><strong>对于请求到的数据，AF帮我们做了各种格式的数据解析，并且支持我们设置自定义的code范围，自定义的数据方式</strong>。如果不在这些范围中，则直接调用失败block。如果用<code>NSURLSession</code>呢？这些都自己去写吧…（你要是做过各种除json外其他的数据解析,就会知道这里面坑有多少…）</li>
<li><strong>对于成功和失败的回调处理。</strong>AF帮我们在数据请求到，到回调给用户之间，做了各种错误的判断，保证了成功和失败的回调，界限清晰。在这过程中，AF帮我们做了太多的容错处理，而<code>NSURLSession</code>呢？只给了一个完成的回调，我们得多做多少判断，才能拿到一个确定能正常显示的数据？</li>
<li>……</li>
<li>…</li>
</ul>
<p>光是这些网络请求的业务逻辑，AF帮我们做的就太多太多，当然还远不仅于此。它用凝聚着许多大牛的经验方式，帮我在有些处理中做了最优的选择，比如我们之前说到的，回调线程数设置为1的问题…帮我们绕开了很多的坑，比如系统内部并行创建<code>task</code>导致id不唯一等等…</p>
<p>三. 而如果我们需要一些UIKit的扩展，AF则提供了最稳定，而且最优化实现方式：</p>
<ul>
<li>就比如之前说到过得那个状态栏小菊花，如果是我们自己去做，得多写多少代码，而且实现的还没有AF那样质量高。</li>
<li>又或者<code>AFImageDownloader</code>，它对于组图片之间的下载协调，以及缓存使用的之间线程调度。对于线程，锁，以及性能各方面权衡，找出最优化的处理方式，试问小伙伴们自己基于<code>NSURLSession</code>去写，能到做几分…</li>
</ul>
<p>所以最后的结论是：<strong>AFNetworking虽然变弱了，但是它还是很有用的。</strong>用它真的不仅仅是习惯，而是因为它确实帮我们做了太多。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/AFNetworking（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/AFNetworking（二）/" itemprop="url">
                  AFNetworking（二）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 16:08:54 / 修改时间：16:10:11" itemprop="dateCreated datePublished" datetime="2018-09-17T16:08:54+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/第三方源码/" itemprop="url" rel="index"><span itemprop="name">第三方源码</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[转自 <a href="https://www.jianshu.com/u/14431e509ae8" target="_blank" rel="noopener">涂耀辉</a>]<a href="https://www.jianshu.com/p/f32bd79233da" target="_blank" rel="noopener">https://www.jianshu.com/p/f32bd79233da</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-426b7ad3b6d4e3ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/850" alt="img"></p>
<h6 id="接着上一篇的内容往下讲，如果没看过上一篇内容可以点这："><a href="#接着上一篇的内容往下讲，如果没看过上一篇内容可以点这：" class="headerlink" title="接着上一篇的内容往下讲，如果没看过上一篇内容可以点这："></a>接着上一篇的内容往下讲，如果没看过上一篇内容可以点这：</h6><p><a href="https://www.jianshu.com/p/856f0e26279d" target="_blank" rel="noopener">AFNetworking到底做了什么?</a></p>
<p>之前我们讲到NSUrlSession代理这一块:</p>
<h6 id="代理8："><a href="#代理8：" class="headerlink" title="代理8："></a>代理8：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> task完成之后的回调，成功和失败都会回调这里</span><br><span class="line"> 函数讨论：</span><br><span class="line"> 注意这里的error不会报告服务期端的error，他表示的是客户端这边的eroor，比如无法解析hostname或者连不上host主机。</span><br><span class="line"> */</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didCompleteWithError:(NSError *)error</span><br><span class="line">&#123;   </span><br><span class="line">    //根据task去取我们一开始创建绑定的delegate</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];</span><br><span class="line"></span><br><span class="line">    // delegate may be nil when completing a task in the background</span><br><span class="line">    if (delegate) &#123;</span><br><span class="line">        //把代理转发给我们绑定的delegate</span><br><span class="line">        [delegate URLSession:session task:task didCompleteWithError:error];</span><br><span class="line">        //转发完移除delegate</span><br><span class="line">        [self removeDelegateForTask:task];</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    //自定义Block回调</span><br><span class="line">    if (self.taskDidComplete) &#123;</span><br><span class="line">        self.taskDidComplete(session, task, error);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代理就是task完成了的回调，方法内做了下面这几件事：</p>
<ul>
<li>在这里我们拿到了之前和这个task对应绑定的AF的delegate:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> - (AFURLSessionManagerTaskDelegate *)delegateForTask:(NSURLSessionTask *)task &#123;</span><br><span class="line">    NSParameterAssert(task);</span><br><span class="line"></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = nil;</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    delegate = self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)];</span><br><span class="line">    [self.lock unlock];</span><br><span class="line"></span><br><span class="line">    return delegate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>去转发了调用了AF代理的方法。这个等我们下面讲完NSUrlSession的代理之后会详细说。</li>
<li>然后把这个AF的代理和task的绑定解除了，并且移除了相关的progress和通知：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> - (void)removeDelegateForTask:(NSURLSessionTask *)task &#123;</span><br><span class="line">    NSParameterAssert(task);</span><br><span class="line">    //移除跟AF代理相关的东西</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    [delegate cleanUpProgressForTask:task];</span><br><span class="line">    [self removeNotificationObserverForTask:task];</span><br><span class="line">    [self.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用了自定义的Blcok:<code>self.taskDidComplete(session, task, error);</code><br>代码还是很简单的，至于这个通知，我们等会再来补充吧。</li>
</ul>
<h6 id="NSURLSessionDataDelegate"><a href="#NSURLSessionDataDelegate" class="headerlink" title="NSURLSessionDataDelegate:"></a>NSURLSessionDataDelegate:</h6><h6 id="代理9："><a href="#代理9：" class="headerlink" title="代理9："></a>代理9：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//收到服务器响应后调用</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">          dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">didReceiveResponse:(NSURLResponse *)response</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    //设置默认为继续进行</span><br><span class="line">    NSURLSessionResponseDisposition disposition = NSURLSessionResponseAllow;</span><br><span class="line"></span><br><span class="line">    //自定义去设置</span><br><span class="line">    if (self.dataTaskDidReceiveResponse) &#123;</span><br><span class="line">        disposition = self.dataTaskDidReceiveResponse(session, dataTask, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>官方文档翻译如下：</p>
<blockquote>
<p>函数作用：<br>告诉代理，该data task获取到了服务器端传回的最初始回复（response）。注意其中的completionHandler这个block，通过传入一个类型为NSURLSessionResponseDisposition的变量来决定该传输任务接下来该做什么：<br>NSURLSessionResponseAllow 该task正常进行<br>NSURLSessionResponseCancel 该task会被取消<br>NSURLSessionResponseBecomeDownload 会调用URLSession:dataTask:didBecomeDownloadTask:方法来新建一个download task以代替当前的data task<br>NSURLSessionResponseBecomeStream 转成一个StreamTask</p>
<p>函数讨论：<br>该方法是可选的，除非你必须支持“multipart/x-mixed-replace”类型的content-type。因为如果你的request中包含了这种类型的content-type，服务器会将数据分片传回来，而且每次传回来的数据会覆盖之前的数据。每次返回新的数据时，session都会调用该函数，你应该在这个函数中合理地处理先前的数据，否则会被新数据覆盖。如果你没有提供该方法的实现，那么session将会继续任务，也就是说会覆盖之前的数据。</p>
</blockquote>
<p>总结一下：</p>
<ul>
<li>当你把添加<code>content-type</code>的类型为<code>multipart/x-mixed-replace</code>那么服务器的数据会分片的传回来。然后这个方法是每次接受到对应片响应的时候会调被调用。你可以去设置上述4种对这个task的处理。</li>
<li>如果我们实现了自定义Block，则调用一下，不然就用默认的<code>NSURLSessionResponseAllow</code>方式。</li>
</ul>
<h6 id="代理10："><a href="#代理10：" class="headerlink" title="代理10："></a>代理10：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//上面的代理如果设置为NSURLSessionResponseBecomeDownload，则会调用这个方法</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">          dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">didBecomeDownloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class="line">&#123;</span><br><span class="line">    //因为转变了task，所以要对task做一个重新绑定</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask];</span><br><span class="line">    if (delegate) &#123;</span><br><span class="line">        [self removeDelegateForTask:dataTask];</span><br><span class="line">        [self setDelegate:delegate forTask:downloadTask];</span><br><span class="line">    &#125;</span><br><span class="line">    //执行自定义Block</span><br><span class="line">    if (self.dataTaskDidBecomeDownloadTask) &#123;</span><br><span class="line">        self.dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个代理方法是被上面的代理方法触发的，作用就是新建一个downloadTask，替换掉当前的dataTask。所以我们在这里做了AF自定义代理的重新绑定操作。</li>
<li>调用自定义Block。</li>
</ul>
<p>按照顺序来，其实还有个AF没有去实现的代理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//AF没实现的代理</span><br><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">didBecomeStreamTask:(NSURLSessionStreamTask *)streamTask;</span><br></pre></td></tr></table></figure>
<p>这个也是之前的那个代理，设置为<code>NSURLSessionResponseBecomeStream</code>则会调用到这个代理里来。会新生成一个<code>NSURLSessionStreamTask</code>来替换掉之前的dataTask。</p>
<h6 id="代理11："><a href="#代理11：" class="headerlink" title="代理11："></a>代理11：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//当我们获取到数据就会调用，会被反复调用，请求到的数据就在这被拼装完整</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">          dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">    didReceiveData:(NSData *)data</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask];</span><br><span class="line">    [delegate URLSession:session dataTask:dataTask didReceiveData:data];</span><br><span class="line">    if (self.dataTaskDidReceiveData) &#123;</span><br><span class="line">        self.dataTaskDidReceiveData(session, dataTask, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个方法和上面<code>didCompleteWithError</code>算是NSUrlSession的代理中最重要的两个方法了。</li>
<li>我们转发了这个方法到AF的代理中去，所以数据的拼接都是在AF的代理中进行的。这也是情理中的，毕竟每个响应数据都是对应各个task，各个AF代理的。在AFURLSessionManager都只是做一些公共的处理。</li>
</ul>
<h6 id="代理12："><a href="#代理12：" class="headerlink" title="代理12："></a>代理12：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*当task接收到所有期望的数据后，session会调用此代理方法。</span><br><span class="line">*/</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">          dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line"> willCacheResponse:(NSCachedURLResponse *)proposedResponse</span><br><span class="line"> completionHandler:(void (^)(NSCachedURLResponse *cachedResponse))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSCachedURLResponse *cachedResponse = proposedResponse;</span><br><span class="line"></span><br><span class="line">    if (self.dataTaskWillCacheResponse) &#123;</span><br><span class="line">        cachedResponse = self.dataTaskWillCacheResponse(session, dataTask, proposedResponse);</span><br><span class="line">    &#125;</span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(cachedResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>官方文档翻译如下：</p>
<blockquote>
<p>函数作用：<br>询问data task或上传任务（upload task）是否缓存response。</p>
<p>函数讨论：<br>当task接收到所有期望的数据后，session会调用此代理方法。如果你没有实现该方法，那么就会使用创建session时使用的configuration对象决定缓存策略。这个代理方法最初的目的是为了阻止缓存特定的URLs或者修改NSCacheURLResponse对象相关的userInfo字典。<br>该方法只会当request决定缓存response时候调用。作为准则，responses只会当以下条件都成立的时候返回缓存：<br>该request是HTTP或HTTPS URL的请求（或者你自定义的网络协议，并且确保该协议支持缓存）<br>确保request请求是成功的（返回的status code为200-299）<br>返回的response是来自服务器端的，而非缓存中本身就有的<br>提供的NSURLRequest对象的缓存策略要允许进行缓存<br>服务器返回的response中与缓存相关的header要允许缓存<br>该response的大小不能比提供的缓存空间大太多（比如你提供了一个磁盘缓存，那么response大小一定不能比磁盘缓存空间还要大5%）</p>
</blockquote>
<ul>
<li>总结一下就是一个用来缓存response的方法，方法中调用了我们自定义的Block，自定义一个response用来缓存。</li>
</ul>
<h6 id="NSURLSessionDownloadDelegate"><a href="#NSURLSessionDownloadDelegate" class="headerlink" title="NSURLSessionDownloadDelegate"></a>NSURLSessionDownloadDelegate</h6><h6 id="代理13："><a href="#代理13：" class="headerlink" title="代理13："></a>代理13：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//下载完成的时候调用</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(NSURL *)location</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask];</span><br><span class="line">    //这个是session的，也就是全局的，后面的个人代理也会做同样的这件事</span><br><span class="line">    if (self.downloadTaskDidFinishDownloading) &#123;</span><br><span class="line">        </span><br><span class="line">        //调用自定义的block拿到文件存储的地址</span><br><span class="line">        NSURL *fileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);</span><br><span class="line">        if (fileURL) &#123;</span><br><span class="line">            delegate.downloadFileURL = fileURL;</span><br><span class="line">            NSError *error = nil;</span><br><span class="line">            //从临时的下载路径移动至我们需要的路径</span><br><span class="line">            [[NSFileManager defaultManager] moveItemAtURL:location toURL:fileURL error:&amp;error];</span><br><span class="line">            //如果移动出错</span><br><span class="line">            if (error) &#123;</span><br><span class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:error.userInfo];</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //转发代理</span><br><span class="line">    if (delegate) &#123;</span><br><span class="line">        [delegate URLSession:session downloadTask:downloadTask didFinishDownloadingToURL:location];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个方法和之前的两个方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)taskdidCompleteWithError:(NSError *)error;</span><br><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data;</span><br></pre></td></tr></table></figure>
<p>总共就这3个方法，被转调到AF自定义delegate中。</p>
<ul>
<li>方法做了什么看注释应该很简单，就不赘述了。</li>
</ul>
<h6 id="代理14："><a href="#代理14：" class="headerlink" title="代理14："></a>代理14：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//周期性地通知下载进度调用</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class="line">      didWriteData:(int64_t)bytesWritten</span><br><span class="line"> totalBytesWritten:(int64_t)totalBytesWritten</span><br><span class="line">totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite</span><br><span class="line">&#123;</span><br><span class="line">    if (self.downloadTaskDidWriteData) &#123;</span><br><span class="line">        self.downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单说一下这几个参数:<br><code>bytesWritten</code> 表示自上次调用该方法后，接收到的数据字节数<br><code>totalBytesWritten</code>表示目前已经接收到的数据字节数<br><code>totalBytesExpectedToWrite</code> 表示期望收到的文件总字节数，是由Content-Length header提供。如果没有提供，默认是NSURLSessionTransferSizeUnknown。</p>
<h6 id="代理15："><a href="#代理15：" class="headerlink" title="代理15："></a>代理15：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//当下载被取消或者失败后重新恢复下载时调用</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class="line"> didResumeAtOffset:(int64_t)fileOffset</span><br><span class="line">expectedTotalBytes:(int64_t)expectedTotalBytes</span><br><span class="line">&#123;</span><br><span class="line">    //交给自定义的Block去调用</span><br><span class="line">    if (self.downloadTaskDidResume) &#123;</span><br><span class="line">        self.downloadTaskDidResume(session, downloadTask, fileOffset, expectedTotalBytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>官方文档翻译：</p>
<blockquote>
<p>函数作用：<br>告诉代理，下载任务重新开始下载了。</p>
<p>函数讨论：<br>如果一个正在下载任务被取消或者失败了，你可以请求一个resumeData对象（比如在userInfo字典中通过NSURLSessionDownloadTaskResumeData这个键来获取到resumeData）并使用它来提供足够的信息以重新开始下载任务。<br>随后，你可以使用resumeData作为downloadTaskWithResumeData:或downloadTaskWithResumeData:completionHandler:的参数。当你调用这些方法时，你将开始一个新的下载任务。一旦你继续下载任务，session会调用它的代理方法URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:其中的downloadTask参数表示的就是新的下载任务，这也意味着下载重新开始了。</p>
</blockquote>
<p>总结一下：</p>
<ul>
<li><strong>其实这个就是用来做断点续传的代理方法。</strong>可以在下载失败的时候，拿到我们失败的拼接的部分<code>resumeData</code>，然后用去调用<code>downloadTaskWithResumeData：</code>就会调用到这个代理方法来了。</li>
<li>其中注意：<code>fileOffset</code>这个参数，如果文件缓存策略或者最后文件更新日期阻止重用已经存在的文件内容，那么该值为0。否则，该值表示当前已经下载data的偏移量。</li>
<li>方法中仅仅调用了<code>downloadTaskDidResume</code>自定义Block。</li>
</ul>
<p>至此NSUrlSesssion的delegate讲完了。大概总结下：</p>
<ul>
<li>每个代理方法对应一个我们自定义的Block,如果Block被赋值了，那么就调用它。</li>
<li>在这些代理方法里，我们做的处理都是相对于这个sessionManager所有的request的。<strong>是公用的处理。</strong></li>
<li>转发了3个代理方法到AF的deleagate中去了，AF中的deleagate是需要对应每个task去<strong>私有化处理的</strong>。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-1a1e7b3d10278aa1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>分割图.png</p>
<p>接下来我们来看转发到AF的deleagate，一共3个方法：</p>
<h6 id="AF代理1："><a href="#AF代理1：" class="headerlink" title="AF代理1："></a>AF代理1：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">//AF实现的代理！被从urlsession那转发到这</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(__unused NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didCompleteWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</span><br><span class="line">    </span><br><span class="line">    //1）强引用self.manager，防止被提前释放；因为self.manager声明为weak,类似Block</span><br><span class="line"></span><br><span class="line">    __strong AFURLSessionManager *manager = self.manager;</span><br><span class="line"></span><br><span class="line">    __block id responseObject = nil;</span><br><span class="line"></span><br><span class="line">    //用来存储一些相关信息，来发送通知用的</span><br><span class="line">    __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];</span><br><span class="line">    //存储responseSerializer响应解析对象</span><br><span class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</span><br><span class="line"></span><br><span class="line">    //Performance Improvement from #2672</span><br><span class="line">    </span><br><span class="line">    //注意这行代码的用法，感觉写的很Nice...把请求到的数据data传出去，然后就不要这个值了释放内存</span><br><span class="line">    NSData *data = nil;</span><br><span class="line">    if (self.mutableData) &#123;</span><br><span class="line">        data = [self.mutableData copy];</span><br><span class="line">        //We no longer need the reference, so nil it out to gain back some memory.</span><br><span class="line">        self.mutableData = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //继续给userinfo填数据</span><br><span class="line">    if (self.downloadFileURL) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;</span><br><span class="line">    &#125; else if (data) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</span><br><span class="line">    &#125;</span><br><span class="line">    //错误处理</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        </span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</span><br><span class="line">        </span><br><span class="line">        //可以自己自定义完成组 和自定义完成queue,完成回调</span><br><span class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            if (self.completionHandler) &#123;</span><br><span class="line">                self.completionHandler(task.response, responseObject, error);</span><br><span class="line">            &#125;</span><br><span class="line">            //主线程中发送完成通知</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //url_session_manager_processing_queue AF的并行队列</span><br><span class="line">        dispatch_async(url_session_manager_processing_queue(), ^&#123;</span><br><span class="line">            NSError *serializationError = nil;</span><br><span class="line">            </span><br><span class="line">            //解析数据</span><br><span class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br><span class="line">            </span><br><span class="line">            //如果是下载文件，那么responseObject为下载的路径</span><br><span class="line">            if (self.downloadFileURL) &#123;</span><br><span class="line">                responseObject = self.downloadFileURL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //写入userInfo</span><br><span class="line">            if (responseObject) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //如果解析错误</span><br><span class="line">            if (serializationError) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</span><br><span class="line">            &#125;</span><br><span class="line">            //回调结果</span><br><span class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                if (self.completionHandler) &#123;</span><br><span class="line">                    self.completionHandler(task.response, responseObject, serializationError);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是NSUrlSession任务完成的代理方法中，主动调用过来的。配合注释，应该代码很容易读，这个方法大概做了以下几件事：</p>
<ol>
<li>生成了一个存储这个task相关信息的字典：<code>userInfo</code>，这个字典是用来作为发送任务完成的通知的参数。</li>
</ol>
<ul>
<li>判断了参数<code>error</code>的值，来区分请求成功还是失败。</li>
<li>如果成功则在一个AF的并行queue中，去做数据解析等后续操作：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static dispatch_queue_t url_session_manager_processing_queue() &#123;</span><br><span class="line">    static dispatch_queue_t af_url_session_manager_processing_queue;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        af_url_session_manager_processing_queue = dispatch_queue_create(&quot;com.alamofire.networking.session.manager.processing&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return af_url_session_manager_processing_queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意AF的优化的点，虽然代理回调是串行的(不明白可以见本文最后)。但是数据解析这种费时操作，确是用并行线程来做的。</p>
<ul>
<li>然后根据我们一开始设置的<code>responseSerializer</code>来解析data。如果解析成功，调用成功的回调，否则调用失败的回调。<br>我们重点来看看返回数据解析这行：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br></pre></td></tr></table></figure>
<p>我们点进去看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  @protocol AFURLResponseSerialization &lt;NSObject, NSSecureCoding, NSCopying&gt;</span><br><span class="line"></span><br><span class="line">  - (nullable id)responseObjectForResponse:(nullable NSURLResponse *)response</span><br><span class="line">                           data:(nullable NSData *)data</span><br><span class="line">                          error:(NSError * _Nullable __autoreleasing *)error NS_SWIFT_NOTHROW;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>原来就是这么一个协议方法，各种类型的responseSerializer类，都是遵守这个协议方法，实现了一个把我们请求到的data转换为我们需要的类型的数据的方法。至于各种类型的responseSerializer如何解析数据，我们到代理讲完再来补充。</p>
<ul>
<li>这边还做了一个判断，如果自定义了GCD完成组<code>completionGroup</code>和完成队列的话<code>completionQueue</code>，会在加入这个组和在队列中回调Block。否则默认的是AF的创建的组：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static dispatch_group_t url_session_manager_completion_group() &#123;</span><br><span class="line">    static dispatch_group_t af_url_session_manager_completion_group;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        af_url_session_manager_completion_group = dispatch_group_create();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return af_url_session_manager_completion_group;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和主队列回调。<strong>AF没有用这个GCD组做任何处理，只是提供这个接口，让我们有需求的自行调用处理。</strong>如果有对多个任务完成度的监听，可以自行处理。<br>而队列的话，如果你不需要回调主线程，可以自己设置一个回调队列。</p>
<ul>
<li>回到主线程，发送了任务完成的通知：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>
<p>这个通知这回AF有用到了，在我们对UIKit的扩展中，用到了这个通知。</p>
<h6 id="AF代理2："><a href="#AF代理2：" class="headerlink" title="AF代理2："></a>AF代理2：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(__unused NSURLSession *)session</span><br><span class="line">          dataTask:(__unused NSURLSessionDataTask *)dataTask</span><br><span class="line">    didReceiveData:(NSData *)data</span><br><span class="line">&#123;</span><br><span class="line">    //拼接数据</span><br><span class="line">    [self.mutableData appendData:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样被NSUrlSession代理转发到这里，拼接了需要回调的数据。</p>
<h6 id="AF代理3："><a href="#AF代理3：" class="headerlink" title="AF代理3："></a>AF代理3：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(NSURL *)location</span><br><span class="line">&#123;</span><br><span class="line">    NSError *fileManagerError = nil;</span><br><span class="line">    self.downloadFileURL = nil;</span><br><span class="line"></span><br><span class="line">    //AF代理的自定义Block</span><br><span class="line">    if (self.downloadTaskDidFinishDownloading) &#123;</span><br><span class="line">        //得到自定义下载路径</span><br><span class="line">        self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);</span><br><span class="line">        </span><br><span class="line">        if (self.downloadFileURL) &#123;</span><br><span class="line">            //把下载路径移动到我们自定义的下载路径</span><br><span class="line">            [[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;fileManagerError];</span><br><span class="line">            </span><br><span class="line">            //错误发通知</span><br><span class="line">            if (fileManagerError) &#123;</span><br><span class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下载成功了被NSUrlSession代理转发到这里，这里有个地方需要注意下：</p>
<ul>
<li>之前的NSUrlSession代理和这里都移动了文件到下载路径，而NSUrlSession代理的下载路径是所有request公用的下载路径，一旦设置，所有的request都会下载到之前那个路径。</li>
<li>而这个是对应的每个task的，每个task可以设置各自下载路径,还记得AFHttpManager的download方法么</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> [manager downloadTaskWithRequest:resquest progress:nil destination:^NSURL * _Nonnull(NSURL * _Nonnull targetPath, NSURLResponse * _Nonnull response) &#123;</span><br><span class="line">    return path;</span><br><span class="line">&#125; completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nullable filePath, NSError * _Nullable error) &#123;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>这个地方return的path就是对应的这个代理方法里的path，我们调用最终会走到这么一个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  - (void)addDelegateForDownloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class="line">                          progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">                       destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination</span><br><span class="line">                 completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</span><br><span class="line">    delegate.manager = self;</span><br><span class="line">    delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">    //返回地址的Block</span><br><span class="line">    if (destination) &#123;</span><br><span class="line">        </span><br><span class="line">        //有点绕，就是把一个block赋值给我们代理的downloadTaskDidFinishDownloading，这个Block里的内部返回也是调用Block去获取到的，这里面的参数都是AF代理传过去的。</span><br><span class="line">        delegate.downloadTaskDidFinishDownloading = ^NSURL * (NSURLSession * __unused session, NSURLSessionDownloadTask *task, NSURL *location) &#123;</span><br><span class="line">            //把Block返回的地址返回</span><br><span class="line">            return destination(location, task.response);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    downloadTask.taskDescription = self.taskDescriptionForSessionTasks;</span><br><span class="line"></span><br><span class="line">    [self setDelegate:delegate forTask:downloadTask];</span><br><span class="line"></span><br><span class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清楚的可以看到地址被赋值给AF的Block了。</p>
<p>至此AF的代理也讲完了，<strong>数据或错误信息随着AF代理成功失败回调，回到了用户的手中。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-42735957ecdeb831.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>分割图.png</p>
<p>接下来我们来补充之前<code>AFURLResponseSerialization</code>这一块是如何解析数据的：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-0cef773849aea454.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/956" alt="img"></p>
<p>AFURLResponseSerialization.png</p>
<p>如图所示，AF用来解析数据的一共上述这些方法。第一个实际是一个协议方法，协议方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@protocol AFURLResponseSerialization &lt;NSObject, NSSecureCoding, NSCopying&gt;</span><br><span class="line"></span><br><span class="line">- (nullable id)responseObjectForResponse:(nullable NSURLResponse *)response</span><br><span class="line">                           data:(nullable NSData *)data</span><br><span class="line">                          error:(NSError * _Nullable __autoreleasing *)error;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>而后面6个类都是遵守这个协议方法，去做数据解析。<strong>这地方可以再次感受一下AF的设计模式…</strong>接下来我们就来主要看看这些类对这个协议方法的实现：</p>
<h6 id="AFHTTPResponseSerializer："><a href="#AFHTTPResponseSerializer：" class="headerlink" title="AFHTTPResponseSerializer："></a>AFHTTPResponseSerializer：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (id)responseObjectForResponse:(NSURLResponse *)response</span><br><span class="line">                           data:(NSData *)data</span><br><span class="line">                          error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    [self validateResponse:(NSHTTPURLResponse *)response data:data error:error];</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法调用了一个另外的方法之后，就把data返回来了，我们继续往里看这个方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">// 判断是不是可接受类型和可接受code，不是则填充error</span><br><span class="line">- (BOOL)validateResponse:(NSHTTPURLResponse *)response</span><br><span class="line">                    data:(NSData *)data</span><br><span class="line">                   error:(NSError * __autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    //response是否合法标识</span><br><span class="line">    BOOL responseIsValid = YES;</span><br><span class="line">    //验证的error</span><br><span class="line">    NSError *validationError = nil;</span><br><span class="line"></span><br><span class="line">    //如果存在且是NSHTTPURLResponse</span><br><span class="line">    if (response &amp;&amp; [response isKindOfClass:[NSHTTPURLResponse class]]) &#123;</span><br><span class="line">        </span><br><span class="line">        //主要判断自己能接受的数据类型和response的数据类型是否匹配，</span><br><span class="line">        //如果有接受数据类型，如果不匹配response，而且响应类型不为空，数据长度不为0</span><br><span class="line">        if (self.acceptableContentTypes &amp;&amp; ![self.acceptableContentTypes containsObject:[response MIMEType]] &amp;&amp;</span><br><span class="line">            !([response MIMEType] == nil &amp;&amp; [data length] == 0)) &#123;</span><br><span class="line">            </span><br><span class="line">            //进入If块说明解析数据肯定是失败的，这时候要把解析错误信息放到error里。</span><br><span class="line">            //如果数据长度大于0，而且有响应url</span><br><span class="line">            if ([data length] &gt; 0 &amp;&amp; [response URL]) &#123;</span><br><span class="line">                </span><br><span class="line">                //错误信息字典，填充一些错误信息</span><br><span class="line">                NSMutableDictionary *mutableUserInfo = [@&#123;</span><br><span class="line">                                                          NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&quot;Request failed: unacceptable content-type: %@&quot;, @&quot;AFNetworking&quot;, nil), [response MIMEType]],</span><br><span class="line">                                                          NSURLErrorFailingURLErrorKey:[response URL],</span><br><span class="line">                                                          AFNetworkingOperationFailingURLResponseErrorKey: response,</span><br><span class="line">                                                        &#125; mutableCopy];</span><br><span class="line">                if (data) &#123;</span><br><span class="line">                    mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //生成错误</span><br><span class="line">                validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:mutableUserInfo], validationError);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //返回标识</span><br><span class="line">            responseIsValid = NO;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //判断自己可接受的状态吗</span><br><span class="line">        //如果和response的状态码不匹配，则进入if块</span><br><span class="line">        if (self.acceptableStatusCodes &amp;&amp; ![self.acceptableStatusCodes containsIndex:(NSUInteger)response.statusCode] &amp;&amp; [response URL]) &#123;</span><br><span class="line">            //填写错误信息字典</span><br><span class="line">            NSMutableDictionary *mutableUserInfo = [@&#123;</span><br><span class="line">                                               NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&quot;Request failed: %@ (%ld)&quot;, @&quot;AFNetworking&quot;, nil), [NSHTTPURLResponse localizedStringForStatusCode:response.statusCode], (long)response.statusCode],</span><br><span class="line">                                               NSURLErrorFailingURLErrorKey:[response URL],</span><br><span class="line">                                               AFNetworkingOperationFailingURLResponseErrorKey: response,</span><br><span class="line">                                       &#125; mutableCopy];</span><br><span class="line"></span><br><span class="line">            if (data) &#123;</span><br><span class="line">                mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //生成错误</span><br><span class="line">            validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorBadServerResponse userInfo:mutableUserInfo], validationError);</span><br><span class="line">            //返回标识</span><br><span class="line">            responseIsValid = NO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //给我们传过来的错误指针赋值</span><br><span class="line">    if (error &amp;&amp; !responseIsValid) &#123;</span><br><span class="line">        *error = validationError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回是否错误标识</span><br><span class="line">    return responseIsValid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>看注释应该很容易明白这个方法有什么作用。简单来说，<strong>这个方法就是来判断返回数据与咱们使用的解析器是否匹配，需要解析的状态码是否匹配。</strong>如果错误，则填充错误信息，并且返回NO，否则返回YES，错误信息为nil。</li>
<li>其中里面出现了两个属性值，一个<code>acceptableContentTypes</code>，一个<code>acceptableStatusCodes</code>，两者在初始化的时候有给默认值，我们也可以去自定义，但是如果给acceptableContentTypes定义了不匹配的类型，那么数据仍旧会解析错误。</li>
<li>而AFHTTPResponseSerializer仅仅是调用验证方法，然后就返回了data。</li>
</ul>
<h6 id="AFJSONResponseSerializer："><a href="#AFJSONResponseSerializer：" class="headerlink" title="AFJSONResponseSerializer："></a>AFJSONResponseSerializer：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (id)responseObjectForResponse:(NSURLResponse *)response</span><br><span class="line">                           data:(NSData *)data</span><br><span class="line">                          error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    //先判断是不是可接受类型和可接受code</span><br><span class="line">    if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) &#123;</span><br><span class="line">        //error为空，或者有错误，去函数里判断。</span><br><span class="line">        if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) &#123;</span><br><span class="line">            //返回空</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id responseObject = nil;</span><br><span class="line">    NSError *serializationError = nil;</span><br><span class="line">    // Workaround for behavior of Rails to return a single space for `head :ok` (a workaround for a bug in Safari), which is not interpreted as valid input by NSJSONSerialization.</span><br><span class="line">    // See https://github.com/rails/rails/issues/1742</span><br><span class="line">    </span><br><span class="line">    //如果数据为空</span><br><span class="line">    BOOL isSpace = [data isEqualToData:[NSData dataWithBytes:&quot; &quot; length:1]];</span><br><span class="line">    //不空则去json解析</span><br><span class="line">    if (data.length &gt; 0 &amp;&amp; !isSpace) &#123;</span><br><span class="line">        responseObject = [NSJSONSerialization JSONObjectWithData:data options:self.readingOptions error:&amp;serializationError];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断是否需要移除Null值</span><br><span class="line">    if (self.removesKeysWithNullValues &amp;&amp; responseObject) &#123;</span><br><span class="line">        responseObject = AFJSONObjectByRemovingKeysWithNullValues(responseObject, self.readingOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //拿着json解析的error去填充错误信息</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        *error = AFErrorWithUnderlyingError(serializationError, *error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回解析结果</span><br><span class="line">    return responseObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释写的很清楚，大概需要讲一下的是以下几个函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//1</span><br><span class="line">AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain))</span><br><span class="line">//2</span><br><span class="line">AFJSONObjectByRemovingKeysWithNullValues(responseObject, self.readingOptions);</span><br><span class="line">//3</span><br><span class="line">AFErrorWithUnderlyingError(serializationError, *error);</span><br></pre></td></tr></table></figure>
<p>之前注释已经写清楚了这些函数的作用，首先来看第1个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//判断是不是我们自己之前生成的错误信息，是的话返回YES</span><br><span class="line">static BOOL AFErrorOrUnderlyingErrorHasCodeInDomain(NSError *error, NSInteger code, NSString *domain) &#123;</span><br><span class="line">    //判断错误域名和传过来的域名是否一致，错误code是否一致</span><br><span class="line">    if ([error.domain isEqualToString:domain] &amp;&amp; error.code == code) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    //如果userInfo的NSUnderlyingErrorKey有值，则在判断一次。</span><br><span class="line">    else if (error.userInfo[NSUnderlyingErrorKey]) &#123;</span><br><span class="line">        return AFErrorOrUnderlyingErrorHasCodeInDomain(error.userInfo[NSUnderlyingErrorKey], code, domain);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以注意，我们这里传过去的code和domain两个参数分别为<code>NSURLErrorCannotDecodeContentData</code>、<code>AFURLResponseSerializationErrorDomain</code>，这两个参数是我们之前判断response可接受类型和code时候自己去生成错误的时候填写的。</p>
<p>第二个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static id AFJSONObjectByRemovingKeysWithNullValues(id JSONObject, NSJSONReadingOptions readingOptions) &#123;</span><br><span class="line">    //分数组和字典</span><br><span class="line">    if ([JSONObject isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">        </span><br><span class="line">        //生成一个数组，只需要JSONObject.count个，感受到大神写代码的严谨态度了吗...</span><br><span class="line">        NSMutableArray *mutableArray = [NSMutableArray arrayWithCapacity:[(NSArray *)JSONObject count]];</span><br><span class="line">        for (id value in (NSArray *)JSONObject) &#123;</span><br><span class="line">            //调用自己</span><br><span class="line">            [mutableArray addObject:AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions)];</span><br><span class="line">        &#125;</span><br><span class="line">        //看我们解析类型是mutable还是非muatable,返回mutableArray或者array</span><br><span class="line">        return (readingOptions &amp; NSJSONReadingMutableContainers) ? mutableArray : [NSArray arrayWithArray:mutableArray];</span><br><span class="line">        </span><br><span class="line">    &#125; else if ([JSONObject isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">        NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionaryWithDictionary:JSONObject];</span><br><span class="line">        for (id &lt;NSCopying&gt; key in [(NSDictionary *)JSONObject allKeys]) &#123;</span><br><span class="line">            id value = (NSDictionary *)JSONObject[key];</span><br><span class="line">            //value空则移除</span><br><span class="line">            if (!value || [value isEqual:[NSNull null]]) &#123;</span><br><span class="line">                [mutableDictionary removeObjectForKey:key];</span><br><span class="line">            &#125; else if ([value isKindOfClass:[NSArray class]] || [value isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">                //如果数组还是去调用自己</span><br><span class="line">                mutableDictionary[key] = AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return (readingOptions &amp; NSJSONReadingMutableContainers) ? mutableDictionary : [NSDictionary dictionaryWithDictionary:mutableDictionary];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return JSONObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法主要还是通过递归的形式实现。比较简单。</p>
<p>第三个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static NSError * AFErrorWithUnderlyingError(NSError *error, NSError *underlyingError) &#123;</span><br><span class="line">    if (!error) &#123;</span><br><span class="line">        return underlyingError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!underlyingError || error.userInfo[NSUnderlyingErrorKey]) &#123;</span><br><span class="line">        return error;</span><br><span class="line">    &#125;</span><br><span class="line">    NSMutableDictionary *mutableUserInfo = [error.userInfo mutableCopy];</span><br><span class="line">    mutableUserInfo[NSUnderlyingErrorKey] = underlyingError;</span><br><span class="line"></span><br><span class="line">    return [[NSError alloc] initWithDomain:error.domain code:error.code userInfo:mutableUserInfo];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法主要是把json解析的错误，赋值给我们需要返回给用户的<code>error</code>上。比较简单，小伙伴们自己看看就好。</p>
<p>至此，AFJSONResponseSerializer就讲完了。<br>而我们ResponseSerialize还有一些其他的类型解析，大家可以自行去阅读，代码还是很容易读的，在这里就不浪费篇幅去讲了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-30cfe7414b8e5db3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>分割图.png</p>
<p>在AFURLSessionManager中，有这么一个类：<code>_AFURLSessionTaskSwizzling</code>。这个类大概的作用就是替换掉<code>NSUrlSession</code>中的<code>resume</code>和<code>suspend</code>方法。正常处理原有逻辑的同时，多发送一个通知，以下是我们需要替换的新方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//被替换掉的方法，只要有TASK开启或者暂停，都会执行</span><br><span class="line">- (void)af_resume &#123;</span><br><span class="line">    NSAssert([self respondsToSelector:@selector(state)], @&quot;Does not respond to state&quot;);</span><br><span class="line">    NSURLSessionTaskState state = [self state];</span><br><span class="line">    [self af_resume];</span><br><span class="line">    </span><br><span class="line">    if (state != NSURLSessionTaskStateRunning) &#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:self];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)af_suspend &#123;</span><br><span class="line">    </span><br><span class="line">    NSAssert([self respondsToSelector:@selector(state)], @&quot;Does not respond to state&quot;);</span><br><span class="line">    NSURLSessionTaskState state = [self state];</span><br><span class="line">    [self af_suspend];</span><br><span class="line">    </span><br><span class="line">    if (state != NSURLSessionTaskStateSuspended) &#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:self];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这块知识是关于OC的Runtime:<code>method swizzling</code>的，如果有不清楚的地方，可以看看这里<a href="https://www.jianshu.com/p/db6dc23834e3" target="_blank" rel="noopener">method swizzling–by冰霜</a>或者自行查阅。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line"> </span><br><span class="line">    if (NSClassFromString(@&quot;NSURLSessionTask&quot;)) &#123;</span><br><span class="line">        </span><br><span class="line">        // 1) 首先构建一个NSURLSession对象session，再通过session构建出一个_NSCFLocalDataTask变量</span><br><span class="line"></span><br><span class="line">        NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];</span><br><span class="line">        NSURLSession * session = [NSURLSession sessionWithConfiguration:configuration];</span><br><span class="line">#pragma GCC diagnostic push</span><br><span class="line">#pragma GCC diagnostic ignored &quot;-Wnonnull&quot;</span><br><span class="line">        NSURLSessionDataTask *localDataTask = [session dataTaskWithURL:nil];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">        // 2) 获取到af_resume实现的指针</span><br><span class="line">        IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([self class], @selector(af_resume)));</span><br><span class="line">        Class currentClass = [localDataTask class];</span><br><span class="line">        </span><br><span class="line">        // 3) 检查当前class是否实现了resume。如果实现了，继续第4步。</span><br><span class="line">        while (class_getInstanceMethod(currentClass, @selector(resume))) &#123;</span><br><span class="line">            </span><br><span class="line">            // 4) 获取到当前class的父类（superClass）</span><br><span class="line">            Class superClass = [currentClass superclass];</span><br><span class="line">            </span><br><span class="line">            // 5) 获取到当前class对于resume实现的指针</span><br><span class="line">            IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, @selector(resume)));</span><br><span class="line">            </span><br><span class="line">            //  6) 获取到父类对于resume实现的指针</span><br><span class="line">            IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, @selector(resume)));</span><br><span class="line"> </span><br><span class="line">               // 7) 如果当前class对于resume的实现和父类不一样（类似iOS7上的情况），并且当前class的resume实现和af_resume不一样，才进行method swizzling。</span><br><span class="line">            if (classResumeIMP != superclassResumeIMP &amp;&amp;</span><br><span class="line">                originalAFResumeIMP != classResumeIMP) &#123;</span><br><span class="line">                //执行交换的函数</span><br><span class="line">                [self swizzleResumeAndSuspendMethodForClass:currentClass];</span><br><span class="line">            &#125;</span><br><span class="line">            // 8) 设置当前操作的class为其父类class，重复步骤3~8</span><br><span class="line">            currentClass = [currentClass superclass];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [localDataTask cancel];</span><br><span class="line">        [session finishTasksAndInvalidate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原方法中有大量的英文注释，我把它翻译过来如下：</p>
<blockquote>
<p>iOS 7和iOS 8在NSURLSessionTask实现上有些许不同，这使得下面的代码实现略显trick<br>关于这个问题，大家做了很多Unit Test，足以证明这个方法是可行的<br>目前我们所知的：</p>
</blockquote>
<ul>
<li>NSURLSessionTasks是一组class的统称，如果你仅仅使用提供的API来获取NSURLSessionTask的class，并不一定返回的是你想要的那个（获取NSURLSessionTask的class目的是为了获取其resume方法）</li>
<li>简单地使用[NSURLSessionTask class]并不起作用。你需要新建一个NSURLSession，并根据创建的session再构建出一个NSURLSessionTask对象才行。</li>
<li>iOS 7上，localDataTask（下面代码构造出的NSURLSessionDataTask类型的变量，为了获取对应Class）的类型是 <strong>NSCFLocalDataTask，</strong>NSCFLocalDataTask继承自<strong>NSCFLocalSessionTask，</strong>NSCFLocalSessionTask继承自__NSCFURLSessionTask。</li>
<li>iOS 8上，localDataTask的类型为<strong>NSCFLocalDataTask，</strong>NSCFLocalDataTask继承自<strong>NSCFLocalSessionTask，</strong>NSCFLocalSessionTask继承自NSURLSessionTask</li>
<li>iOS 7上，<strong>NSCFLocalSessionTask和</strong>NSCFURLSessionTask是仅有的两个实现了resume和suspend方法的类，另外<strong>NSCFLocalSessionTask中的resume和suspend并没有调用其父类（即</strong>NSCFURLSessionTask）方法，这也意味着两个类的方法都需要进行method swizzling。</li>
<li>iOS 8上，NSURLSessionTask是唯一实现了resume和suspend方法的类。这也意味着其是唯一需要进行method swizzling的类</li>
<li>因为NSURLSessionTask并不是在每个iOS版本中都存在，所以把这些放在此处（即load函数中），比如给一个dummy class添加swizzled方法都会变得很方便，管理起来也方便。</li>
</ul>
<blockquote>
<p>一些假设前提:</p>
</blockquote>
<ul>
<li>目前iOS中resume和suspend的方法实现中并没有调用对应的父类方法。如果日后iOS改变了这种做法，我们还需要重新处理。</li>
<li>没有哪个后台task会重写resume和suspend函数</li>
</ul>
<p>其余的一部分翻译在注释中，对应那一行代码。大概总结下这个注释：</p>
<ul>
<li>其实这是被社区大量讨论的一个bug，之前AF因为这个替换方法，会导致偶发性的crash，如果不要这个swizzle则问题不会再出现，但是这样会导致AF中很多UIKit的扩展都不能正常使用。</li>
<li><strong>原来这是因为iOS7和iOS8的NSURLSessionTask的继承链不同导致的，</strong>而且在iOS7继承链中会有两个类都实现了<code>resume</code>和<code>suspend</code>方法。而且子类没有调用父类的方法，我们则需要对着两个类都进行方法替换。而iOS8只需要对一个类进行替换。</li>
<li>对着注释看，上述方法代码不难理解，用一个while循环，一级一级去获取父类，如果实现了<code>resume</code>方法，则进行替换。</li>
</ul>
<p>但是有几个点大家可能会觉得疑惑的，我们先把这个方法调用的替换的函数一块贴出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//其引用的交换的函数：</span><br><span class="line">+ (void)swizzleResumeAndSuspendMethodForClass:(Class)theClass &#123;</span><br><span class="line">    Method afResumeMethod = class_getInstanceMethod(self, @selector(af_resume));</span><br><span class="line">    Method afSuspendMethod = class_getInstanceMethod(self, @selector(af_suspend));</span><br><span class="line"></span><br><span class="line">    if (af_addMethod(theClass, @selector(af_resume), afResumeMethod)) &#123;</span><br><span class="line">        af_swizzleSelector(theClass, @selector(resume), @selector(af_resume));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (af_addMethod(theClass, @selector(af_suspend), afSuspendMethod)) &#123;</span><br><span class="line">        af_swizzleSelector(theClass, @selector(suspend), @selector(af_suspend));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">static inline void af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(theClass, originalSelector);</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(theClass, swizzledSelector);</span><br><span class="line">    method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">&#125;</span><br><span class="line">static inline BOOL af_addMethod(Class theClass, SEL selector, Method method) &#123;</span><br><span class="line">    return class_addMethod(theClass, selector,  method_getImplementation(method),  method_getTypeEncoding(method));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为有小伙伴问到过，所以我们来分析分析大家可能会觉得疑惑的地方：</p>
<ol>
<li>首先可以注意<code>class_getInstanceMethod</code>这个方法，它会获取到当前类继承链逐级往上，第一个实现的该方法。所以说它获取到的方法不能确定是当前类还是父类的。而且这里也没有用dispatch_once_t来保证一个方法只交换一次，那万一这是父类的方法，当前类换一次，父类又换一次，不是等于没交换么？…请注意这行判断：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 7) 如果当前class对于resume的实现和父类不一样（类似iOS7上的情况），并且当前class的resume实现和af_resume不一样，才进行method swizzling。</span><br><span class="line">if (classResumeIMP != superclassResumeIMP &amp;&amp; originalAFResumeIMP != classResumeIMP) &#123; </span><br><span class="line">          //执行交换的函数</span><br><span class="line">         [self swizzleResumeAndSuspendMethodForClass:currentClass]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个条件就杜绝了这种情况的发生，只有当前类实现了这个方法，才可能进入这个if块。</p>
<p>2.那iOS7两个类都交换了<code>af_resume</code>，那岂不是父类换到子类方法了?…只能说又是没仔细看代码的…注意AF是去向当前类添加<code>af_resume</code>方法，然后去交换当前类的<code>af_resume</code>。所以说根本不会出现这种情况…</p>
<p><code>AFUrlSessionManager</code> 基本上就这么多内容了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-eabe0311bc1077f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>分割图.png</p>
<p>现在我们回到一开始初始化的这行代码上:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.operationQueue.maxConcurrentOperationCount = 1;</span><br></pre></td></tr></table></figure>
<p>1）首先我们要明确一个概念，这里的并发数仅仅是回调代理的线程并发数。而不是请求网络的线程并发数。请求网络是由NSUrlSession来做的，它内部维护了一个线程池，用来做网络请求。它调度线程,基于底层的CFSocket去发送请求和接收数据。这些<strong>线程是并发的</strong>。</p>
<p>2）明确了这个概念之后，我们来梳理一下AF3.x的整个流程和线程的关系：</p>
<ul>
<li>我们一开始初始化<code>sessionManager</code>的时候，一般都是在主线程，（当然不排除有些人喜欢在分线程初始化…）</li>
<li>然后我们调用<code>get</code>或者<code>post</code>等去请求数据，接着会进行<code>request</code>拼接，AF代理的字典映射，<code>progress</code>的<code>KVO</code>添加等等，到<code>NSUrlSession</code>的<code>resume</code>之前这些准备工作，仍旧是在主线程中的。</li>
<li>然后我们调用<code>NSUrlSession</code>的<code>resume</code>，接着就跑到<code>NSUrlSession</code>内部去对网络进行数据请求了,在它内部是多线程并发的去请求数据的。</li>
<li>紧接着数据请求完成后，回调回来在我们一开始生成的并发数为1的<code>NSOperationQueue</code>中，这个时候会是多线程串行的回调回来的。（注：不明白的朋友可以看看雷纯峰大神这篇<a href="https://link.jianshu.com/?t=http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/" target="_blank" rel="noopener">iOS 并发编程之 Operation Queues</a>）</li>
<li>然后我们到返回数据解析那一块，我们自己又创建了并发的多线程，去对这些数据进行了各种类型的解析。</li>
<li>最后我们如果有自定义的<code>completionQueue</code>，则在自定义的<code>queue</code>中回调回来，也就是分线程回调回来，否则就是主队列，主线程中回调结束。</li>
</ul>
<p>3）最后我们来解释解释为什么回调Queue要设置并发数为1：</p>
<ul>
<li>我认为AF这么做有以下两点原因：<br>1）众所周知，AF2.x所有的回调是在一条线程，这条线程是AF的常驻线程，而这一条线程正是AF调度request的思想精髓所在，所以第一个目的就是为了和之前版本保持一致。<br>2）因为跟代理相关的一些操作AF都使用了NSLock。所以就算Queue的并发数设置为n，因为多线程回调，锁的等待，导致所提升的程序速度也并不明显。<strong>反而多task回调导致的多线程并发，平白浪费了部分性能。</strong><br>而设置Queue的并发数为1，（注：这里虽然回调Queue的并发数为1，仍然会有不止一条线程，但是因为是串行回调，所以同一时间，只会有一条线程在操作AFUrlSessionManager的那些方法。）至少回调的事件，是不需要多线程并发的。<strong>回调没有了NSLock的等待时间，所以对时间并没有多大的影响。</strong>（注：但是还是会有多线程的操作的，因为设置刚开始调起请求的时候，是在主线程的，而回调则是串行分线程。）</li>
</ul>
<p>当然这仅仅是我个人的看法，如果有不同意见的欢迎交流~</p>
<p>至此我们AF3.X业务层的逻辑，基本上结束了。小伙伴们，看到这你明白了AF做了什么了吗？可能很多朋友要扔鸡蛋了…可能你还是没觉得AF到底有什么用，我用NSUrlSession不也一样，我干嘛要用AF，在这里，我暂时卖个关子，等我们下篇讲完<code>AFSecurityPolicy</code>和部分<code>UIKit</code>的扩展，以及AF2.x的核心类源码实现之后，我们再好好总结。</p>
<h6 id="后续文章："><a href="#后续文章：" class="headerlink" title="后续文章："></a>后续文章：</h6><p><a href="https://www.jianshu.com/p/a84237b07611" target="_blank" rel="noopener">AFNetworking之于https认证</a><br><a href="https://www.jianshu.com/p/4ffeb1ba3046" target="_blank" rel="noopener">AFNetworking之UIKit扩展与缓存实现</a><br><a href="https://www.jianshu.com/p/7ed7c0be15b4" target="_blank" rel="noopener">AFNetworking到底做了什么？(终)</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/AFNetworking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/AFNetworking/" itemprop="url">
                  AFNetworking
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 16:02:02 / 修改时间：16:05:26" itemprop="dateCreated datePublished" datetime="2018-09-17T16:02:02+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/第三方源码/" itemprop="url" rel="index"><span itemprop="name">第三方源码</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[转自 <a href="https://www.jianshu.com/u/14431e509ae8" target="_blank" rel="noopener">涂耀辉</a>]（<a href="https://www.jianshu.com/p/856f0e26279d）" target="_blank" rel="noopener">https://www.jianshu.com/p/856f0e26279d）</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-2d036ecb6746df01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/850" alt="img"></p>
<h6 id="写在开头："><a href="#写在开头：" class="headerlink" title="写在开头："></a>写在开头：</h6><ul>
<li>作为一个iOS开发，也许你不知道NSUrlRequest、不知道NSUrlConnection、也不知道NSURLSession…（说不下去了…怎么会什么都不知道…）但是你一定知道AFNetworking。</li>
<li>大多数人习惯了只要是请求网络都用AF，但是你真的知道AF做了什么吗？为什么我们不用原生的NSURLSession而选择AFNetworking?</li>
<li>本文将从源码的角度去分析AF的实际作用。<br><strong>或许看完这篇文章，你心里会有一个答案。</strong></li>
</ul>
<h6 id="先从最新的AF3-x讲起吧："><a href="#先从最新的AF3-x讲起吧：" class="headerlink" title="先从最新的AF3.x讲起吧："></a>先从最新的AF3.x讲起吧：</h6><ul>
<li><p>首先，我们就一起分析一下该框架的组成。<br>将AF下载导入工程后，下面是其包结构，相对于2.x变得非常简单了：</p>
<p>​</p>
<p>​</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-27e6f4836e83d229.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>AF代码结构图.png</p>
</li>
</ul>
<p>除去Support Files，可以看到AF分为如下5个功能模块：</p>
<ul>
<li>网络通信模块(AFURLSessionManager、AFHTTPSessionManger)</li>
<li>网络状态监听模块(Reachability)</li>
<li>网络通信安全策略模块(Security)</li>
<li>网络通信信息序列化/反序列化模块(Serialization)</li>
<li>对于iOS UIKit库的扩展(UIKit)</li>
</ul>
<h6 id="其核心当然是网络通信模块AFURLSessionManager。大家都知道，AF3-x是基于NSURLSession来封装的。所以这个类围绕着NSURLSession做了一系列的封装。而其余的四个模块，均是为了配合网络通信或对已有UIKit的一个扩展工具包。"><a href="#其核心当然是网络通信模块AFURLSessionManager。大家都知道，AF3-x是基于NSURLSession来封装的。所以这个类围绕着NSURLSession做了一系列的封装。而其余的四个模块，均是为了配合网络通信或对已有UIKit的一个扩展工具包。" class="headerlink" title="其核心当然是网络通信模块AFURLSessionManager。大家都知道，AF3.x是基于NSURLSession来封装的。所以这个类围绕着NSURLSession做了一系列的封装。而其余的四个模块，均是为了配合网络通信或对已有UIKit的一个扩展工具包。"></a>其核心当然是网络通信模块AFURLSessionManager。大家都知道，AF3.x是基于NSURLSession来封装的。所以这个类围绕着NSURLSession做了一系列的封装。而其余的四个模块，均是为了配合网络通信或对已有UIKit的一个扩展工具包。</h6><p>这五个模块所对应的类的结构关系图如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-10294db19b1aedfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>AF架构图.png</p>
<p>其中AFHTTPSessionManager是继承于AFURLSessionManager的，我们一般做网络请求都是用这个类，<strong>但是它本身是没有做实事的，只是做了一些简单的封装，把请求逻辑分发给父类AFURLSessionManager或者其它类去做。</strong></p>
<h6 id="首先我们简单的写个get请求："><a href="#首先我们简单的写个get请求：" class="headerlink" title="首先我们简单的写个get请求："></a>首先我们简单的写个get请求：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc]init];</span><br><span class="line"></span><br><span class="line">[manager GET:@&quot;http://localhost&quot; parameters:nil progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class="line"> </span><br><span class="line">&#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>首先我们我们调用了初始化方法生成了一个manager，我们点进去看看初始化做了什么:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">    return [self initWithBaseURL:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithBaseURL:(NSURL *)url &#123;</span><br><span class="line">    return [self initWithBaseURL:url sessionConfiguration:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123;</span><br><span class="line">    return [self initWithBaseURL:nil sessionConfiguration:configuration];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithBaseURL:(NSURL *)url</span><br><span class="line">           sessionConfiguration:(NSURLSessionConfiguration *)configuration</span><br><span class="line">&#123;</span><br><span class="line">    self = [super initWithSessionConfiguration:configuration];</span><br><span class="line">    if (!self) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    //对传过来的BaseUrl进行处理，如果有值且最后不包含/，url加上&quot;/&quot;</span><br><span class="line">  //--经一位热心读者更正...以后注释也一定要走心啊...不能误导大家...</span><br><span class="line">    if ([[url path] length] &gt; 0 &amp;&amp; ![[url absoluteString] hasSuffix:@&quot;/&quot;]) &#123;</span><br><span class="line">        url = [url URLByAppendingPathComponent:@&quot;&quot;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self.baseURL = url;</span><br><span class="line"></span><br><span class="line">    self.requestSerializer = [AFHTTPRequestSerializer serializer];</span><br><span class="line">    self.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化都调用到<code>- (instancetype)initWithBaseURL:(NSURL *)url sessionConfiguration:(NSURLSessionConfiguration *)configuration</code>方法中来了。</li>
<li><strong>其实初始化方法都调用父类的初始化方法。</strong>父类也就是AF3.x<strong>最最核心的类AFURLSessionManager</strong>。几乎所有的类都是围绕着这个类在处理业务逻辑。</li>
<li>除此之外，方法中把baseURL存了起来，还生成了一个请求序列对象和一个响应序列对象。后面再细说这两个类是干什么用的。</li>
</ul>
<p>直接来到父类AFURLSessionManager的初始化方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">    return [self initWithSessionConfiguration:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (!self) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!configuration) &#123;</span><br><span class="line">        configuration = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line">    self.sessionConfiguration = configuration;</span><br><span class="line">    self.operationQueue = [[NSOperationQueue alloc] init];</span><br><span class="line">    //queue并发线程数设置为1</span><br><span class="line">    self.operationQueue.maxConcurrentOperationCount = 1;</span><br><span class="line">    </span><br><span class="line">    //注意代理，代理的继承，实际上NSURLSession去判断了，你实现了哪个方法会去调用，包括子代理的方法！</span><br><span class="line">    self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];</span><br><span class="line">    </span><br><span class="line">    //各种响应转码</span><br><span class="line">    self.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">    //设置默认安全策略</span><br><span class="line">    self.securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line">#if !TARGET_OS_WATCH</span><br><span class="line">    self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line">#endif</span><br><span class="line">    // 设置存储NSURL task与AFURLSessionManagerTaskDelegate的词典（重点，在AFNet中，每一个task都会被匹配一个AFURLSessionManagerTaskDelegate 来做task的delegate事件处理） ===============</span><br><span class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init];</span><br><span class="line"></span><br><span class="line">    //  设置AFURLSessionManagerTaskDelegate 词典的锁，确保词典在多线程访问时的线程安全</span><br><span class="line">    self.lock = [[NSLock alloc] init];</span><br><span class="line">    self.lock.name = AFURLSessionManagerLockName;</span><br><span class="line"></span><br><span class="line">    // 置空task关联的代理</span><br><span class="line">    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123;        </span><br><span class="line">        for (NSURLSessionDataTask *task in dataTasks) &#123;</span><br><span class="line">            [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil];</span><br><span class="line">        &#125;</span><br><span class="line">        for (NSURLSessionUploadTask *uploadTask in uploadTasks) &#123;</span><br><span class="line">            [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil];</span><br><span class="line">        &#125;</span><br><span class="line">        for (NSURLSessionDownloadTask *downloadTask in downloadTasks) &#123;</span><br><span class="line">            [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个就是最终的初始化方法了，注释应该写的很清楚，唯一需要说的就是三点：<ul>
<li><code>self.operationQueue.maxConcurrentOperationCount = 1;</code><strong>这个operationQueue就是我们代理回调的queue。这里把代理回调的线程并发数设置为1了。</strong>至于这里为什么要这么做，我们先留一个坑，等我们讲完AF2.x之后再来分析这一块。</li>
</ul>
</li>
<li>第二就是我们初始化了一些属性，其中包括<code>self.mutableTaskDelegatesKeyedByTaskIdentifier</code>，这个是用来让每一个请求task和我们自定义的AF代理来建立映射用的，其实AF对task的代理进行了一个封装，并且转发代理到AF自定义的代理，这是AF比较重要的一部分，接下来我们会具体讲这一块。</li>
<li>第三就是下面这个方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123; </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>首先说说这个方法是干什么用的：这个方法用来异步的获取当前session的所有未完成的task。其实讲道理来说在初始化中调用这个方法应该里面一个task都不会有。我们打断点去看，也确实如此，里面的数组都是空的。<br>但是想想也知道，AF大神不会把一段没用的代码放在这吧。辗转多处，终于从AF的issue中找到了结论：<a href="https://link.jianshu.com/?t=https://github.com/AFNetworking/AFNetworking/issues/3499" target="_blank" rel="noopener">github </a>。</p>
<ul>
<li>原来这是为了防止后台回来，重新初始化这个session，一些之前的后台请求任务，导致程序的crash。</li>
</ul>
<p>初始化方法到这就全部完成了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-bc2238dee34f8acd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>分割图.png</p>
<p>接着我们来看看网络请求:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)GET:(NSString *)URLString</span><br><span class="line">                   parameters:(id)parameters</span><br><span class="line">                     progress:(void (^)(NSProgress * _Nonnull))downloadProgress</span><br><span class="line">                      success:(void (^)(NSURLSessionDataTask * _Nonnull, id _Nullable))success</span><br><span class="line">                      failure:(void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure</span><br><span class="line">&#123;</span><br><span class="line">     //生成一个task</span><br><span class="line">    NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@&quot;GET&quot;</span><br><span class="line">                                                        URLString:URLString</span><br><span class="line">                                                       parameters:parameters</span><br><span class="line">                                                   uploadProgress:nil</span><br><span class="line">                                                 downloadProgress:downloadProgress</span><br><span class="line">                                                          success:success</span><br><span class="line">                                                          failure:failure];</span><br><span class="line">  </span><br><span class="line">    //开始网络请求</span><br><span class="line">    [dataTask resume];</span><br><span class="line"></span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法走到类AFHTTPSessionManager中来，调用父类，也就是我们整个AF3.x的核心类AFURLSessionManager的方法，生成了一个系统的NSURLSessionDataTask实例，并且开始网络请求。<br>我们继续往父类里看，看看这个方法到底做了什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method</span><br><span class="line">                                       URLString:(NSString *)URLString</span><br><span class="line">                                      parameters:(id)parameters</span><br><span class="line">                                  uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress</span><br><span class="line">                                downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress</span><br><span class="line">                                         success:(void (^)(NSURLSessionDataTask *, id))success</span><br><span class="line">                                         failure:(void (^)(NSURLSessionDataTask *, NSError *))failure</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    NSError *serializationError = nil;</span><br><span class="line">    </span><br><span class="line">    //把参数，还有各种东西转化为一个request</span><br><span class="line">    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];</span><br><span class="line">    </span><br><span class="line">    if (serializationError) &#123;</span><br><span class="line">        if (failure) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</span><br><span class="line">            //如果解析错误，直接返回</span><br><span class="line">            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                failure(nil, serializationError);</span><br><span class="line">            &#125;);</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    __block NSURLSessionDataTask *dataTask = nil;</span><br><span class="line">    dataTask = [self dataTaskWithRequest:request</span><br><span class="line">                          uploadProgress:uploadProgress</span><br><span class="line">                        downloadProgress:downloadProgress</span><br><span class="line">                       completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            if (failure) &#123;</span><br><span class="line">                failure(dataTask, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (success) &#123;</span><br><span class="line">                success(dataTask, responseObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个方法做了两件事：<br>1.用self.requestSerializer和各种参数去获取了一个我们最终请求网络需要的NSMutableURLRequest实例。<br>2.调用另外一个方法dataTaskWithRequest去拿到我们最终需要的NSURLSessionDataTask实例，并且在完成的回调里，调用我们传过来的成功和失败的回调。</li>
<li>注意下面这个方法，我们常用来 push pop搭配，来忽略一些编译器的警告：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</span><br><span class="line">#pragma clang diagnostic pop</span><br></pre></td></tr></table></figure>
<p>这里是用来忽略<strong>：？</strong>带来的警告，具体的各种编译器警告描述，可以参考这篇：<a href="https://link.jianshu.com/?t=http://fuckingclangwarnings.com/#semantic" target="_blank" rel="noopener">各种编译器的警告</a>。</p>
<ul>
<li>说到底这个方法还是没有做实事，我们继续到requestSerializer方法里去看，看看AF到底如何拼接成我们需要的request的：</li>
</ul>
<p>接着我们跑到AFURLRequestSerialization类中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (NSMutableURLRequest *)requestWithMethod:(NSString *)method</span><br><span class="line">                                 URLString:(NSString *)URLString</span><br><span class="line">                                parameters:(id)parameters</span><br><span class="line">                                     error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    //断言，debug模式下，如果缺少改参数，crash</span><br><span class="line">    NSParameterAssert(method);</span><br><span class="line">    NSParameterAssert(URLString);</span><br><span class="line"></span><br><span class="line">    NSURL *url = [NSURL URLWithString:URLString];</span><br><span class="line"></span><br><span class="line">    NSParameterAssert(url);</span><br><span class="line"></span><br><span class="line">    NSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url];</span><br><span class="line">    mutableRequest.HTTPMethod = method;</span><br><span class="line"></span><br><span class="line">    //将request的各种属性循环遍历</span><br><span class="line">    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">        //如果自己观察到的发生变化的属性，在这些方法里</span><br><span class="line">        if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123;</span><br><span class="line">           //把给自己设置的属性给request设置</span><br><span class="line">            [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //将传入的parameters进行编码，并添加到request中</span><br><span class="line">    mutableRequest = [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</span><br><span class="line"></span><br><span class="line">    return mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>讲一下这个方法，这个方法做了3件事：<br>1）设置request的请求类型，get,post,put…等<br>2）往request里添加一些参数设置，其中<code>AFHTTPRequestSerializerObservedKeyPaths()</code>是一个c函数，返回一个数组，我们来看看这个函数:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static NSArray * AFHTTPRequestSerializerObservedKeyPaths() &#123;</span><br><span class="line">    static NSArray *_AFHTTPRequestSerializerObservedKeyPaths = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    // 此处需要observer的keypath为allowsCellularAccess、cachePolicy、HTTPShouldHandleCookies</span><br><span class="line">    // HTTPShouldUsePipelining、networkServiceType、timeoutInterval</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        _AFHTTPRequestSerializerObservedKeyPaths = @[NSStringFromSelector(@selector(allowsCellularAccess)), NSStringFromSelector(@selector(cachePolicy)), NSStringFromSelector(@selector(HTTPShouldHandleCookies)), NSStringFromSelector(@selector(HTTPShouldUsePipelining)), NSStringFromSelector(@selector(networkServiceType)), NSStringFromSelector(@selector(timeoutInterval))];</span><br><span class="line">    &#125;);</span><br><span class="line">    //就是一个数组里装了很多方法的名字,</span><br><span class="line">    return _AFHTTPRequestSerializerObservedKeyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这个函数就是封装了一些属性的名字，这些都是NSUrlRequest的属性。<br>再来看看<code>self.mutableObservedChangedKeyPaths</code>,这个是当前类的一个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (readwrite, nonatomic, strong) NSMutableSet *mutableObservedChangedKeyPaths;</span><br></pre></td></tr></table></figure>
<p>在-init方法对这个集合进行了初始化，<strong>并且对当前类的和NSUrlRequest相关的那些属性添加了KVO监听</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//每次都会重置变化</span><br><span class="line">   self.mutableObservedChangedKeyPaths = [NSMutableSet set];</span><br><span class="line">   </span><br><span class="line">   //给这自己些方法添加观察者为自己，就是request的各种属性，set方法</span><br><span class="line">   for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">       if ([self respondsToSelector:NSSelectorFromString(keyPath)]) &#123;</span><br><span class="line">           [self addObserver:self forKeyPath:keyPath options:NSKeyValueObservingOptionNew context:AFHTTPRequestSerializerObserverContext];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>KVO触发的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-(void)observeValueForKeyPath:(NSString *)keyPath</span><br><span class="line">                      ofObject:(__unused id)object</span><br><span class="line">                        change:(NSDictionary *)change</span><br><span class="line">                       context:(void *)context</span><br><span class="line">&#123;</span><br><span class="line">    //当观察到这些set方法被调用了，而且不为Null就会添加到集合里，否则移除</span><br><span class="line">    if (context == AFHTTPRequestSerializerObserverContext) &#123;</span><br><span class="line">        if ([change[NSKeyValueChangeNewKey] isEqual:[NSNull null]]) &#123;</span><br><span class="line">            [self.mutableObservedChangedKeyPaths removeObject:keyPath];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            [self.mutableObservedChangedKeyPaths addObject:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此我们知道<code>self.mutableObservedChangedKeyPaths</code>其实就是我们自己设置的request属性值的集合。<br>接下来调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];</span><br></pre></td></tr></table></figure>
<p>用KVC的方式，把属性值都设置到我们请求的request中去。</p>
<p>3）把需要传递的参数进行编码，并且设置到request中去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//将传入的parameters进行编码，并添加到request中</span><br><span class="line">mutableRequest = [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"> - (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request</span><br><span class="line">                               withParameters:(id)parameters</span><br><span class="line">                                        error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    NSParameterAssert(request);</span><br><span class="line"></span><br><span class="line">    NSMutableURLRequest *mutableRequest = [request mutableCopy];</span><br><span class="line"></span><br><span class="line">    //从自己的head里去遍历，如果有值则设置给request的head</span><br><span class="line">    [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) &#123;</span><br><span class="line">        if (![request valueForHTTPHeaderField:field]) &#123;</span><br><span class="line">            [mutableRequest setValue:value forHTTPHeaderField:field];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    //来把各种类型的参数，array dic set转化成字符串，给request</span><br><span class="line">    NSString *query = nil;</span><br><span class="line">    if (parameters) &#123;</span><br><span class="line">        //自定义的解析方式</span><br><span class="line">        if (self.queryStringSerialization) &#123;</span><br><span class="line">            NSError *serializationError;</span><br><span class="line">            query = self.queryStringSerialization(request, parameters, &amp;serializationError);</span><br><span class="line"></span><br><span class="line">            if (serializationError) &#123;</span><br><span class="line">                if (error) &#123;</span><br><span class="line">                    *error = serializationError;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return nil;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //默认解析方式</span><br><span class="line">            switch (self.queryStringSerializationStyle) &#123;</span><br><span class="line">                case AFHTTPRequestQueryStringDefaultStyle:</span><br><span class="line">                    query = AFQueryStringFromParameters(parameters);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //最后判断该request中是否包含了GET、HEAD、DELETE（都包含在HTTPMethodsEncodingParametersInURI）。因为这几个method的quey是拼接到url后面的。而POST、PUT是把query拼接到http body中的。</span><br><span class="line">    if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</span><br><span class="line">        if (query &amp;&amp; query.length &gt; 0) &#123;</span><br><span class="line">            mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @&quot;&amp;%@&quot; : @&quot;?%@&quot;, query]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //post put请求</span><br><span class="line">        </span><br><span class="line">        // #2864: an empty string is a valid x-www-form-urlencoded payload</span><br><span class="line">        if (!query) &#123;</span><br><span class="line">            query = @&quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) &#123;</span><br><span class="line">            [mutableRequest setValue:@&quot;application/x-www-form-urlencoded&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];</span><br><span class="line">        &#125;</span><br><span class="line">        //设置请求体</span><br><span class="line">        [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法做了3件事：<br>1.从<code>self.HTTPRequestHeaders</code>中拿到设置的参数，赋值要请求的request里去<br>2.把请求网络的参数，从array dic set这些容器类型转换为字符串，具体转码方式，我们可以使用自定义的方式，也可以用AF默认的转码方式。自定义的方式没什么好说的，想怎么去解析由你自己来决定。我们可以来看看默认的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">NSString * AFQueryStringFromParameters(NSDictionary *parameters) &#123;</span><br><span class="line">    NSMutableArray *mutablePairs = [NSMutableArray array];</span><br><span class="line">    </span><br><span class="line">    //把参数给AFQueryStringPairsFromDictionary，拿到AF的一个类型的数据就一个key，value对象，在URLEncodedStringValue拼接keyValue，一个加到数组里</span><br><span class="line">    for (AFQueryStringPair *pair in AFQueryStringPairsFromDictionary(parameters)) &#123;</span><br><span class="line">        [mutablePairs addObject:[pair URLEncodedStringValue]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //拆分数组返回参数字符串</span><br><span class="line">    return [mutablePairs componentsJoinedByString:@&quot;&amp;&quot;];</span><br><span class="line">&#125;</span><br><span class="line">NSArray * AFQueryStringPairsFromDictionary(NSDictionary *dictionary) &#123;</span><br><span class="line">    //往下调用</span><br><span class="line">    return AFQueryStringPairsFromKeyAndValue(nil, dictionary);</span><br><span class="line">&#125;</span><br><span class="line">NSArray * AFQueryStringPairsFromKeyAndValue(NSString *key, id value) &#123;</span><br><span class="line">    NSMutableArray *mutableQueryStringComponents = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">    // 根据需要排列的对象的description来进行升序排列，并且selector使用的是compare:</span><br><span class="line">    // 因为对象的description返回的是NSString，所以此处compare:使用的是NSString的compare函数</span><br><span class="line">    // 即@[@&quot;foo&quot;, @&quot;bar&quot;, @&quot;bae&quot;] ----&gt; @[@&quot;bae&quot;, @&quot;bar&quot;,@&quot;foo&quot;]</span><br><span class="line">    NSSortDescriptor *sortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@&quot;description&quot; ascending:YES selector:@selector(compare:)];</span><br><span class="line"></span><br><span class="line">    //判断vaLue是什么类型的，然后去递归调用自己，直到解析的是除了array dic set以外的元素，然后把得到的参数数组返回。</span><br><span class="line">    if ([value isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">        NSDictionary *dictionary = value;</span><br><span class="line">        // Sort dictionary keys to ensure consistent ordering in query string, which is important when deserializing potentially ambiguous sequences, such as an array of dictionaries</span><br><span class="line">        </span><br><span class="line">        //拿到</span><br><span class="line">        for (id nestedKey in [dictionary.allKeys sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class="line">            id nestedValue = dictionary[nestedKey];</span><br><span class="line">            if (nestedValue) &#123;</span><br><span class="line">                [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue((key ? [NSString stringWithFormat:@&quot;%@[%@]&quot;, key, nestedKey] : nestedKey), nestedValue)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if ([value isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">        NSArray *array = value;</span><br><span class="line">        for (id nestedValue in array) &#123;</span><br><span class="line">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue([NSString stringWithFormat:@&quot;%@[]&quot;, key], nestedValue)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if ([value isKindOfClass:[NSSet class]]) &#123;</span><br><span class="line">        NSSet *set = value;</span><br><span class="line">        for (id obj in [set sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class="line">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue(key, obj)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [mutableQueryStringComponents addObject:[[AFQueryStringPair alloc] initWithField:key value:value]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return mutableQueryStringComponents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>转码主要是以上三个函数，配合着注释应该也很好理解：主要是在递归调用<code>AFQueryStringPairsFromKeyAndValue</code>。判断vaLue是什么类型的，然后去递归调用自己，直到解析的是除了array dic set以外的元素，然后把得到的参数数组返回。</li>
<li>其中有个<code>AFQueryStringPair</code>对象，其只有两个属性和两个方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@property (readwrite, nonatomic, strong) id field;</span><br><span class="line">@property (readwrite, nonatomic, strong) id value;</span><br><span class="line">   </span><br><span class="line">    - (instancetype)initWithField:(id)field value:(id)value &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (!self) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self.field = field;</span><br><span class="line">    self.value = value;</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   - (NSString *)URLEncodedStringValue &#123;</span><br><span class="line">    if (!self.value || [self.value isEqual:[NSNull null]]) &#123;</span><br><span class="line">        return AFPercentEscapedStringFromString([self.field description]);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return [NSString stringWithFormat:@&quot;%@=%@&quot;, AFPercentEscapedStringFromString([self.field description]), AFPercentEscapedStringFromString([self.value description])];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法很简单，现在我们也很容易理解这整个转码过程了，我们举个例子梳理下，就是以下这3步：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@&#123; </span><br><span class="line">     @&quot;name&quot; : @&quot;bang&quot;, </span><br><span class="line">     @&quot;phone&quot;: @&#123;@&quot;mobile&quot;: @&quot;xx&quot;, @&quot;home&quot;: @&quot;xx&quot;&#125;, </span><br><span class="line">     @&quot;families&quot;: @[@&quot;father&quot;, @&quot;mother&quot;], </span><br><span class="line">     @&quot;nums&quot;: [NSSet setWithObjects:@&quot;1&quot;, @&quot;2&quot;, nil] </span><br><span class="line">&#125; </span><br><span class="line">-&gt; </span><br><span class="line">@[ </span><br><span class="line">     field: @&quot;name&quot;, value: @&quot;bang&quot;, </span><br><span class="line">     field: @&quot;phone[mobile]&quot;, value: @&quot;xx&quot;, </span><br><span class="line">     field: @&quot;phone[home]&quot;, value: @&quot;xx&quot;, </span><br><span class="line">     field: @&quot;families[]&quot;, value: @&quot;father&quot;, </span><br><span class="line">     field: @&quot;families[]&quot;, value: @&quot;mother&quot;, </span><br><span class="line">     field: @&quot;nums&quot;, value: @&quot;1&quot;, </span><br><span class="line">     field: @&quot;nums&quot;, value: @&quot;2&quot;, </span><br><span class="line">] </span><br><span class="line">-&gt; </span><br><span class="line">name=bang&amp;phone[mobile]=xx&amp;phone[home]=xx&amp;families[]=father&amp;families[]=mother&amp;nums=1&amp;num=2</span><br></pre></td></tr></table></figure>
<p>至此，我们原来的容器类型的参数，就这样变成字符串类型了。</p>
<p>紧接着这个方法还根据该request中请求类型，来判断参数字符串应该如何设置到request中去。如果是GET、HEAD、DELETE，则把参数quey是拼接到url后面的。而POST、PUT是把query拼接到http body中的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</span><br><span class="line">    if (query &amp;&amp; query.length &gt; 0) &#123;</span><br><span class="line">        mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @&quot;&amp;%@&quot; : @&quot;?%@&quot;, query]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    //post put请求</span><br><span class="line">    </span><br><span class="line">    // #2864: an empty string is a valid x-www-form-urlencoded payload</span><br><span class="line">    if (!query) &#123;</span><br><span class="line">        query = @&quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) &#123;</span><br><span class="line">        [mutableRequest setValue:@&quot;application/x-www-form-urlencoded&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    //设置请求体</span><br><span class="line">    [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们生成了一个request。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-bc2238dee34f8acd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>分割图.png</p>
<h6 id="我们再回到AFHTTPSessionManager类中来-回到这个方法："><a href="#我们再回到AFHTTPSessionManager类中来-回到这个方法：" class="headerlink" title="我们再回到AFHTTPSessionManager类中来,回到这个方法："></a>我们再回到AFHTTPSessionManager类中来,回到这个方法：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method</span><br><span class="line">                                       URLString:(NSString *)URLString</span><br><span class="line">                                      parameters:(id)parameters</span><br><span class="line">                                  uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress</span><br><span class="line">                                downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress</span><br><span class="line">                                         success:(void (^)(NSURLSessionDataTask *, id))success</span><br><span class="line">                                         failure:(void (^)(NSURLSessionDataTask *, NSError *))failure</span><br><span class="line">&#123;</span><br><span class="line">    NSError *serializationError = nil;</span><br><span class="line">    //把参数，还有各种东西转化为一个request</span><br><span class="line">    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];</span><br><span class="line">    </span><br><span class="line">    if (serializationError) &#123;</span><br><span class="line">        if (failure) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</span><br><span class="line">            //如果解析错误，直接返回</span><br><span class="line">            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                failure(nil, serializationError);</span><br><span class="line">            &#125;);</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    __block NSURLSessionDataTask *dataTask = nil;</span><br><span class="line">    dataTask = [self dataTaskWithRequest:request</span><br><span class="line">                          uploadProgress:uploadProgress</span><br><span class="line">                        downloadProgress:downloadProgress</span><br><span class="line">                       completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            if (failure) &#123;</span><br><span class="line">                failure(dataTask, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (success) &#123;</span><br><span class="line">                success(dataTask, responseObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>绕了一圈我们又回来了。。</p>
<ul>
<li>我们继续往下看：当解析错误，我们直接调用传进来的fauler的Block失败返回了，这里有一个<code>self.completionQueue</code>,这个是我们自定义的，这个是一个GCD的Queue如果设置了那么从这个Queue中回调结果，否则从主队列回调。</li>
<li>实际上这个Queue还是挺有用的，之前还用到过。我们公司有自己的一套数据加解密的解析模式，所以我们回调回来的数据并不想是主线程，我们可以设置这个Queue,在分线程进行解析数据，然后自己再调回到主线程去刷新UI。</li>
</ul>
<p>言归正传，我们接着调用了父类的生成task的方法，并且执行了一个成功和失败的回调，我们接着去父类AFURLSessionManger里看（总算到我们的核心类了..）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</span><br><span class="line">                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    __block NSURLSessionDataTask *dataTask = nil;</span><br><span class="line">    //第一件事，创建NSURLSessionDataTask，里面适配了Ios8以下taskIdentifiers，函数创建task对象。</span><br><span class="line">    //其实现应该是因为iOS 8.0以下版本中会并发地创建多个task对象，而同步有没有做好，导致taskIdentifiers 不唯一…这边做了一个串行处理</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        dataTask = [self.session dataTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们注意到这个方法非常简单，就调用了一个<code>url_session_manager_create_task_safely()</code>函数，传了一个Block进去，Block里就是iOS原生生成dataTask的方法。此外，还调用了一个<code>addDelegateForDataTask</code>的方法。</li>
<li>我们到这先到这个函数里去看看：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static void url_session_manager_create_task_safely(dispatch_block_t block) &#123;</span><br><span class="line">    if (NSFoundationVersionNumber &lt; NSFoundationVersionNumber_With_Fixed_5871104061079552_bug) &#123;</span><br><span class="line">        // Fix of bug</span><br><span class="line">        // Open Radar:http://openradar.appspot.com/radar?id=5871104061079552 (status: Fixed in iOS8)</span><br><span class="line">        // Issue about:https://github.com/AFNetworking/AFNetworking/issues/2093</span><br><span class="line">      </span><br><span class="line">      //理解下，第一为什么用sync，因为是想要主线程等在这，等执行完，在返回，因为必须执行完dataTask才有数据，传值才有意义。</span><br><span class="line">      //第二，为什么要用串行队列，因为这块是为了防止ios8以下内部的dataTaskWithRequest是并发创建的，</span><br><span class="line">      //这样会导致taskIdentifiers这个属性值不唯一，因为后续要用taskIdentifiers来作为Key对应delegate。</span><br><span class="line">        dispatch_sync(url_session_manager_creation_queue(), block);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">static dispatch_queue_t url_session_manager_creation_queue() &#123;</span><br><span class="line">    static dispatch_queue_t af_url_session_manager_creation_queue;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    //保证了即使是在多线程的环境下，也不会创建其他队列</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        af_url_session_manager_creation_queue = dispatch_queue_create(&quot;com.alamofire.networking.session.manager.creation&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return af_url_session_manager_creation_queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法非常简单，关键是理解这么做的目的：为什么我们不直接去调用<br><code>dataTask = [self.session dataTaskWithRequest:request];</code><br>非要绕这么一圈，我们点进去bug日志里看看，<strong>原来这是为了适配iOS8的以下，创建session的时候，偶发的情况会出现session的属性taskIdentifier这个值不唯一</strong>，而这个taskIdentifier是我们后面来映射delegate的key,所以它必须是唯一的。</li>
<li><strong>具体原因应该是NSURLSession内部去生成task的时候是用多线程并发去执行的。</strong>想通了这一点，我们就很好解决了，我们只需要在iOS8以下<strong>同步串行</strong>的去生成task就可以防止这一问题发生（如果还是不理解同步串行的原因，可以看看注释）。</li>
<li>题外话：很多同学都会抱怨为什么sync我从来用不到，看，有用到的地方了吧，<strong>很多东西不是没用，而只是你想不到怎么用</strong>。</li>
</ul>
<p>我们接着看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br></pre></td></tr></table></figure>
<p>调用到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</span><br><span class="line">   </span><br><span class="line">    // AFURLSessionManagerTaskDelegate与AFURLSessionManager建立相互关系</span><br><span class="line">    delegate.manager = self;</span><br><span class="line">    delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">    //这个taskDescriptionForSessionTasks用来发送开始和挂起通知的时候会用到,就是用这个值来Post通知，来两者对应</span><br><span class="line">    dataTask.taskDescription = self.taskDescriptionForSessionTasks;</span><br><span class="line">    </span><br><span class="line">    // ***** 将AF delegate对象与 dataTask建立关系</span><br><span class="line">    [self setDelegate:delegate forTask:dataTask];</span><br><span class="line"></span><br><span class="line">    // 设置AF delegate的上传进度，下载进度块。</span><br><span class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</span><br><span class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>总结一下:<br>1）这个方法，生成了一个<code>AFURLSessionManagerTaskDelegate</code>,这个其实就是AF的自定义代理。我们请求传来的参数，都赋值给这个AF的代理了。<br>2）<code>delegate.manager = self;</code>代理把AFURLSessionManager这个类作为属性了,我们可以看到：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, weak) AFURLSessionManager *manager;</span><br></pre></td></tr></table></figure>
<p>这个属性是弱引用的，所以不会存在循环引用的问题。<br>3）我们调用了<code>[self setDelegate:delegate forTask:dataTask];</code></p>
<p>我们进去看看这个方法做了什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class="line">            forTask:(NSURLSessionTask *)task</span><br><span class="line">&#123;</span><br><span class="line">    //断言，如果没有这个参数，debug下crash在这</span><br><span class="line">    NSParameterAssert(task);</span><br><span class="line">    NSParameterAssert(delegate);</span><br><span class="line"></span><br><span class="line">    //加锁保证字典线程安全</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    // 将AF delegate放入以taskIdentifier标记的词典中（同一个NSURLSession中的taskIdentifier是唯一的）</span><br><span class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</span><br><span class="line">   </span><br><span class="line">    // 为AF delegate 设置task 的progress监听</span><br><span class="line">    [delegate setupProgressForTask:task];</span><br><span class="line">    </span><br><span class="line">    //添加task开始和暂停的通知</span><br><span class="line">    [self addNotificationObserverForTask:task];</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个方法主要就是把AF代理和task建立映射，存在了一个我们事先声明好的字典里。</li>
<li>而要加锁的原因是因为本身我们这个字典属性是mutable的，是线程不安全的。而我们对这些方法的调用，确实是会在复杂的多线程环境中，后面会仔细提到线程问题。</li>
<li>还有个<code>[delegate setupProgressForTask:task];</code>我们到方法里去看看：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">- (void)setupProgressForTask:(NSURLSessionTask *)task &#123;</span><br><span class="line">    </span><br><span class="line">    __weak __typeof__(task) weakTask = task;</span><br><span class="line"></span><br><span class="line">    //拿到上传下载期望的数据大小</span><br><span class="line">    self.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend;</span><br><span class="line">    self.downloadProgress.totalUnitCount = task.countOfBytesExpectedToReceive;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //将上传与下载进度和 任务绑定在一起，直接cancel suspend resume进度条，可以cancel...任务</span><br><span class="line">    [self.uploadProgress setCancellable:YES];</span><br><span class="line">    [self.uploadProgress setCancellationHandler:^&#123;</span><br><span class="line">        __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">        [strongTask cancel];</span><br><span class="line">    &#125;];</span><br><span class="line">    [self.uploadProgress setPausable:YES];</span><br><span class="line">    [self.uploadProgress setPausingHandler:^&#123;</span><br><span class="line">        __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">        [strongTask suspend];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    if ([self.uploadProgress respondsToSelector:@selector(setResumingHandler:)]) &#123;</span><br><span class="line">        [self.uploadProgress setResumingHandler:^&#123;</span><br><span class="line">            __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">            [strongTask resume];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [self.downloadProgress setCancellable:YES];</span><br><span class="line">    [self.downloadProgress setCancellationHandler:^&#123;</span><br><span class="line">        __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">        [strongTask cancel];</span><br><span class="line">    &#125;];</span><br><span class="line">    [self.downloadProgress setPausable:YES];</span><br><span class="line">    [self.downloadProgress setPausingHandler:^&#123;</span><br><span class="line">        __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">        [strongTask suspend];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    if ([self.downloadProgress respondsToSelector:@selector(setResumingHandler:)]) &#123;</span><br><span class="line">        [self.downloadProgress setResumingHandler:^&#123;</span><br><span class="line">            __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">            [strongTask resume];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //观察task的这些属性</span><br><span class="line">    [task addObserver:self</span><br><span class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))</span><br><span class="line">              options:NSKeyValueObservingOptionNew</span><br><span class="line">              context:NULL];</span><br><span class="line">    [task addObserver:self</span><br><span class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))</span><br><span class="line">              options:NSKeyValueObservingOptionNew</span><br><span class="line">              context:NULL];</span><br><span class="line"></span><br><span class="line">    [task addObserver:self</span><br><span class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))</span><br><span class="line">              options:NSKeyValueObservingOptionNew</span><br><span class="line">              context:NULL];</span><br><span class="line">    [task addObserver:self</span><br><span class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToSend))</span><br><span class="line">              options:NSKeyValueObservingOptionNew</span><br><span class="line">              context:NULL];</span><br><span class="line"></span><br><span class="line">    //观察progress这两个属性</span><br><span class="line">    [self.downloadProgress addObserver:self</span><br><span class="line">                            forKeyPath:NSStringFromSelector(@selector(fractionCompleted))</span><br><span class="line">                               options:NSKeyValueObservingOptionNew</span><br><span class="line">                               context:NULL];</span><br><span class="line">    [self.uploadProgress addObserver:self</span><br><span class="line">                          forKeyPath:NSStringFromSelector(@selector(fractionCompleted))</span><br><span class="line">                             options:NSKeyValueObservingOptionNew</span><br><span class="line">                             context:NULL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个方法也非常简单，主要做了以下几件事：<br>1）设置  <code>downloadProgress</code>与<code>uploadProgress</code>的一些属性，并且把两者和task的任务状态绑定在了一起。注意这两者都是NSProgress的实例对象，（这里可能又一群小伙伴楞在这了，这是个什么…）简单来说，这就是iOS7引进的一个用来管理进度的类，可以开始，暂停，取消，完整的对应了task的各种状态，当progress进行各种操作的时候，task也会引发对应操作。<br>2）给task和progress的各个属及添加KVO监听，至于监听了干什么用，我们接着往下看：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    </span><br><span class="line">    //是task</span><br><span class="line">    if ([object isKindOfClass:[NSURLSessionTask class]] || [object isKindOfClass:[NSURLSessionDownloadTask class]]) &#123;</span><br><span class="line">        //给进度条赋新值</span><br><span class="line">        if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesReceived))]) &#123;</span><br><span class="line">            self.downloadProgress.completedUnitCount = [change[NSKeyValueChangeNewKey] longLongValue];</span><br><span class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))]) &#123;</span><br><span class="line">            self.downloadProgress.totalUnitCount = [change[NSKeyValueChangeNewKey] longLongValue];</span><br><span class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesSent))]) &#123;</span><br><span class="line">            self.uploadProgress.completedUnitCount = [change[NSKeyValueChangeNewKey] longLongValue];</span><br><span class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToSend))]) &#123;</span><br><span class="line">            self.uploadProgress.totalUnitCount = [change[NSKeyValueChangeNewKey] longLongValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //上面的赋新值会触发这两个，调用block回调，用户拿到进度</span><br><span class="line">    else if ([object isEqual:self.downloadProgress]) &#123;</span><br><span class="line">        if (self.downloadProgressBlock) &#123;</span><br><span class="line">            self.downloadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ([object isEqual:self.uploadProgress]) &#123;</span><br><span class="line">        if (self.uploadProgressBlock) &#123;</span><br><span class="line">            self.uploadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法非常简单直观，主要就是如果task触发KVO,则给progress进度赋值，应为赋值了，所以会触发progress的KVO，也会调用到这里，然后去执行我们传进来的<code>downloadProgressBlock</code>和<code>uploadProgressBlock</code>。主要的作用就是为了让进度实时的传递。</li>
<li>主要是观摩一下大神的写代码的结构，这个解耦的编程思想，不愧是大神…</li>
<li>还有一点需要注意：我们之前的setProgress和这个KVO监听，都是在我们AF自定义的delegate内的，是<strong>有一个task就会有一个delegate的。所以说我们是每个task都会去监听这些属性，分别在各自的AF代理内。</strong>看到这，可能有些小伙伴会有点乱，没关系。等整个讲完之后我们还会详细的去讲捋一捋manager、task、还有AF自定义代理三者之前的对应关系。</li>
</ul>
<p>到这里我们整个对task的处理就完成了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-77ff15b37bfbeac3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>分割图.png</p>
<p>接着task就开始请求网络了，还记得我们初始化方法中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];</span><br></pre></td></tr></table></figure>
<p>我们把AFUrlSessionManager作为了所有的task的delegate。当我们请求网络的时候，这些代理开始调用了：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-5a404cc7d92fb8ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>NSUrlSession的代理.png</p>
<ul>
<li><p>AFUrlSessionManager一共实现了如上图所示这么一大堆NSUrlSession相关的代理。（小伙伴们的顺序可能不一样，楼主根据代理隶属重新排序了一下）</p>
</li>
<li><p>而只转发了其中3条到AF自定义的delegate中：</p>
<p>​</p>
<p>​</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-e6469f92ca6a550e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>AF自定义delegate.png</p>
</li>
</ul>
<p>这就是我们一开始说的，AFUrlSessionManager对这一大堆代理做了一些公共的处理，而转发到AF自定义代理的3条，则负责把每个task对应的数据回调出去。</p>
<p>又有小伙伴问了，我们设置的这个代理不是<code>NSURLSessionDelegate</code>吗？怎么能响应NSUrlSession这么多代理呢？我们点到类的声明文件中去看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@protocol NSURLSessionDelegate &lt;NSObject&gt;</span><br><span class="line">@protocol NSURLSessionTaskDelegate &lt;NSURLSessionDelegate&gt;</span><br><span class="line">@protocol NSURLSessionDataDelegate &lt;NSURLSessionTaskDelegate&gt;</span><br><span class="line">@protocol NSURLSessionDownloadDelegate &lt;NSURLSessionTaskDelegate&gt;</span><br><span class="line">@protocol NSURLSessionStreamDelegate &lt;NSURLSessionTaskDelegate&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们可以看到这些代理都是继承关系，而在<code>NSURLSession</code>实现中，只要设置了这个代理，它会去判断这些所有的代理，是否<code>respondsToSelector</code>这些代理中的方法，如果响应了就会去调用。</li>
<li>而AF还重写了<code>respondsToSelector</code>方法:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> - (BOOL)respondsToSelector:(SEL)selector &#123;</span><br><span class="line">    </span><br><span class="line">    //复写了selector的方法，这几个方法是在本类有实现的，但是如果外面的Block没赋值的话，则返回NO，相当于没有实现！</span><br><span class="line">    if (selector == @selector(URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:)) &#123;</span><br><span class="line">        return self.taskWillPerformHTTPRedirection != nil;</span><br><span class="line">    &#125; else if (selector == @selector(URLSession:dataTask:didReceiveResponse:completionHandler:)) &#123;</span><br><span class="line">        return self.dataTaskDidReceiveResponse != nil;</span><br><span class="line">    &#125; else if (selector == @selector(URLSession:dataTask:willCacheResponse:completionHandler:)) &#123;</span><br><span class="line">        return self.dataTaskWillCacheResponse != nil;</span><br><span class="line">    &#125; else if (selector == @selector(URLSessionDidFinishEventsForBackgroundURLSession:)) &#123;</span><br><span class="line">        return self.didFinishEventsForBackgroundURLSession != nil;</span><br><span class="line">    &#125;</span><br><span class="line">    return [[self class] instancesRespondToSelector:selector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样如果没实现这些我们自定义的Block也不会去回调这些代理。因为本身某些代理，只执行了这些自定义的Block，如果Block都没有赋值，那我们调用代理也没有任何意义。<br>讲到这，我们顺便看看AFUrlSessionManager的一些自定义Block：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDidBecomeInvalidBlock sessionDidBecomeInvalid;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDidReceiveAuthenticationChallengeBlock sessionDidReceiveAuthenticationChallenge;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDidFinishEventsForBackgroundURLSessionBlock didFinishEventsForBackgroundURLSession;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskWillPerformHTTPRedirectionBlock taskWillPerformHTTPRedirection;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskDidReceiveAuthenticationChallengeBlock taskDidReceiveAuthenticationChallenge;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskNeedNewBodyStreamBlock taskNeedNewBodyStream;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskDidSendBodyDataBlock taskDidSendBodyData;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskDidCompleteBlock taskDidComplete;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidReceiveResponseBlock dataTaskDidReceiveResponse;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidBecomeDownloadTaskBlock dataTaskDidBecomeDownloadTask;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidReceiveDataBlock dataTaskDidReceiveData;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDataTaskWillCacheResponseBlock dataTaskWillCacheResponse;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidWriteDataBlock downloadTaskDidWriteData;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidResumeBlock downloadTaskDidResume;</span><br></pre></td></tr></table></figure>
<p>各自对应的还有一堆这样的set方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> - (void)setSessionDidBecomeInvalidBlock:(void (^)(NSURLSession *session, NSError *error))block &#123;</span><br><span class="line">    self.sessionDidBecomeInvalid = block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法都是一样的，就不重复粘贴占篇幅了。<br>主要谈谈这个设计思路</p>
<ul>
<li>作者用@property把这个些Block属性在.m文件中声明,然后复写了set方法。</li>
<li>然后在.h中去声明这些set方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setSessionDidBecomeInvalidBlock:(nullable void (^)(NSURLSession *session, NSError *error))block;</span><br></pre></td></tr></table></figure>
<p>为什么要绕这么一大圈呢？<strong>原来这是为了我们这些用户使用起来方便，调用set方法去设置这些Block，能很清晰的看到Block的各个参数与返回值。</strong>大神的精髓的编程思想无处不体现…</p>
<p>接下来我们就讲讲这些代理方法做了什么（按照顺序来）：</p>
<h6 id="NSURLSessionDelegate"><a href="#NSURLSessionDelegate" class="headerlink" title="NSURLSessionDelegate"></a>NSURLSessionDelegate</h6><h6 id="代理1："><a href="#代理1：" class="headerlink" title="代理1："></a>代理1：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//当前这个session已经失效时，该代理方法被调用。</span><br><span class="line">/*</span><br><span class="line"> 如果你使用finishTasksAndInvalidate函数使该session失效，</span><br><span class="line"> 那么session首先会先完成最后一个task，然后再调用URLSession:didBecomeInvalidWithError:代理方法，</span><br><span class="line"> 如果你调用invalidateAndCancel方法来使session失效，那么该session会立即调用上面的代理方法。</span><br><span class="line"> */</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">didBecomeInvalidWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    if (self.sessionDidBecomeInvalid) &#123;</span><br><span class="line">        self.sessionDidBecomeInvalid(session, error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法调用时机注释写的很清楚，就调用了一下我们自定义的Block,还发了一个失效的通知，至于这个通知有什么用。很抱歉，AF没用它做任何事，只是发了…目的是用户自己可以利用这个通知做什么事吧。</li>
<li>其实AF大部分通知都是如此。当然，还有一部分通知AF还是有自己用到的，包括配合对UIKit的一些扩展来使用，后面我们会有单独篇幅展开讲讲这些UIKit的扩展类的实现。</li>
</ul>
<h6 id="代理2："><a href="#代理2：" class="headerlink" title="代理2："></a>代理2：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//2、https认证</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    //挑战处理类型为 默认</span><br><span class="line">    /*</span><br><span class="line">     NSURLSessionAuthChallengePerformDefaultHandling：默认方式处理</span><br><span class="line">     NSURLSessionAuthChallengeUseCredential：使用指定的证书</span><br><span class="line">     NSURLSessionAuthChallengeCancelAuthenticationChallenge：取消挑战</span><br><span class="line">     */</span><br><span class="line">    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">    __block NSURLCredential *credential = nil;</span><br><span class="line"></span><br><span class="line">    // sessionDidReceiveAuthenticationChallenge是自定义方法，用来如何应对服务器端的认证挑战</span><br><span class="line"></span><br><span class="line">    if (self.sessionDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 此处服务器要求客户端的接收认证挑战方法是NSURLAuthenticationMethodServerTrust</span><br><span class="line">        // 也就是说服务器端需要客户端返回一个根据认证挑战的保护空间提供的信任（即challenge.protectionSpace.serverTrust）产生的挑战证书。</span><br><span class="line">       </span><br><span class="line">        // 而这个证书就需要使用credentialForTrust:来创建一个NSURLCredential对象</span><br><span class="line">        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</span><br><span class="line">            </span><br><span class="line">            // 基于客户端的安全策略来决定是否信任该服务器，不信任的话，也就没必要响应挑战</span><br><span class="line">            if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">               </span><br><span class="line">                // 创建挑战证书（注：挑战方式为UseCredential和PerformDefaultHandling都需要新建挑战证书）</span><br><span class="line">                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">                // 确定挑战的方式</span><br><span class="line">                if (credential) &#123;</span><br><span class="line">                    //证书挑战</span><br><span class="line">                    disposition = NSURLSessionAuthChallengeUseCredential;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //默认挑战  唯一区别，下面少了这一步！</span><br><span class="line">                    disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //取消挑战</span><br><span class="line">                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //默认挑战方式</span><br><span class="line">            disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //完成挑战</span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>函数作用：<br>web服务器接收到客户端请求时，有时候需要先验证客户端是否为正常用户，再决定是够返回真实数据。这种情况称之为服务端要求客户端接收挑战（NSURLAuthenticationChallenge <em>challenge）。接收到挑战后，客户端要根据服务端传来的challenge来生成completionHandler所需的NSURLSessionAuthChallengeDisposition disposition和NSURLCredential </em>credential（disposition指定应对这个挑战的方法，而credential是客户端生成的挑战证书，注意只有challenge中认证方法为NSURLAuthenticationMethodServerTrust的时候，才需要生成挑战证书）。最后调用completionHandler回应服务器端的挑战。</li>
</ul>
</blockquote>
<ul>
<li>函数讨论：<br>该代理方法会在下面两种情况调用：</li>
</ul>
<ol>
<li>当服务器端要求客户端提供证书时或者进行NTLM认证（Windows NT LAN Manager，微软提出的WindowsNT挑战/响应验证机制）时，此方法允许你的app提供正确的挑战证书。</li>
<li>当某个session使用SSL/TLS协议，第一次和服务器端建立连接的时候，服务器会发送给iOS客户端一个证书，此方法允许你的app验证服务期端的证书链（certificate keychain）<br>注：如果你没有实现该方法，该session会调用其NSURLSessionTaskDelegate的代理方法URLSession:task:didReceiveChallenge:completionHandler: 。</li>
</ol>
<p>这里，我把官方文档对这个方法的描述翻译了一下。<br>总结一下，这个方法其实就是做https认证的。看看上面的注释，大概能看明白这个方法做认证的步骤，我们还是如果有自定义的做认证的Block，则调用我们自定义的，否则去执行默认的认证步骤，最后调用完成认证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//完成挑战 </span><br><span class="line">if (completionHandler) &#123; </span><br><span class="line">      completionHandler(disposition, credential); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="代理3："><a href="#代理3：" class="headerlink" title="代理3："></a>代理3：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//3、 当session中所有已经入队的消息被发送出去后，会调用该代理方法。</span><br><span class="line">- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session &#123;</span><br><span class="line">    if (self.didFinishEventsForBackgroundURLSession) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            self.didFinishEventsForBackgroundURLSession(session);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>官方文档翻译：</p>
<blockquote>
<p>函数讨论：</p>
</blockquote>
<ul>
<li>在iOS中，当一个后台传输任务完成或者后台传输时需要证书，而此时你的app正在后台挂起，那么你的app在后台会自动重新启动运行，并且这个app的UIApplicationDelegate会发送一个application:handleEventsForBackgroundURLSession:completionHandler:消息。该消息包含了对应后台的session的identifier，而且这个消息会导致你的app启动。你的app随后应该先存储completion handler，然后再使用相同的identifier创建一个background configuration，并根据这个background configuration创建一个新的session。这个新创建的session会自动与后台任务重新关联在一起。</li>
<li>当你的app获取了一个URLSessionDidFinishEventsForBackgroundURLSession:消息，这就意味着之前这个session中已经入队的所有消息都转发出去了，这时候再调用先前存取的completion handler是安全的，或者因为内部更新而导致调用completion handler也是安全的。</li>
</ul>
<h6 id="NSURLSessionTaskDelegate"><a href="#NSURLSessionTaskDelegate" class="headerlink" title="NSURLSessionTaskDelegate"></a>NSURLSessionTaskDelegate</h6><h6 id="代理4："><a href="#代理4：" class="headerlink" title="代理4："></a>代理4：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//被服务器重定向的时候调用</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">willPerformHTTPRedirection:(NSHTTPURLResponse *)response</span><br><span class="line">        newRequest:(NSURLRequest *)request</span><br><span class="line"> completionHandler:(void (^)(NSURLRequest *))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSURLRequest *redirectRequest = request;</span><br><span class="line"></span><br><span class="line">    // step1. 看是否有对应的user block 有的话转发出去，通过这4个参数，返回一个NSURLRequest类型参数，request转发、网络重定向.</span><br><span class="line">    if (self.taskWillPerformHTTPRedirection) &#123;</span><br><span class="line">        //用自己自定义的一个重定向的block实现，返回一个新的request。</span><br><span class="line">        redirectRequest = self.taskWillPerformHTTPRedirection(session, task, response, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        // step2. 用request重新请求</span><br><span class="line">        completionHandler(redirectRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一开始我以为这个方法是类似<code>NSURLProtocol</code>，可以在请求时自己主动的去重定向request，后来发现不是，这个方法是在服务器去重定向的时候，才会被调用。为此我写了段简单的PHP测了测：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">defined(&apos;BASEPATH&apos;) OR exit(&apos;No direct script access allowed&apos;);</span><br><span class="line"></span><br><span class="line">class Welcome extends CI_Controller &#123;</span><br><span class="line">    public function index()</span><br><span class="line">    &#123;</span><br><span class="line">        header(&quot;location: http://www.huixionghome.cn/&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>证实确实如此，当我们服务器重定向的时候，代理就被调用了，我们可以去重新定义这个重定向的request。</p>
<ul>
<li>关于这个代理还有一些需要注意的地方：</li>
</ul>
<blockquote>
<p>此方法只会在default session或者ephemeral session中调用，而在background session中，session task会自动重定向。</p>
</blockquote>
<p>这里指的模式是我们一开始Init的模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (!configuration) &#123;</span><br><span class="line">    configuration = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">&#125;</span><br><span class="line">self.sessionConfiguration = configuration;</span><br></pre></td></tr></table></figure>
<p>这个模式总共分为3种：</p>
<blockquote>
<p>对于NSURLSession对象的初始化需要使用NSURLSessionConfiguration，而NSURLSessionConfiguration有三个类工厂方法：<br>+defaultSessionConfiguration 返回一个标准的 configuration，这个配置实际上与 NSURLConnection 的网络堆栈（networking stack）是一样的，具有相同的共享 NSHTTPCookieStorage，共享 NSURLCache 和共享NSURLCredentialStorage。<br>+ephemeralSessionConfiguration 返回一个预设配置，这个配置中不会对缓存，Cookie 和证书进行持久性的存储。这对于实现像秘密浏览这种功能来说是很理想的。<br>+backgroundSessionConfiguration:(NSString *)identifier 的独特之处在于，它会创建一个后台 session。后台 session 不同于常规的，普通的 session，它甚至可以在应用程序挂起，退出或者崩溃的情况下运行上传和下载任务。初始化时指定的标识符，被用于向任何可能在进程外恢复后台传输的守护进程（daemon）提供上下文。</p>
</blockquote>
<h6 id="代理5："><a href="#代理5：" class="headerlink" title="代理5："></a>代理5：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//https认证</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">    __block NSURLCredential *credential = nil;</span><br><span class="line"></span><br><span class="line">    if (self.taskDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = self.taskDidReceiveAuthenticationChallenge(session, task, challenge, &amp;credential);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</span><br><span class="line">            if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">                disposition = NSURLSessionAuthChallengeUseCredential;</span><br><span class="line">                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>鉴于篇幅，就不去贴官方文档的翻译了，大概总结一下：<br>之前我们也有一个https认证，功能一样，执行的内容也完全一样。</li>
<li>区别在于这个是non-session-level级别的认证，而之前的是session-level级别的。</li>
<li>相对于它，多了一个参数task,然后调用我们自定义的Block会多回传这个task作为参数，这样我们就可以根据每个task去自定义我们需要的https认证方式。</li>
</ul>
<h6 id="代理6："><a href="#代理6：" class="headerlink" title="代理6："></a>代理6：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//当一个session task需要发送一个新的request body stream到服务器端的时候，调用该代理方法。</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line"> needNewBodyStream:(void (^)(NSInputStream *bodyStream))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    NSInputStream *inputStream = nil;</span><br><span class="line"></span><br><span class="line">    //有自定义的taskNeedNewBodyStream,用自定义的，不然用task里原始的stream</span><br><span class="line">    if (self.taskNeedNewBodyStream) &#123;</span><br><span class="line">        inputStream = self.taskNeedNewBodyStream(session, task);</span><br><span class="line">    &#125; else if (task.originalRequest.HTTPBodyStream &amp;&amp; [task.originalRequest.HTTPBodyStream conformsToProtocol:@protocol(NSCopying)]) &#123;</span><br><span class="line">        inputStream = [task.originalRequest.HTTPBodyStream copy];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>该代理方法会在下面两种情况被调用：<ol>
<li>如果task是由uploadTaskWithStreamedRequest:创建的，那么提供初始的request body stream时候会调用该代理方法。</li>
<li>因为认证挑战或者其他可恢复的服务器错误，而导致需要客户端重新发送一个含有body stream的request，这时候会调用该代理。</li>
</ol>
</li>
</ul>
<h6 id="代理7："><a href="#代理7：" class="headerlink" title="代理7："></a>代理7：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> //周期性地通知代理发送到服务器端数据的进度。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">   didSendBodyData:(int64_t)bytesSent</span><br><span class="line">    totalBytesSent:(int64_t)totalBytesSent</span><br><span class="line">totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend</span><br><span class="line">&#123;</span><br><span class="line">     // 如果totalUnitCount获取失败，就使用HTTP header中的Content-Length作为totalUnitCount</span><br><span class="line"></span><br><span class="line">    int64_t totalUnitCount = totalBytesExpectedToSend;</span><br><span class="line">    if(totalUnitCount == NSURLSessionTransferSizeUnknown) &#123;</span><br><span class="line">        NSString *contentLength = [task.originalRequest valueForHTTPHeaderField:@&quot;Content-Length&quot;];</span><br><span class="line">        if(contentLength) &#123;</span><br><span class="line">            totalUnitCount = (int64_t) [contentLength longLongValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (self.taskDidSendBodyData) &#123;</span><br><span class="line">        self.taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalUnitCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>就是每次发送数据给服务器，会回调这个方法，通知已经发送了多少，总共要发送多少。</li>
<li>代理方法里也就是仅仅调用了我们自定义的Block而已。</li>
</ul>
<h6 id="未完总结："><a href="#未完总结：" class="headerlink" title="未完总结："></a>未完总结：</h6><ul>
<li>其实写了这么多，还没有讲到真正重要的地方，但是因为已经接近简书最大篇幅，所以只能先在这里结个尾了。</li>
<li>如果能看到这里，说明你是个非常有耐心，非常好学，非常nice的iOS开发。楼主为你点个赞。那么相信你也不吝啬手指动一动，给本文点个喜欢…顺便关注一下楼主…毕竟写了这么多…也很辛苦…咳咳，我不小心说出心声了么？</li>
<li>最后，万一如果本文有人转载，麻烦注明出处~谢谢！</li>
</ul>
<p>后续文章:<br><a href="https://www.jianshu.com/p/f32bd79233da" target="_blank" rel="noopener">AFNetworking到底做了什么（二）?</a><br><a href="https://www.jianshu.com/p/a84237b07611" target="_blank" rel="noopener">AFNetworking之于https认证</a><br><a href="https://www.jianshu.com/p/4ffeb1ba3046" target="_blank" rel="noopener">AFNetworking之UIKit扩展与缓存实现</a><br><a href="https://www.jianshu.com/p/7ed7c0be15b4" target="_blank" rel="noopener">AFNetworking到底做了什么？(终)</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/网络数据传输安全及SSH与HTTPS工作原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/网络数据传输安全及SSH与HTTPS工作原理/" itemprop="url">
                  网络数据传输安全及SSH与HTTPS工作原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 15:24:57 / 修改时间：15:46:32" itemprop="dateCreated datePublished" datetime="2018-09-17T15:24:57+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络相关/" itemprop="url" rel="index"><span itemprop="name">网络相关</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[转自 <a href="https://home.cnblogs.com/u/yyds/" target="_blank" rel="noopener">云游道士</a>]（<a href="https://www.cnblogs.com/yyds/p/6992125.html）" target="_blank" rel="noopener">https://www.cnblogs.com/yyds/p/6992125.html）</a></p>
<h2 id="本节内容"><a href="#本节内容" class="headerlink" title="本节内容"></a>本节内容</h2><hr>
<ol>
<li>网络数据传输安全概述</li>
<li>数据加密算法分类</li>
<li>SSH工作原理</li>
<li>HTTPS工作原理</li>
<li>参考资料</li>
</ol>
<p>个人一直在努力推动git在公司内部的普及和使用，前些日子在公司内部做了一次分享课，给大家介绍了下项目发布流程相关的内容，顺便普及了一些git的相关知识。对git是什么，以及怎样配置和使用它做了一些说明。但事后，很多同事的反馈，让我意识到他们很多人都卡在ssh免密钥登录的配置上。我们常说，学习一个新的东西应该遵循3W1H法则–WAHT(是什么)，WHEN(什么时候用)，HOW（怎样用）和 WHY（为什么这样用）。我想大家应该是因为不知道为什么这样用，所以才会感到困惑。刚好，最近也在整理“使用Python相关模块进行数据加密”的文档，需要做些理论性的铺垫，所以才想写这篇文章，希望对大家有所帮助。</p>
<blockquote>
<p>另外需要说明的是，网络安全涉及很多方面的很多内容，本文只是针对网络数据传输过程中的安全性发表一下个人认识和看法。如果描述的有什么不妥之处，欢迎大家留言交流和指正。</p>
</blockquote>
<h2 id="一、网络数据传输安全概述"><a href="#一、网络数据传输安全概述" class="headerlink" title="一、网络数据传输安全概述"></a>一、网络数据传输安全概述</h2><hr>
<p>我们说的数据加密与解密通常是为了保证数据在网络传输过程中的安全性。在网络发展初期，网络的数据安全性是没有被足够的重视的。事实上，当时为了实现数据可以通过网络进行传输已经耗费了科学家大部分男细胞，因此在TCP/IP协议设计的初期，他们也实在没有太多精力去过多考虑数据在网络传输过程中可能存在的安全性问题。随着TCP/IP协议及相关技术的日渐成熟，网络数据传输技术越来越稳定，人们才慢慢开始重视这个问题，美国国家标准与技术研究院（National Institue of Standard and Technology，简称NIST）也开始制定相关的安全标准。</p>
<p>网络安全涉及到很多个方面，我们这里仅仅讨论下网络数据传输过程中可能受到的威胁，其中常见的有：</p>
<ul>
<li>数据窃听</li>
<li>数据篡改</li>
<li>身份伪装</li>
</ul>
<p>针对以上威胁，我们介绍下网络数据传输的安全性涉及的几个方面：</p>
<h3 id="1-机密性"><a href="#1-机密性" class="headerlink" title="1. 机密性"></a>1. 机密性</h3><p>机密性是指对要传输的数据进行加密和解密，防止第三方看到通信数据的明文内容。其对应的通信过程如下：</p>
<p>数据发送方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plaintext(明文) ==&gt; 转换算法 ==&gt; ciphertext(密文)</span><br></pre></td></tr></table></figure>
<p>数据接收方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ciphertext(密文) ==&gt; 转换算法 ==&gt; plaintext(明文)</span><br></pre></td></tr></table></figure>
<h3 id="2-完整性"><a href="#2-完整性" class="headerlink" title="2. 完整性"></a>2. 完整性</h3><p>数据完整性是指不允许数据在传输过程中被修改（第三方恶意篡改或电平信号造成的部分数据丢失），但是它不要求数据的机密性，也就是说允许其他人看到明文数据。我们通常通过以不可逆的算法对数据提取特征码（也叫数据指纹），通过验证特征码的一致性来判断数据是否被修改过，通信过程如下：</p>
<p>数据发送发：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plaintext(明文) ==&gt; 转换算法 ==&gt; plaintext(明文) + footprint(数据指纹A)</span><br></pre></td></tr></table></figure>
<p>数据接收方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plaintext(明文) + footprint(数据指纹A) ==&gt; 转换算法 ==&gt; footprint(数据指纹B) ==&gt; 对比数据指纹A与B是否一致</span><br></pre></td></tr></table></figure>
<h3 id="3-身份验证"><a href="#3-身份验证" class="headerlink" title="3. 身份验证"></a>3. 身份验证</h3><p>身份验证通常是指数据接收方需要确认发送数据给自己的数据是自己想要通信的那一方，防止他人冒充通信对方的身份进行通信。身份验证的大体原理是：数据发送方与数据接收方约定一种特殊的数据加解密方式，数据发送方将一个通过约定的加密方式进行加密后的数据发送给数据接收方，数据接收方如能按照约定的加密方式正确解密该数据就表示对数据发送方的身份验证成功。其对应的通信过程如下：</p>
<p>数据发送方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plaintext(明文) ==&gt; 转换算法 ==&gt; ciphertext(密文)</span><br></pre></td></tr></table></figure>
<p>数据接收方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ciphertext(密文) ==&gt; 转换算法 ==&gt; plaintext(明文)</span><br></pre></td></tr></table></figure>
<h2 id="二、数据加密算法分类"><a href="#二、数据加密算法分类" class="headerlink" title="二、数据加密算法分类"></a>二、数据加密算法分类</h2><hr>
<p>上面提到的网络数据传输所涉及到的几个方面都需要特定的转换算法来实现，常用的转换算法（数据加密/解密算法）大体上可以分为以下几类：</p>
<h3 id="1-对称加密"><a href="#1-对称加密" class="headerlink" title="1. 对称加密"></a>1. 对称加密</h3><p>对称加密是指数据加密与解密使用相同的密钥。</p>
<h5 id="主要功能："><a href="#主要功能：" class="headerlink" title="主要功能："></a>主要功能：</h5><p>通常用于保证数据的机密性。</p>
<h5 id="常用的算法实现："><a href="#常用的算法实现：" class="headerlink" title="常用的算法实现："></a>常用的算法实现：</h5><ul>
<li><strong>DES：</strong> Data Encryption Standard，秘钥长度为56位，2003年左右被破解–秘钥可以暴力破解。</li>
<li><strong>3DES：</strong> DES的改进版本。</li>
<li><strong>AES：</strong> Advanced Encryption Standard，支持的秘钥长度包括 128bits，192bits，258bits，384bits，512bits。</li>
</ul>
<blockquote>
<p>需要说明的是，秘钥长度越长，数据加密与解密的时间就越久。</p>
</blockquote>
<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><ul>
<li>加密与解密使用的密钥相同。</li>
<li>在一定程度上实现了数据的机密性，且简单、快速。</li>
<li>但是由于算法一般都是公开的，因此机密性几乎完全依赖于密钥。</li>
<li>同一发送方与不同接收方进行通信时应使用不同的密钥，防止数据被窃听或拦截后被解密。</li>
</ul>
<h5 id="存在的问题："><a href="#存在的问题：" class="headerlink" title="存在的问题："></a>存在的问题：</h5><ul>
<li>当通信对象很多时会面临众多秘钥的有效管理问题。</li>
<li>对于一个新的数据通信对象，密钥怎样进行传输的问题。</li>
</ul>
<h3 id="2-单向加密"><a href="#2-单向加密" class="headerlink" title="2. 单向加密"></a>2. 单向加密</h3><p>单向加密是指只能对明文数据进行加密，而不能解密数据。</p>
<h5 id="主要功能：-1"><a href="#主要功能：-1" class="headerlink" title="主要功能："></a>主要功能：</h5><p>通常用于保证数据的完整性。</p>
<h5 id="常用的算法实现：-1"><a href="#常用的算法实现：-1" class="headerlink" title="常用的算法实现："></a>常用的算法实现：</h5><ul>
<li><strong>MD5：</strong> 128bits</li>
<li><strong>SHA：</strong> SHA1(160bits), SHA224, SHA256, SHA384</li>
</ul>
<h5 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h5><ul>
<li>不可逆：无法根据数据指纹/特征码还原原来的数据。</li>
<li>输入相同，输出必然相同。</li>
<li>雪崩效应：输入的微小改变，将会引起结果的巨大改变。</li>
<li>定长输出：无论原始数据有多长，结果的长度是相同的。</li>
</ul>
<h5 id="存在的问题：-1"><a href="#存在的问题：-1" class="headerlink" title="存在的问题："></a>存在的问题：</h5><p>可能出现中间人攻击，中间人可以对原始内容进行修改之后重新生成数据指纹，数据接收方验证数据指纹时会发现数据是正常的。此时，数据发送方只能把生成的数据指纹进行加密后再发送给数据接收方，<strong>那么问题就又回到了加密密钥的传输和管理上。</strong></p>
<h3 id="3-公钥加密（也叫非对称加密）"><a href="#3-公钥加密（也叫非对称加密）" class="headerlink" title="3. 公钥加密（也叫非对称加密）"></a>3. 公钥加密（也叫非对称加密）</h3><p>公钥加密，也被称作非对称加密，也就是说加密和解密所使用的密钥是不同的。</p>
<h5 id="主要作用："><a href="#主要作用：" class="headerlink" title="主要作用："></a>主要作用：</h5><p>通常用于保证身份验证。</p>
<h5 id="常用的公钥加密算法有："><a href="#常用的公钥加密算法有：" class="headerlink" title="常用的公钥加密算法有："></a>常用的公钥加密算法有：</h5><ul>
<li><strong>RSA：</strong> 可以实现数字签名 和 数据加密</li>
<li><strong>DSA：</strong> 只能实现数字签名，不能实现数据加密</li>
</ul>
<h5 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h5><ul>
<li>加密与解密使用的不同的密钥。</li>
<li>实际上它所使用的密钥是一对儿，一个交公钥，一个叫私钥。这对密钥不是独立的，公钥是从私钥中提炼出来，因此私钥是很长的，968位、1024位、2048位、4096位的都有。</li>
<li>通常公钥是公开的，所有人都可以得到；私钥是不能公开的，只有自己才有。</li>
<li>用公钥机密的内容只能用与之对应的私钥才能解密，反之亦然，这个特点尤为重要。</li>
</ul>
<p>我们发现公钥加密“貌似”已经解决了密钥管理的问题–所有人只需要知道自己的那一对儿密钥即可，需要跟谁通信就去获取对方的公钥，然后通过这个公钥对数据进行加密和机密就可以了。我们可以用它来完成以下两件事情：</p>
<ul>
<li><strong>用自己的私钥加密，</strong> 可以保证身份验证，因为用你的私钥加密的数据只能用你的公开的公钥才能解密数据；但是不能保证数据的机密性，因为所有人都知道你的公钥。浏览器检查CA证书合法性时，验证CA机构的数字签名时就是通过这种方式进行的。</li>
<li><strong>用对方的公钥加密，</strong> 可以保证数据的机密性，因为只有用对方的私钥才能解密，而对方的私钥只有他一个人有。HTTPS通信时，通过密钥协商技术得到的密钥进行传输时就是通过这种方式来保证机密性的。其实用对方公钥加密也可以用于用于身份验证，验证过程是：A用B的公钥加密数据后将密文传输给B，B用自己的私钥进行解密并将明文发送回给A，A对比B返回的明文和自己加密前的明文一致则表示对B完成了身份验证，通过SSH进行免密钥登录时就是通过这种方式来完成用户身份验证的。</li>
</ul>
<blockquote>
<p>事实上，<strong>公钥加密算法很少用于数据加密，它通常只是用来做身份认证</strong>，因为它的密钥太长，加密速度太慢–公钥加密算法的速度甚至比对称加密算法的速度慢上3个数量级（1000倍）。</p>
</blockquote>
<h5 id="存在的问题：-2"><a href="#存在的问题：-2" class="headerlink" title="存在的问题："></a>存在的问题：</h5><ul>
<li>既然公钥加密通常只用于身份验证，而不是用于保证数据的机密性，也就意味着这个密钥对儿并不能完全作为加密和解密数据的秘钥来用。那么，秘钥的管理和传输问题依然存在着，这个问题到底怎样来解决呢？</li>
<li>另外还有个问题就是，如果有人伪造了一对儿密钥，把其中的公钥发送给别人怎么办？怎样验证以获取公钥的合法性呢？</li>
</ul>
<h5 id="密钥管理的解决方案："><a href="#密钥管理的解决方案：" class="headerlink" title="密钥管理的解决方案："></a>密钥管理的解决方案：</h5><p>实际上，已经存在一种专门用于秘钥交换的算法–Diffie-Hellman加密算法。该加密算法本身仅限于秘钥的交换用途，被许多商用产品用作秘钥交换技术。这种秘钥交换技术的目的在于使得两个用户安全的交换一个密钥，以便用于之后的数据对称加密。也就是说，通信双方可以通过这个技术，动态的协商生成一个用于对称加密的密钥，而不用管理很多静态的密钥，这样就解决了密钥的管理问题。</p>
<blockquote>
<p>需要说明的是，在通过秘钥交互技术动态协商生成密钥之前，通常需要先通过公钥加密算法对对方的身份进行验证。实际上，https就是这样工作的。</p>
</blockquote>
<h5 id="防止公钥被伪造的解决方案"><a href="#防止公钥被伪造的解决方案" class="headerlink" title="防止公钥被伪造的解决方案"></a>防止公钥被伪造的解决方案</h5><p>公钥实际上也是一段文本，验证公钥的合法性涉及到两个方面：</p>
<ul>
<li>1）该公钥的发布者身份是否合法</li>
<li>2）该公钥的内容是否被篡改过</li>
</ul>
<p>其实，这个已经不是靠纯技术能解决的问题了，这需要借助一些机构和人为约定来解决。常见的解决方案有两种：</p>
<ul>
<li>1）<strong>公钥的合法拥有者，通过官方渠道声明其密钥的数据指纹：</strong> 既然时官方发布的信息，那么身份的合法性是有保证的；用户在获取公钥后也生成一个数据指纹，通过对比这两个数据指纹就知道公钥内容是否被修改过；SSH的身份验证实际上就是这个原理。</li>
<li>2）<strong>通过一些权威的机构来完成这些验证：</strong> 比如https使用的证书就是由CA机构签发的，这个在后面讲https原理时再做具体介绍。</li>
</ul>
<p>我们常见的对于上面这些加密算法的经典应用就是ssh和https了，它们都是使用这些加密算法实现的网络协议。下面我们对ssh和https的工作原理进行下介绍，一方面当做上面这些加密算法的实例讲解，帮助大家了解这些算法的经典应用；另一方面，也帮助大家更深入的理解ssh和https是什么，以及它们是怎样工作的。</p>
<h2 id="三、SSH工作原理"><a href="#三、SSH工作原理" class="headerlink" title="三、SSH工作原理"></a>三、SSH工作原理</h2><hr>
<h3 id="1-SSH是什么？"><a href="#1-SSH是什么？" class="headerlink" title="1. SSH是什么？"></a>1. SSH是什么？</h3><p>简单来说，<strong>SSH就是一种网络协议，主要用于计算机之间的加密登录与数据传输</strong>，使用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ssh user@host</span><br></pre></td></tr></table></figure>
<p>表示要以user这个用户的身份登录host这台网络机器。也可以省略前面的user，这样来用<code>ssh host</code>，表示以当前本地登录的用户名登录host这台网络机器。</p>
<p>早期，人们主要是通过telnet协议进行计算机之间的登录操作，但是它有一个很严重的安全隐患就是“数据是明文传输的”，登录时传输的包括用户名和密码在内的所有信息都有可能会被恶意拦截而暴露。而SSH则是将登录信息全部加密后进行传输的，因此使用SSH进行登录时安全的，即使数据在传输过程中被截获，里面的密码已经被加密而不会泄露。</p>
<blockquote>
<p>现在SSH作为互联网安全的一个基本解决方案，已经在全世界获得推广，且目前已经成为Linux系统的标准配置。需要说明的是，SSH只是一种协议，它有多种软件实现，既有商业的，也有开源的。OpenSSH是当前使用最为广泛的一个SSH协议的开源实现。</p>
</blockquote>
<h3 id="2-SSH工作原理"><a href="#2-SSH工作原理" class="headerlink" title="2. SSH工作原理"></a>2. SSH工作原理</h3><p>其实SSH是充分利用了公钥加密/非对称机密 、对称加密 和 单向加密 来实现数据安全登录的。在使用SSH进行通信时，通信过程分为以下几个步骤：</p>
<ul>
<li>1）<strong>生成会话密钥：</strong> 这个会话密钥，不是密钥对儿中公钥或私钥，而是通过密钥协商技术生成密钥。这个密钥会被通过被登录机器的密钥对进行加密后传输，用于后续所有（通过对称加密方式进行的)加密通信。</li>
<li>2）<strong>用户身份认证（登录）：*</strong> 这个对登录者进行身份验证的过程是通过登录者的密钥对儿对数据进行加解密验证实现的，这个过程中传输的所有数据都是通过上一步生成的密钥加密过的。</li>
<li>3）<strong>数据加密通信：</strong> 后面就行基于第1步生成的密钥进行数据加密传输的通信过程了。</li>
</ul>
<p>下面来看具体解析。</p>
<h5 id="账号密码安全登录的实现"><a href="#账号密码安全登录的实现" class="headerlink" title="账号密码安全登录的实现"></a>账号密码安全登录的实现</h5><p>上面提到，SSH是通过对数据进行加密后进行传输来保证数据安全的。但是，SSH的数据加密采用的是对称加密算法，只是对称加密所使用的密钥是通过公钥加密/非对称加密实现加密后的安全传输的。另外，每台Linux机器都有自己的密钥对儿（通常放在/etc/ssh目录下），这个密钥对儿跟具体的用户无关。其工作流程是：</p>
<ul>
<li>1）在主机A上向主机B发送连接请求；</li>
<li>2）主机B在与用户建立连接后，把自己的公钥发送给主机A；</li>
<li>3）主机A通过密钥协商技术产生一个随机密钥，然后使用主机B的公钥对这个随机密钥进行加密后发送给主机B;</li>
<li>4） 主机B接收到主机A发送过来的密文形式的密钥后，通过自己的私钥进行解密，得到对称加密使用的密钥明文；至此，会话密钥已经生成完毕了；</li>
<li>5）主机A通过生成的会话密钥对账号和密码等信息进行加密然后发送给主机B；</li>
<li>6）主机B接收到加密信息后，使用会话密钥进行解密，从而得到明文的账号和密码进行账号验证；</li>
<li>7）主机B在验证账号和密码后通知主机A是否登录成功；</li>
</ul>
<p>这样即便有人结果了账号密码信息，也是密文信息，并不能知道里面是什么内容。貌似已经OK了，但是，主机A怎么验证主机B的身份呢？如果有主机C冒充主机B截获了登录请求，将自己伪造的公钥发送给主机A，怎么办？尽管信息是加密过的，通信过程也是合法的，但是通信信息都被主机C截获了，其实这就是所谓的“中间人攻击”（Man-in-the-middle attack）。其实，<strong>对主机B进行验证就是对主机B发送过来的公钥的合法性进行验证的过程。</strong></p>
<h5 id="公钥合法性验证的实现"><a href="#公钥合法性验证的实现" class="headerlink" title="公钥合法性验证的实现"></a>公钥合法性验证的实现</h5><p>上面我们提到过，验证公钥的合法性有两种方式：</p>
<ul>
<li>1）验证公钥的官方发布的公钥数据指纹</li>
<li>2）通过权威的结构进行验证</li>
</ul>
<p>SSH主要用于机器之间的安全登录，因此通常不会通过权威的机构去签发证书，它主要是通过验证数据指纹的方式来验证公钥的合法性的。公钥的合法性验证是发生在主机A接收到主机B发送的公钥之后，主机A向主机B协商产生会话密钥之前，也就是上个部分所列举的数据机密时间的第2个步骤和第3个步骤之间。具体的工作流程如下：</p>
<ul>
<li>1）上个部分所列举的数据加密实现的第1-2步；</li>
<li>2）主机A会去当前用户家目录下的.ssh/known_hosts文件中查找是否存在该机器的公钥，如果不存在，表示主机A是第一次与该主机进行通信，那么主机A会计算出该公钥的数据指纹并要求用户对该指纹进行合法性确认。就是我们经常看到的的这样子：<br><img src="https://images2015.cnblogs.com/blog/1063221/201706/1063221-20170610110552778-2137595593.png" alt="img"></li>
<li>3）用户需要把目标主机管理员公布的公钥的数据指纹与主机A计算得到的数据指纹进行比对，如果一致，则说明该公钥是合法的；如果不一致则说明不合法；</li>
<li>4）用户如果确认该公钥是合法的，则输入yes表示继续后面的连接，主机A则会把这个公钥的内容保存到当前用户家目录下的.ssh/known_hosts文件中，然后提示用户输入密码，如下图所示：<br><img src="https://images2015.cnblogs.com/blog/1063221/201706/1063221-20170610110717965-1712933521.png" alt="img">下次再登录，执行到步骤2时，主机A发现该公钥已经在.ssh/known_hosts文件中存在了，就不用要求再次确认了，而是会直接提示输出密码：<br><img src="https://images2015.cnblogs.com/blog/1063221/201706/1063221-20170610110310809-1975093095.png" alt="img"></li>
<li>5）至此，主机B的身份合法性验证就结束了。</li>
</ul>
<blockquote>
<p>每个用户都有自己的kown_hosts文件，它们是相互独立的。我们也可以为所有用户保存一份公共的可信赖的远程主机的公钥，这个文件通常是/etc/ssh/ssh_known_hosts。</p>
</blockquote>
<h5 id="问题：假如之前我们通过ssh登录过的一台机器的IP被绑定到其他机器上了会出现什么情况？"><a href="#问题：假如之前我们通过ssh登录过的一台机器的IP被绑定到其他机器上了会出现什么情况？" class="headerlink" title="问题：假如之前我们通过ssh登录过的一台机器的IP被绑定到其他机器上了会出现什么情况？"></a>问题：假如之前我们通过ssh登录过的一台机器的IP被绑定到其他机器上了会出现什么情况？</h5><p>当机器A接收到机器B的公钥指纹时，发现knowns_hosts文件中虽然有机器B的公钥，但是计算得出的公钥指纹与机器B发送过来的公钥指纹不一致。这肯定是不一致的，因为每台机器的密钥对都是随机生成的，几乎不可能出现重复。因此，我们会看到如下提示信息：</p>
<p><img src="https://images2015.cnblogs.com/blog/1063221/201706/1063221-20170615172106587-1711264707.png" alt="img"></p>
<p>上面的大概意思是，主机A发现主机B的公钥指纹对不上了，怀疑我们正在遭受中间人攻击（即有人在冒充主机B），并且密码验证方式和键盘交互验证方式都被禁止使用了。其实，我们自己知道是因为IP被绑定到其他机器上引起的这个问题，所以我们如果想继续登录新的主机B，<strong>只需要在.ssh/known_hosts文件中把原来保存的主机B的公钥删掉就可以了</strong>。</p>
<h3 id="3-SSH免密钥登录的实现"><a href="#3-SSH免密钥登录的实现" class="headerlink" title="3. SSH免密钥登录的实现"></a>3. SSH免密钥登录的实现</h3><h5 id="使用SSH免密钥登录的优点"><a href="#使用SSH免密钥登录的优点" class="headerlink" title="使用SSH免密钥登录的优点"></a>使用SSH免密钥登录的优点</h5><p>大家都知道，SSH免密钥登录是通过公钥认证的，用户登录时只需要提供用户名，而不需要输入密码。其实其优点不止这一个，我们来总结下：</p>
<ul>
<li>1）使用账号和密码进行登录时，由于用户无法设置空密码，因此每次登录都要输入密码。而且即使系统允许给用户设置空密码，也是十分危险的行为。而公钥认证允许用户给私钥设置空密码，同时还能保证安全性。</li>
<li>2）使用账号和密码进行登录时密码容易被人看到，且密码也容易被猜到；而公钥认证所使用的密钥不用手动输入，而且内容很长，因此安全性比较高。</li>
<li>3）使用账号和密码进行登录时，服务器上的一个账号如果想给多个人同时使用，机器密码维护工作会变得很繁琐，因为他们所有人都需要知道密码是什么，当修改密码也要通知他们每个人。而使用公钥认证只需要把它们的公钥保存在服务器上，如果要取消某个人的操作权限，只需要把这个人的公钥删掉，而不需要修改服务器密码。</li>
</ul>
<h5 id="SSH免密钥登录过程"><a href="#SSH免密钥登录过程" class="headerlink" title="SSH免密钥登录过程"></a>SSH免密钥登录过程</h5><p>其实<strong>登录的过程就是被登录端对登录用户进行“身份验证”的过程</strong>，前面是通过账号和密码来验证用户身份，因为密码应该只有该账号的拥有者才知道。而我们知道公钥加密算法中，用公钥加密的数据只能由与其配对的私钥才能解密，而私钥只有用户自己才有。那么，我们是否可以通过这种方式来验证用户身份呢？实际上SSH免密钥登录就是这样的原理。比如，我们想在主机A上以root用户以SSH免密钥的方式登录主机B，登录验证过程是这样的：</p>
<ul>
<li>1）主机A与主机B协商产生会话密钥；</li>
<li>2）主机A会向主机B发送一个登录请求（如：<code>root@192.168.1.2</code>），发送的信息包括用户名root和root的公钥指纹，且所有信息都是通过会话密钥加密过的。</li>
<li>3）主机B通过会话密钥解密主机A发送的数据得到请求登录的用户名root和root的公钥指纹，然后读取root用户家目录下的所有公钥数据（/root/.ssh/autorized_keys文件中），并分别通过单向加密算法获取各公钥的数据指纹与主机A发送过来的数据指纹做对比，从而找到主机A上的root用户的公钥；</li>
<li>4）主机B使用找到的root用户的公钥对一个随机数进行加密发送发送给主机A；</li>
<li>5）主机A使用root用户的私钥对主机B发送的随机数密文进行解密，然后把解密结果发送给主机B;</li>
<li>6）主机B验证主机A解密后的数据与自己发送的数据一致，则对root用户的身份验证成功；</li>
</ul>
<p><strong>那么主机A是怎样获取root用户的私钥的呢？主机B又是怎样获取root用户的公钥的呢？</strong> 这个就是实现SSH免密钥登录所要配置的内容：</p>
<ul>
<li>1）生成密钥对儿：在当前机器A上，可以通过<code>ssh-keygen</code>命令生成一个ssh密钥对儿，一路回车就可以；生成的密钥对儿默认保存在当前登录用户家目录下的.ssh目录，也可以指定保存目录。我们当前是以root用户登录，因此是保存在/root/.ssh目录：<br><img src="https://images2015.cnblogs.com/blog/1063221/201706/1063221-20170610122423965-60669097.png" alt="img"></li>
<li>2）我们可以把这个密钥对儿中的两个文件复制到其他用户家目录的.ssh目录下（如/home/wader/.ssh/目录），也可以复制到其他任意目录。需要说明的是一定要注意目录和文件的权限：.ssh 目录的权限必须是0700，authorized_keys 文件权限必须是0600。</li>
<li>3）当在主机A上通过 <code>ssh root@hostB</code>进行登录时，主机A会尝试读取登录用户的家目录下的私钥文件（这里是以root用户登录主机B，因此主机A会读取/root/.ssh/id_rsa文件作为私钥），也可以通过-i选项指定要使用的私钥文件；</li>
<li>4）我们需要手动把公钥的内容复制到要登录机器B的相应用户（如root）家目录下的指定文件中：/home/root/.ssh/autorized_keys；可以使用<code>ssh-copy-id root@hostB</code>命令直接完成这个操作，也可以通过复制粘贴的方式来完成；</li>
<li>5）在当前机器上就可以通过ssh私钥使用root用户登录机器B了。</li>
</ul>
<h3 id="4-ssh免密钥登录在git中的使用"><a href="#4-ssh免密钥登录在git中的使用" class="headerlink" title="4. ssh免密钥登录在git中的使用"></a>4. ssh免密钥登录在git中的使用</h3><p>我们在管理git仓库中的项目时，可以使用http/https协议，也可以使用ssh协议来管理我们的项目代码：</p>
<p>http/https协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.1.1/GROUP_OR_USER/PROJECT_NAME.git</span><br><span class="line">https://192.168.1.1/GROUP_OR_USER/PROJECT_NAME.git</span><br></pre></td></tr></table></figure>
<p>ssh协议:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh://git@192.168.1.1/GROUP_OR_USER/PROJECT_NAME.git</span><br></pre></td></tr></table></figure>
<p>无论使用http/https协议还是ssh协议来管理项目仓库，对于非公开的仓库都是需要进行登录（即账户身份验证）的。如果我们使用http/https协议的话，就需要提供用户名和密码进行验证；如果我们使用ssh协议的话，就可以把我们公钥保存到项目仓库机器的指定位置，来通过非对称加密的方式进行身份验证，验证的原理上面已经详细说明过了。</p>
<h2 id="四、HTTPS工作原理"><a href="#四、HTTPS工作原理" class="headerlink" title="四、HTTPS工作原理"></a>四、HTTPS工作原理</h2><hr>
<p>HTTPS实际上就是HTTP协议和SSL/TSL协议的组合，可以把HTTPS大致理解为“HTTP over SSL”或“HTTP over TSL”。关于它们的相关介绍，可以参考<a href="http://www.techug.com/post/https-ssl-tls.html" target="_blank" rel="noopener">这篇文章</a>。对于HTTPS我们应该有以下几个认知：</p>
<ul>
<li>1）使用HTTPS传输数据是安全的，因为数据都是被加密传输的；</li>
<li>2）使用HTTPS需要在服务器端配置密钥对；</li>
<li>3）使用HTTPS需要花钱找专业的权威机构进行CA证书的签发。</li>
</ul>
<p>那么使用HTTPS与网站服务器进行交互的流程和原理到底是怎样的呢？让我们先以逆向思考的方式来进行说明：</p>
<ul>
<li>我们说过，公钥加密/非对称加密方式虽然安全，但是由于密钥过长，加密和解密速度都远远低于对称加密。因此，出于对性能方面的考虑，HTTPS并不是把所有传输的数据都使用公钥加密的方式进行机密性的保护，而是继续使用对称加密的方式来加密数据。还有一个原因就是，使用公钥机密算法来保证数据机密性的话，需要通信双方都要有密钥对儿，否则总有一方发出的数据是能被对方公布的公钥解密的。</li>
<li>既然时使用对称加密的方式加密数据，就需要有一个通信双方都知道的加解密所使用的密钥。HTTPS是通过上面提到的密钥交换技术来动态协商这个密钥的，实际上就是由客户端生成一个随机密钥，然后发送给服务器端，这样就解决了密钥的管理问题。</li>
<li>既然说HTTPS是安全的，那么客户端生成的这个随机密钥肯定不能以明文的方式发送给服务器端啊。是的，当客户端以https的方式访问一个站点时，该站点会自动下发其公钥信息。客户端会使用这个公钥对产生的随机密钥进行加密，然后传送给服务器端。服务器端以自己的私钥对这个密文进行解密，然后得到这个密钥的明文内容。至此，客户端与服务端用于对称加密和解密的密钥协商与传输工作已经安全的完成了。</li>
<li>那么要通过网络获取服务器端的公钥信息，那么怎么验证该公钥信息的合法性呢？我们上面说过，不是所有问题都能依赖技术来解决的。这里要验证公钥信息的合法性就要依靠CA证书签发机构了，网站服务的提供者必须找一个大家都信任的机构来对他提供的公钥进行签名，用户得到一个网站下发的公钥后看到有这个机构的签名就认为这个公钥是合法的，是可信赖的。</li>
<li>那么CA机构的签名要以什么样的形式来提供呢？实际上网站服务器下发给客户端（通常是浏览器）的公钥已经不仅仅是密钥对儿中公钥的内容了，而是包含了证书签发机构写入的其他信息的CA证书。这个CA证书中包括证书签发机构的标识和公钥的数据指纹，当然还有包含网站服务提供者的公钥信息以及证书到期时间等等。但是，我们前面提到过，单向加密只能保证数据的完整性，不能保证数据机密性。CA证书的伪造者完全可以伪造公钥信息并生成相应的数据指纹，然后发送给用户。那么现在的问题就变成了要验证CA证书中公钥的合法性以及CA证书提供者的身份了。貌似问题只是转移了，而没有被解决。</li>
<li>其实每个CA证书的签发机构也都有自己的密钥对儿，他们放在CA证书中的公钥的数据指纹时通过自己的私钥加密过的，而这些CA证书签发机构的公钥是被各浏览器厂商内置在浏览器内部的。当浏览器接收到某网站服务器下发的CA证书后会根据CA证书中签发机构的标识来读取浏览器内置的相应CA签发机构的公钥信息，通过这个公钥信息对公钥数据指纹的密文进行解密就可以得到CA证书中包含的公钥信息的真实数据指纹。浏览器再通过单向加密的方式自己计算一次CA证书中包含的公钥信息的数据指纹，两个数据指纹一致则说明这个CA证书确实是该CA机构签发的，同时也证明了CA证书中的公钥信息没有被篡改过。至此，所有的问题就都解决了。</li>
</ul>
<p>现在我们再来以正常的顺序描述一下使用HTTPS与网站服务器进行交互的过程：</p>
<ul>
<li>1）浏览器A与网站服务器B通过三次握手后建立网络连接。</li>
<li>2）浏览器A告诉网站服务器B：我想跟你通过HTTPS协议进行秘密交流。</li>
<li>3）网站服务器B把包含自己公钥信息的CA证书下发给浏览器A，并告诉浏览器A这个CA证书里有我的公钥信息，你决定一个对称加密使用的秘钥串，然后通过这个公钥加密后发送给我。</li>
<li>4） 浏览器A接收到网站服务器B下发的CA证书后，对这个CA证书的及其包含的公钥信息的合法性表示怀疑。于是根据CA证书中包含的证书签发机构的标识找到自身内置的该签发机构的公钥对CA证书中公钥的数据指纹进行解密，然后再自己计算一下CA证书中公钥的数据指纹，对了一下这两个数据指纹是一致的。浏览器A放心了，知道这个CA证书是合法的，CA证书中的公钥也没有被篡改过。</li>
<li>5）然后浏览器A通过通过密钥协商技术产生了一个随机的字符串作为与网站服务器B进行秘密通信的密钥，并把这个密钥通过CA证书中包含的公钥进行加密后发送给网站服务器B。</li>
<li>6）网站服务器B接收到密文格式的密钥后，通过自己的私钥进行解密得到密钥的明文内容。</li>
<li>7）浏览器A和网站服务器B开始了秘密交流。</li>
</ul>
<h2 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h2><ul>
<li>某哥视频学习笔记</li>
<li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html</a></li>
<li><a href="http://www.techug.com/post/https-ssl-tls.html" target="_blank" rel="noopener">http://www.techug.com/post/https-ssl-tls.html</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/HTTP协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/HTTP协议/" itemprop="url">
                  HTTP协议
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 15:05:17 / 修改时间：15:57:42" itemprop="dateCreated datePublished" datetime="2018-09-17T15:05:17+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络相关/" itemprop="url" rel="index"><span itemprop="name">网络相关</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.cnblogs.com/ranyonsue/p/5984001.html" target="_blank" rel="noopener">转自 <a href="https://home.cnblogs.com/u/ranyonsue/" target="_blank" rel="noopener">ranyonsue</a></a></p>
<h2 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h2><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p>
<p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>
<p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。</p>
<p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2964446-5a35e17f298a48e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>http请求-响应模型.jpg</p>
<h2 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h2><p>1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p>
<p>2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p>
<p>3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
<p>4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。<br>5、支持B/S及C/S模式。</p>
<h2 id="HTTP之URL"><a href="#HTTP之URL" class="headerlink" title="HTTP之URL"></a>HTTP之URL</h2><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息</p>
<p>URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：</p>
<h4 id="http-www-aspxfans-com-8080-news-index-asp-boardID-5-amp-ID-24618-amp-page-1-name"><a href="#http-www-aspxfans-com-8080-news-index-asp-boardID-5-amp-ID-24618-amp-page-1-name" class="headerlink" title="http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name"></a><a href="http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name" target="_blank" rel="noopener">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</a></h4><p>从上面的URL可以看出，一个完整的URL包括以下几部分：<br>1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符</p>
<p>2.域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用</p>
<p>3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</p>
<p>4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”</p>
<p>5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</p>
<p>6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</p>
<p>7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</p>
<p>（原文：<a href="http://blog.csdn.net/ergouge/article/details/8185219" target="_blank" rel="noopener">http://blog.csdn.net/ergouge/article/details/8185219</a> ）</p>
<h2 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h2><h5 id="URI，是uniform-resource-identifier，统一资源标识符，用来唯一的标识一个资源。"><a href="#URI，是uniform-resource-identifier，统一资源标识符，用来唯一的标识一个资源。" class="headerlink" title="URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。"></a>URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。</h5><p>Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的<br>URI一般由三部组成：<br>①访问资源的命名机制<br>②存放资源的主机名<br>③资源自身的名称，由路径表示，着重强调于资源。</p>
<h5 id="URL是uniform-resource-locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。"><a href="#URL是uniform-resource-locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。" class="headerlink" title="URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。"></a>URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。</h5><p>URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。<br>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：<br>①协议(或称为服务方式)<br>②存有该资源的主机IP地址(有时也包括端口号)<br>③主机资源的具体地址。如目录和文件名等</p>
<h5 id="URN，uniform-resource-name，统一资源命名，是通过名字来标识资源，比如mailto-java-net-java-sun-com。"><a href="#URN，uniform-resource-name，统一资源命名，是通过名字来标识资源，比如mailto-java-net-java-sun-com。" class="headerlink" title="URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。"></a>URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。</h5><p>URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。</p>
<p>在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。<br>在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。<br>相反的是，URL类可以打开一个到达资源的流。</p>
<h2 id="HTTP之请求消息Request"><a href="#HTTP之请求消息Request" class="headerlink" title="HTTP之请求消息Request"></a>HTTP之请求消息Request</h2><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：</p>
<h5 id="请求行（request-line）、请求头部（header）、空行和请求数据四个部分组成。"><a href="#请求行（request-line）、请求头部（header）、空行和请求数据四个部分组成。" class="headerlink" title="请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。"></a>请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。</h5><p><img src="http://upload-images.jianshu.io/upload_images/2964446-fdfb1a8fce8de946.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>Http请求消息结构.png</p>
<ul>
<li>请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。</li>
</ul>
<h5 id="Get请求例子，使用Charles抓取的request："><a href="#Get请求例子，使用Charles抓取的request：" class="headerlink" title="Get请求例子，使用Charles抓取的request："></a>Get请求例子，使用Charles抓取的request：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /562f25980001b1b106000338.jpg HTTP/1.1</span><br><span class="line">Host    img.mukewang.com</span><br><span class="line">User-Agent    Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36</span><br><span class="line">Accept    image/webp,image/*,*/*;q=0.8</span><br><span class="line">Referer    http://www.imooc.com/</span><br><span class="line">Accept-Encoding    gzip, deflate, sdch</span><br><span class="line">Accept-Language    zh-CN,zh;q=0.8</span><br></pre></td></tr></table></figure>
<h5 id="第一部分：请求行，用来说明请求类型-要访问的资源以及所使用的HTTP版本"><a href="#第一部分：请求行，用来说明请求类型-要访问的资源以及所使用的HTTP版本" class="headerlink" title="第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本."></a>第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.</h5><p>GET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。</p>
<h5 id="第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息"><a href="#第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息" class="headerlink" title="第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息"></a>第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息</h5><p>从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等</p>
<h5 id="第三部分：空行，请求头部后面的空行是必须的"><a href="#第三部分：空行，请求头部后面的空行是必须的" class="headerlink" title="第三部分：空行，请求头部后面的空行是必须的"></a>第三部分：空行，请求头部后面的空行是必须的</h5><p>即使第四部分的请求数据为空，也必须有空行。</p>
<h5 id="第四部分：请求数据也叫主体，可以添加任意的其他数据。"><a href="#第四部分：请求数据也叫主体，可以添加任意的其他数据。" class="headerlink" title="第四部分：请求数据也叫主体，可以添加任意的其他数据。"></a>第四部分：请求数据也叫主体，可以添加任意的其他数据。</h5><p>这个例子的请求数据为空。</p>
<h5 id="POST请求例子，使用Charles抓取的request："><a href="#POST请求例子，使用Charles抓取的request：" class="headerlink" title="POST请求例子，使用Charles抓取的request："></a>POST请求例子，使用Charles抓取的request：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP1.1</span><br><span class="line">Host:www.wrox.com</span><br><span class="line">User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)</span><br><span class="line">Content-Type:application/x-www-form-urlencoded</span><br><span class="line">Content-Length:40</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line"></span><br><span class="line">name=Professional%20Ajax&amp;publisher=Wiley</span><br></pre></td></tr></table></figure>
<p>第一部分：请求行，第一行明了是post请求，以及http1.1版本。<br>第二部分：请求头部，第二行至第六行。<br>第三部分：空行，第七行的空行。<br>第四部分：请求数据，第八行。</p>
<h2 id="HTTP之响应消息Response"><a href="#HTTP之响应消息Response" class="headerlink" title="HTTP之响应消息Response"></a>HTTP之响应消息Response</h2><p>一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。</p>
<h5 id="HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。"><a href="#HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。" class="headerlink" title="HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。"></a>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</h5><p><img src="http://upload-images.jianshu.io/upload_images/2964446-1c4cab46f270d8ee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>http响应消息格式.jpg</p>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Fri, 22 May 2009 06:07:21 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">      &lt;head&gt;&lt;/head&gt;</span><br><span class="line">      &lt;body&gt;</span><br><span class="line">            &lt;!--body goes here--&gt;</span><br><span class="line">      &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h5 id="第一部分：状态行，由HTTP协议版本号，-状态码，-状态消息-三部分组成。"><a href="#第一部分：状态行，由HTTP协议版本号，-状态码，-状态消息-三部分组成。" class="headerlink" title="第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。"></a>第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</h5><p>第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）</p>
<h5 id="第二部分：消息报头，用来说明客户端要使用的一些附加信息"><a href="#第二部分：消息报头，用来说明客户端要使用的一些附加信息" class="headerlink" title="第二部分：消息报头，用来说明客户端要使用的一些附加信息"></a>第二部分：消息报头，用来说明客户端要使用的一些附加信息</h5><p>第二行和第三行为消息报头，<br>Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8</p>
<h5 id="第三部分：空行，消息报头后面的空行是必须的"><a href="#第三部分：空行，消息报头后面的空行是必须的" class="headerlink" title="第三部分：空行，消息报头后面的空行是必须的"></a>第三部分：空行，消息报头后面的空行是必须的</h5><h5 id="第四部分：响应正文，服务器返回给客户端的文本信息。"><a href="#第四部分：响应正文，服务器返回给客户端的文本信息。" class="headerlink" title="第四部分：响应正文，服务器返回给客户端的文本信息。"></a>第四部分：响应正文，服务器返回给客户端的文本信息。</h5><p>空行后面的html部分为响应正文。</p>
<h2 id="HTTP之状态码"><a href="#HTTP之状态码" class="headerlink" title="HTTP之状态码"></a>HTTP之状态码</h2><p>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p>
<h6 id="1xx：指示信息–表示请求已接收，继续处理"><a href="#1xx：指示信息–表示请求已接收，继续处理" class="headerlink" title="1xx：指示信息–表示请求已接收，继续处理"></a>1xx：指示信息–表示请求已接收，继续处理</h6><h6 id="2xx：成功–表示请求已被成功接收、理解、接受"><a href="#2xx：成功–表示请求已被成功接收、理解、接受" class="headerlink" title="2xx：成功–表示请求已被成功接收、理解、接受"></a>2xx：成功–表示请求已被成功接收、理解、接受</h6><h6 id="3xx：重定向–要完成请求必须进行更进一步的操作"><a href="#3xx：重定向–要完成请求必须进行更进一步的操作" class="headerlink" title="3xx：重定向–要完成请求必须进行更进一步的操作"></a>3xx：重定向–要完成请求必须进行更进一步的操作</h6><h6 id="4xx：客户端错误–请求有语法错误或请求无法实现"><a href="#4xx：客户端错误–请求有语法错误或请求无法实现" class="headerlink" title="4xx：客户端错误–请求有语法错误或请求无法实现"></a>4xx：客户端错误–请求有语法错误或请求无法实现</h6><h6 id="5xx：服务器端错误–服务器未能实现合法的请求"><a href="#5xx：服务器端错误–服务器未能实现合法的请求" class="headerlink" title="5xx：服务器端错误–服务器未能实现合法的请求"></a>5xx：服务器端错误–服务器未能实现合法的请求</h6><p>常见状态码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">200 OK                        //客户端请求成功</span><br><span class="line">400 Bad Request               //客户端请求有语法错误，不能被服务器所理解</span><br><span class="line">401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </span><br><span class="line">403 Forbidden                 //服务器收到请求，但是拒绝提供服务</span><br><span class="line">404 Not Found                 //请求资源不存在，eg：输入了错误的URL</span><br><span class="line">500 Internal Server Error     //服务器发生不可预期的错误</span><br><span class="line">503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</span><br></pre></td></tr></table></figure>
<p>更多状态码<a href="http://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener">http://www.runoob.com/http/http-status-codes.html</a></p>
<h2 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h2><p>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET     请求指定的页面信息，并返回实体主体。</span><br><span class="line">HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</span><br><span class="line">POST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</span><br><span class="line">PUT     从客户端向服务器传送的数据取代指定的文档的内容。</span><br><span class="line">DELETE      请求服务器删除指定的页面。</span><br><span class="line">CONNECT     HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</span><br><span class="line">OPTIONS     允许客户端查看服务器的性能。</span><br><span class="line">TRACE     回显服务器收到的请求，主要用于测试或诊断。</span><br></pre></td></tr></table></figure>
<h2 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h2><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
<p>以下是 HTTP 请求/响应的步骤：</p>
<h6 id="1、客户端连接到Web服务器"><a href="#1、客户端连接到Web服务器" class="headerlink" title="1、客户端连接到Web服务器"></a>1、客户端连接到Web服务器</h6><p>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.oakcms.cn./" target="_blank" rel="noopener">http://www.oakcms.cn。</a></p>
<h6 id="2、发送HTTP请求"><a href="#2、发送HTTP请求" class="headerlink" title="2、发送HTTP请求"></a>2、发送HTTP请求</h6><p>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p>
<h6 id="3、服务器接受请求并返回HTTP响应"><a href="#3、服务器接受请求并返回HTTP响应" class="headerlink" title="3、服务器接受请求并返回HTTP响应"></a>3、服务器接受请求并返回HTTP响应</h6><p>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p>
<h6 id="4、释放连接TCP连接"><a href="#4、释放连接TCP连接" class="headerlink" title="4、释放连接TCP连接"></a>4、释放连接<a href="http://www.jianshu.com/p/ef892323e68f" target="_blank" rel="noopener">TCP连接</a></h6><p>若connection 模式为close，则服务器主动关闭<a href="http://www.jianshu.com/p/ef892323e68f" target="_blank" rel="noopener">TCP连接</a>，客户端被动关闭连接，释放<a href="http://www.jianshu.com/p/ef892323e68f" target="_blank" rel="noopener">TCP连接</a>;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p>
<h6 id="5、客户端浏览器解析HTML内容"><a href="#5、客户端浏览器解析HTML内容" class="headerlink" title="5、客户端浏览器解析HTML内容"></a>5、客户端浏览器解析HTML内容</h6><p>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p>
<p>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p>
<p>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</p>
<p>2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立<a href="http://www.jianshu.com/p/ef892323e68f" target="_blank" rel="noopener">TCP连接</a>;</p>
<p>3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 <a href="http://www.jianshu.com/p/ef892323e68f" target="_blank" rel="noopener">TCP 三次握手</a>的第三个报文的数据发送给服务器;</p>
<p>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</p>
<p>5、释放 <a href="http://www.jianshu.com/p/ef892323e68f" target="_blank" rel="noopener">TCP连接</a>;</p>
<p>6、浏览器将该 html 文本并显示内容; 　　</p>
<h2 id="GET和POST请求的区别"><a href="#GET和POST请求的区别" class="headerlink" title="GET和POST请求的区别"></a>GET和POST请求的区别</h2><h6 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /books/?sex=man&amp;name=Professional HTTP/1.1</span><br><span class="line">Host: www.wrox.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class="line">Gecko/20050225 Firefox/1.0.1</span><br><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure>
<p>注意最后一行是空行</p>
<h6 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: www.wrox.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class="line">Gecko/20050225 Firefox/1.0.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 40</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line"></span><br><span class="line">name=Professional%20Ajax&amp;publisher=Wiley</span><br></pre></td></tr></table></figure>
<p>1、GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接；例 如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。</p>
<p>POST提交：把提交的数据放置在是HTTP包的包体中。上文示例中红色字体标明的就是实际的传输数据</p>
<h6 id="因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变"><a href="#因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变" class="headerlink" title="因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变"></a>因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变</h6><p>2、传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。</p>
<p>而在实际开发中存在的限制主要有：</p>
<p><strong>GET</strong>:特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系 统的支持。</p>
<p>因此对于GET提交时，传输数据就会受到URL长度的 限制。</p>
<p><strong>POST</strong>:由于不是通过URL传值，理论上数据不受 限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。</p>
<p>3、安全性</p>
<p>POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存；(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击</p>
<p>4、Http get,post,soap协议都是在http上运行的</p>
<p>（1）get：请求参数是作为一个key/value对的序列（查询字符串）附加到URL上的<br>查询字符串的长度受到web浏览器和web服务器的限制（如IE最多支持2048个字符），不适合传输大型数据集同时，它很不安全</p>
<p>（2）post：请求参数是在http标题的一个不同部分（名为entity body）传输的，这一部分用来传输表单信息，因此必须将Content-type设置为:application/x-www-form- urlencoded。post设计用来支持web窗体上的用户字段，其参数也是作为key/value对传输。<br>但是：它不支持复杂数据类型，因为post没有定义传输数据结构的语义和规则。</p>
<p>（3）soap：是http post的一个专用版本，遵循一种特殊的xml消息格式<br>Content-type设置为: text/xml 任何数据都可以xml化。</p>
<p>Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.</p>
<p>我们看看GET和POST的区别</p>
<ol>
<li><ol>
<li>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中.</li>
<li>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</li>
<li>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</li>
<li>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</li>
</ol>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/TCP和UDP的区别和优缺点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/TCP和UDP的区别和优缺点/" itemprop="url">
                  TCP和UDP的区别和优缺点
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 14:44:15 / 修改时间：14:58:27" itemprop="dateCreated datePublished" datetime="2018-09-17T14:44:15+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络相关/" itemprop="url" rel="index"><span itemprop="name">网络相关</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://blog.csdn.net/xiaobangkuaipao/article/details/76793702" target="_blank" rel="noopener">转自 <a href="https://blog.csdn.net/xiaobangkuaipao" target="_blank" rel="noopener">xiaobangkuaipao</a></a></p>
<h1 id="TCP与UDP区别总结："><a href="#TCP与UDP区别总结：" class="headerlink" title="TCP与UDP区别总结："></a>TCP与UDP区别总结：</h1><p>1、TCP面向连接（如打电话要先拨号建立连接）;</p>
<p>UDP是无连接的，即发送数据之前不需要建立连接</p>
<p>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</p>
<p>Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</p>
<p>3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</p>
<p>4.每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</p>
<p>5、TCP对系统资源要求较多，UDP对系统资源要求较少。</p>
<h2 id="为什么UDP有时比TCP更有优势"><a href="#为什么UDP有时比TCP更有优势" class="headerlink" title="为什么UDP有时比TCP更有优势?"></a>为什么UDP有时比TCP更有优势?</h2><p>UDP以其简单、传输快的优势，在越来越多场景下取代了TCP,如实时游戏。</p>
<p>（1）网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。</p>
<p>（2）TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。</p>
<p>采用TCP，一旦发生丢包，TCP会将后续的包缓存起来，等前面的包重传并接收到后再继续发送，延时会越来越大，基于UDP对实时性要求较为严格的情况下，采用自定义重传机制，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成影响。</p>
<p>3、UDP和TCP编程步骤也有些不同，如下：</p>
<p><strong>TCP: </strong><br>TCP编程的服务器端一般步骤是：<br>　　1、创建一个socket，用函数socket()；     SOCKET SocketListen =socket(AF_INET,SOCK_STREAM, IPPROTO_TCP);<br>　　2、设置socket属性，用函数setsockopt(); <em> 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind(); SOCKET_ERROR = bind(SocketListen,(const sockaddr</em>)&amp;addr,sizeof(addr))<br>　　4、开启监听，用函数listen()；                 SOCKET_ERROR == listen(SocketListen,2)<br>　　5、接收客户端上来的连接，用函数accept()；    SOCKET SocketWaiter = accept(SocketListen,</p>
<p>​                                                  <em>Out</em>    struct sockaddr *addr</p>
<p> <em>Inout</em>  int <em>addrlen);<br>　　6、收发数据，用函数send()和recv()，或者read()和write();<br>　　7、关闭网络连接； closesocket(SocketListen);closesocket(SocketWaiter);<br>　　8、关闭监听；<br>SOCK_STREAM这种的特点是面向连接的，即每次收发数据之前必须通过connect建立连接，而SOCK_DGRAM这种是User Datagram Protocol协议的网络通讯，它是无连接的，不可靠的。<br>TCP编程的客户端一般步骤是：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt();</em> 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选<br>　　4、设置要连接的对方的IP地址和端口等属性；<br>　　5、连接服务器，用函数connect()；<br>　　6、收发数据，用函数send()和recv()，或者read()和write();<br>　　7、关闭网络连接；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int send(</span><br><span class="line">  _In_  SOCKET s,         //向哪个socket发送，accept返回的socket。</span><br><span class="line">  _In_  const char *buf,</span><br><span class="line">  _In_  int len,</span><br><span class="line">  _In_  int flags</span><br><span class="line">);                               由于</span><br></pre></td></tr></table></figure>
<p>send(SocketClient,(const char *)&amp;fh,sizeof(fh),0);</p>
<p>recv(SocketClient,szbuf,sizeof(szbuf),0);<br><strong>UDP:</strong><br>与之对应的UDP编程步骤要简单许多，分别如下：<br>　　UDP编程的服务器端一般步骤是：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt();<em> 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();<br>　　4、循环接收数据，用函数recvfrom();<br>　　5、关闭网络连接；<br>UDP编程的客户端一般步骤是：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt();</em> 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选<br>　　4、设置对方的IP地址和端口等属性;<br>　　5、发送数据，用函数sendto();<br>　　6、关闭网络连接；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int recvfrom(</span><br><span class="line">  _In_         SOCKET s,       //绑定的socket</span><br><span class="line">  _Out_        char *buf,</span><br><span class="line">  _In_         int len,</span><br><span class="line">  _In_         int flags,</span><br><span class="line">  _Out_        struct sockaddr *from,  //用来接收对方的</span><br><span class="line">  _Inout_opt_  int *fromlen</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>int nres=</p>
<p>recvfrom</p>
<p>(pThis-&gt;m_socketListen,szBuf,sizeof(szBuf),0,(sockaddr<em>)&amp;addrClient,&amp;nSize);//0处标志位<br>sendto(m_socketListen,szBuffer,nSize,0,(const sockaddr</em>)&amp;addr,sizeof(sockaddr_in))</p>
<p>TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。</p>
<p>4、将socket设置为广播属性<br>bool optval=true;<br>setsockopt(m_socketListen,SOL_SOCKET,SO_BROADCAST,(const char *)&amp;optval,sizeof(bool));</p>
<p>5、将Socket设置为非阻塞。<br>//bool benable=true;<br>//ioctlsocket(m_socketListen,FIONBIO,(u_long*)&amp;benable);</p>
<p>6、Tcp头，20字节</p>
<p><img src="http://ovwhbnlx7.bkt.clouddn.com/20170806225229000.png" alt="20170806225229000"></p>
<p>7、UDP首部,8个字节</p>
<p><img src="http://ovwhbnlx7.bkt.clouddn.com/20170806225326602.png" alt="20170806225326602"></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Sun Lei</p>
              <p class="site-description motion-element" itemprop="description">只有用心才能看清楚·真正重要的东西·用眼睛是看不见的</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">36</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sun Lei</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.4.4</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Muse</a> v6.4.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.1"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
