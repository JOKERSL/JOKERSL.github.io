<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.1" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.1">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.4.1',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
<meta property="og:type" content="website">
<meta property="og:title" content="Man Tou Pu&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/iOS面试/index.html">
<meta property="og:site_name" content="Man Tou Pu&#39;s Blog">
<meta property="og:description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Man Tou Pu&#39;s Blog">
<meta name="twitter:description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">






  <link rel="canonical" href="http://yoursite.com/iOS面试/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Man Tou Pu's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Man Tou Pu's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">技术、生活个人博客</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/AFNetworking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/AFNetworking/" itemprop="url">
                  AFNetworking
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 16:02:02 / 修改时间：16:05:26" itemprop="dateCreated datePublished" datetime="2018-09-17T16:02:02+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/第三方源码/" itemprop="url" rel="index"><span itemprop="name">第三方源码</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[转自 <a href="https://www.jianshu.com/u/14431e509ae8" target="_blank" rel="noopener">涂耀辉</a>]（<a href="https://www.jianshu.com/p/856f0e26279d）" target="_blank" rel="noopener">https://www.jianshu.com/p/856f0e26279d）</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-2d036ecb6746df01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/850" alt="img"></p>
<h6 id="写在开头："><a href="#写在开头：" class="headerlink" title="写在开头："></a>写在开头：</h6><ul>
<li>作为一个iOS开发，也许你不知道NSUrlRequest、不知道NSUrlConnection、也不知道NSURLSession…（说不下去了…怎么会什么都不知道…）但是你一定知道AFNetworking。</li>
<li>大多数人习惯了只要是请求网络都用AF，但是你真的知道AF做了什么吗？为什么我们不用原生的NSURLSession而选择AFNetworking?</li>
<li>本文将从源码的角度去分析AF的实际作用。<br><strong>或许看完这篇文章，你心里会有一个答案。</strong></li>
</ul>
<h6 id="先从最新的AF3-x讲起吧："><a href="#先从最新的AF3-x讲起吧：" class="headerlink" title="先从最新的AF3.x讲起吧："></a>先从最新的AF3.x讲起吧：</h6><ul>
<li><p>首先，我们就一起分析一下该框架的组成。<br>将AF下载导入工程后，下面是其包结构，相对于2.x变得非常简单了：</p>
<p>​</p>
<p>​</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-27e6f4836e83d229.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>AF代码结构图.png</p>
</li>
</ul>
<p>除去Support Files，可以看到AF分为如下5个功能模块：</p>
<ul>
<li>网络通信模块(AFURLSessionManager、AFHTTPSessionManger)</li>
<li>网络状态监听模块(Reachability)</li>
<li>网络通信安全策略模块(Security)</li>
<li>网络通信信息序列化/反序列化模块(Serialization)</li>
<li>对于iOS UIKit库的扩展(UIKit)</li>
</ul>
<h6 id="其核心当然是网络通信模块AFURLSessionManager。大家都知道，AF3-x是基于NSURLSession来封装的。所以这个类围绕着NSURLSession做了一系列的封装。而其余的四个模块，均是为了配合网络通信或对已有UIKit的一个扩展工具包。"><a href="#其核心当然是网络通信模块AFURLSessionManager。大家都知道，AF3-x是基于NSURLSession来封装的。所以这个类围绕着NSURLSession做了一系列的封装。而其余的四个模块，均是为了配合网络通信或对已有UIKit的一个扩展工具包。" class="headerlink" title="其核心当然是网络通信模块AFURLSessionManager。大家都知道，AF3.x是基于NSURLSession来封装的。所以这个类围绕着NSURLSession做了一系列的封装。而其余的四个模块，均是为了配合网络通信或对已有UIKit的一个扩展工具包。"></a>其核心当然是网络通信模块AFURLSessionManager。大家都知道，AF3.x是基于NSURLSession来封装的。所以这个类围绕着NSURLSession做了一系列的封装。而其余的四个模块，均是为了配合网络通信或对已有UIKit的一个扩展工具包。</h6><p>这五个模块所对应的类的结构关系图如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-10294db19b1aedfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>AF架构图.png</p>
<p>其中AFHTTPSessionManager是继承于AFURLSessionManager的，我们一般做网络请求都是用这个类，<strong>但是它本身是没有做实事的，只是做了一些简单的封装，把请求逻辑分发给父类AFURLSessionManager或者其它类去做。</strong></p>
<h6 id="首先我们简单的写个get请求："><a href="#首先我们简单的写个get请求：" class="headerlink" title="首先我们简单的写个get请求："></a>首先我们简单的写个get请求：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc]init];</span><br><span class="line"></span><br><span class="line">[manager GET:@&quot;http://localhost&quot; parameters:nil progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class="line"> </span><br><span class="line">&#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>首先我们我们调用了初始化方法生成了一个manager，我们点进去看看初始化做了什么:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">    return [self initWithBaseURL:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithBaseURL:(NSURL *)url &#123;</span><br><span class="line">    return [self initWithBaseURL:url sessionConfiguration:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123;</span><br><span class="line">    return [self initWithBaseURL:nil sessionConfiguration:configuration];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithBaseURL:(NSURL *)url</span><br><span class="line">           sessionConfiguration:(NSURLSessionConfiguration *)configuration</span><br><span class="line">&#123;</span><br><span class="line">    self = [super initWithSessionConfiguration:configuration];</span><br><span class="line">    if (!self) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    //对传过来的BaseUrl进行处理，如果有值且最后不包含/，url加上&quot;/&quot;</span><br><span class="line">  //--经一位热心读者更正...以后注释也一定要走心啊...不能误导大家...</span><br><span class="line">    if ([[url path] length] &gt; 0 &amp;&amp; ![[url absoluteString] hasSuffix:@&quot;/&quot;]) &#123;</span><br><span class="line">        url = [url URLByAppendingPathComponent:@&quot;&quot;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self.baseURL = url;</span><br><span class="line"></span><br><span class="line">    self.requestSerializer = [AFHTTPRequestSerializer serializer];</span><br><span class="line">    self.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化都调用到<code>- (instancetype)initWithBaseURL:(NSURL *)url sessionConfiguration:(NSURLSessionConfiguration *)configuration</code>方法中来了。</li>
<li><strong>其实初始化方法都调用父类的初始化方法。</strong>父类也就是AF3.x<strong>最最核心的类AFURLSessionManager</strong>。几乎所有的类都是围绕着这个类在处理业务逻辑。</li>
<li>除此之外，方法中把baseURL存了起来，还生成了一个请求序列对象和一个响应序列对象。后面再细说这两个类是干什么用的。</li>
</ul>
<p>直接来到父类AFURLSessionManager的初始化方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">    return [self initWithSessionConfiguration:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (!self) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!configuration) &#123;</span><br><span class="line">        configuration = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line">    self.sessionConfiguration = configuration;</span><br><span class="line">    self.operationQueue = [[NSOperationQueue alloc] init];</span><br><span class="line">    //queue并发线程数设置为1</span><br><span class="line">    self.operationQueue.maxConcurrentOperationCount = 1;</span><br><span class="line">    </span><br><span class="line">    //注意代理，代理的继承，实际上NSURLSession去判断了，你实现了哪个方法会去调用，包括子代理的方法！</span><br><span class="line">    self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];</span><br><span class="line">    </span><br><span class="line">    //各种响应转码</span><br><span class="line">    self.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">    //设置默认安全策略</span><br><span class="line">    self.securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line">#if !TARGET_OS_WATCH</span><br><span class="line">    self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line">#endif</span><br><span class="line">    // 设置存储NSURL task与AFURLSessionManagerTaskDelegate的词典（重点，在AFNet中，每一个task都会被匹配一个AFURLSessionManagerTaskDelegate 来做task的delegate事件处理） ===============</span><br><span class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init];</span><br><span class="line"></span><br><span class="line">    //  设置AFURLSessionManagerTaskDelegate 词典的锁，确保词典在多线程访问时的线程安全</span><br><span class="line">    self.lock = [[NSLock alloc] init];</span><br><span class="line">    self.lock.name = AFURLSessionManagerLockName;</span><br><span class="line"></span><br><span class="line">    // 置空task关联的代理</span><br><span class="line">    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123;        </span><br><span class="line">        for (NSURLSessionDataTask *task in dataTasks) &#123;</span><br><span class="line">            [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil];</span><br><span class="line">        &#125;</span><br><span class="line">        for (NSURLSessionUploadTask *uploadTask in uploadTasks) &#123;</span><br><span class="line">            [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil];</span><br><span class="line">        &#125;</span><br><span class="line">        for (NSURLSessionDownloadTask *downloadTask in downloadTasks) &#123;</span><br><span class="line">            [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个就是最终的初始化方法了，注释应该写的很清楚，唯一需要说的就是三点：<ul>
<li><code>self.operationQueue.maxConcurrentOperationCount = 1;</code><strong>这个operationQueue就是我们代理回调的queue。这里把代理回调的线程并发数设置为1了。</strong>至于这里为什么要这么做，我们先留一个坑，等我们讲完AF2.x之后再来分析这一块。</li>
</ul>
</li>
<li>第二就是我们初始化了一些属性，其中包括<code>self.mutableTaskDelegatesKeyedByTaskIdentifier</code>，这个是用来让每一个请求task和我们自定义的AF代理来建立映射用的，其实AF对task的代理进行了一个封装，并且转发代理到AF自定义的代理，这是AF比较重要的一部分，接下来我们会具体讲这一块。</li>
<li>第三就是下面这个方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123; </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>首先说说这个方法是干什么用的：这个方法用来异步的获取当前session的所有未完成的task。其实讲道理来说在初始化中调用这个方法应该里面一个task都不会有。我们打断点去看，也确实如此，里面的数组都是空的。<br>但是想想也知道，AF大神不会把一段没用的代码放在这吧。辗转多处，终于从AF的issue中找到了结论：<a href="https://link.jianshu.com/?t=https://github.com/AFNetworking/AFNetworking/issues/3499" target="_blank" rel="noopener">github </a>。</p>
<ul>
<li>原来这是为了防止后台回来，重新初始化这个session，一些之前的后台请求任务，导致程序的crash。</li>
</ul>
<p>初始化方法到这就全部完成了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-bc2238dee34f8acd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>分割图.png</p>
<p>接着我们来看看网络请求:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)GET:(NSString *)URLString</span><br><span class="line">                   parameters:(id)parameters</span><br><span class="line">                     progress:(void (^)(NSProgress * _Nonnull))downloadProgress</span><br><span class="line">                      success:(void (^)(NSURLSessionDataTask * _Nonnull, id _Nullable))success</span><br><span class="line">                      failure:(void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure</span><br><span class="line">&#123;</span><br><span class="line">     //生成一个task</span><br><span class="line">    NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@&quot;GET&quot;</span><br><span class="line">                                                        URLString:URLString</span><br><span class="line">                                                       parameters:parameters</span><br><span class="line">                                                   uploadProgress:nil</span><br><span class="line">                                                 downloadProgress:downloadProgress</span><br><span class="line">                                                          success:success</span><br><span class="line">                                                          failure:failure];</span><br><span class="line">  </span><br><span class="line">    //开始网络请求</span><br><span class="line">    [dataTask resume];</span><br><span class="line"></span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法走到类AFHTTPSessionManager中来，调用父类，也就是我们整个AF3.x的核心类AFURLSessionManager的方法，生成了一个系统的NSURLSessionDataTask实例，并且开始网络请求。<br>我们继续往父类里看，看看这个方法到底做了什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method</span><br><span class="line">                                       URLString:(NSString *)URLString</span><br><span class="line">                                      parameters:(id)parameters</span><br><span class="line">                                  uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress</span><br><span class="line">                                downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress</span><br><span class="line">                                         success:(void (^)(NSURLSessionDataTask *, id))success</span><br><span class="line">                                         failure:(void (^)(NSURLSessionDataTask *, NSError *))failure</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    NSError *serializationError = nil;</span><br><span class="line">    </span><br><span class="line">    //把参数，还有各种东西转化为一个request</span><br><span class="line">    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];</span><br><span class="line">    </span><br><span class="line">    if (serializationError) &#123;</span><br><span class="line">        if (failure) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</span><br><span class="line">            //如果解析错误，直接返回</span><br><span class="line">            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                failure(nil, serializationError);</span><br><span class="line">            &#125;);</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    __block NSURLSessionDataTask *dataTask = nil;</span><br><span class="line">    dataTask = [self dataTaskWithRequest:request</span><br><span class="line">                          uploadProgress:uploadProgress</span><br><span class="line">                        downloadProgress:downloadProgress</span><br><span class="line">                       completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            if (failure) &#123;</span><br><span class="line">                failure(dataTask, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (success) &#123;</span><br><span class="line">                success(dataTask, responseObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个方法做了两件事：<br>1.用self.requestSerializer和各种参数去获取了一个我们最终请求网络需要的NSMutableURLRequest实例。<br>2.调用另外一个方法dataTaskWithRequest去拿到我们最终需要的NSURLSessionDataTask实例，并且在完成的回调里，调用我们传过来的成功和失败的回调。</li>
<li>注意下面这个方法，我们常用来 push pop搭配，来忽略一些编译器的警告：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</span><br><span class="line">#pragma clang diagnostic pop</span><br></pre></td></tr></table></figure>
<p>这里是用来忽略<strong>：？</strong>带来的警告，具体的各种编译器警告描述，可以参考这篇：<a href="https://link.jianshu.com/?t=http://fuckingclangwarnings.com/#semantic" target="_blank" rel="noopener">各种编译器的警告</a>。</p>
<ul>
<li>说到底这个方法还是没有做实事，我们继续到requestSerializer方法里去看，看看AF到底如何拼接成我们需要的request的：</li>
</ul>
<p>接着我们跑到AFURLRequestSerialization类中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (NSMutableURLRequest *)requestWithMethod:(NSString *)method</span><br><span class="line">                                 URLString:(NSString *)URLString</span><br><span class="line">                                parameters:(id)parameters</span><br><span class="line">                                     error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    //断言，debug模式下，如果缺少改参数，crash</span><br><span class="line">    NSParameterAssert(method);</span><br><span class="line">    NSParameterAssert(URLString);</span><br><span class="line"></span><br><span class="line">    NSURL *url = [NSURL URLWithString:URLString];</span><br><span class="line"></span><br><span class="line">    NSParameterAssert(url);</span><br><span class="line"></span><br><span class="line">    NSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url];</span><br><span class="line">    mutableRequest.HTTPMethod = method;</span><br><span class="line"></span><br><span class="line">    //将request的各种属性循环遍历</span><br><span class="line">    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">        //如果自己观察到的发生变化的属性，在这些方法里</span><br><span class="line">        if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123;</span><br><span class="line">           //把给自己设置的属性给request设置</span><br><span class="line">            [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //将传入的parameters进行编码，并添加到request中</span><br><span class="line">    mutableRequest = [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</span><br><span class="line"></span><br><span class="line">    return mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>讲一下这个方法，这个方法做了3件事：<br>1）设置request的请求类型，get,post,put…等<br>2）往request里添加一些参数设置，其中<code>AFHTTPRequestSerializerObservedKeyPaths()</code>是一个c函数，返回一个数组，我们来看看这个函数:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static NSArray * AFHTTPRequestSerializerObservedKeyPaths() &#123;</span><br><span class="line">    static NSArray *_AFHTTPRequestSerializerObservedKeyPaths = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    // 此处需要observer的keypath为allowsCellularAccess、cachePolicy、HTTPShouldHandleCookies</span><br><span class="line">    // HTTPShouldUsePipelining、networkServiceType、timeoutInterval</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        _AFHTTPRequestSerializerObservedKeyPaths = @[NSStringFromSelector(@selector(allowsCellularAccess)), NSStringFromSelector(@selector(cachePolicy)), NSStringFromSelector(@selector(HTTPShouldHandleCookies)), NSStringFromSelector(@selector(HTTPShouldUsePipelining)), NSStringFromSelector(@selector(networkServiceType)), NSStringFromSelector(@selector(timeoutInterval))];</span><br><span class="line">    &#125;);</span><br><span class="line">    //就是一个数组里装了很多方法的名字,</span><br><span class="line">    return _AFHTTPRequestSerializerObservedKeyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这个函数就是封装了一些属性的名字，这些都是NSUrlRequest的属性。<br>再来看看<code>self.mutableObservedChangedKeyPaths</code>,这个是当前类的一个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (readwrite, nonatomic, strong) NSMutableSet *mutableObservedChangedKeyPaths;</span><br></pre></td></tr></table></figure>
<p>在-init方法对这个集合进行了初始化，<strong>并且对当前类的和NSUrlRequest相关的那些属性添加了KVO监听</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//每次都会重置变化</span><br><span class="line">   self.mutableObservedChangedKeyPaths = [NSMutableSet set];</span><br><span class="line">   </span><br><span class="line">   //给这自己些方法添加观察者为自己，就是request的各种属性，set方法</span><br><span class="line">   for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">       if ([self respondsToSelector:NSSelectorFromString(keyPath)]) &#123;</span><br><span class="line">           [self addObserver:self forKeyPath:keyPath options:NSKeyValueObservingOptionNew context:AFHTTPRequestSerializerObserverContext];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>KVO触发的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-(void)observeValueForKeyPath:(NSString *)keyPath</span><br><span class="line">                      ofObject:(__unused id)object</span><br><span class="line">                        change:(NSDictionary *)change</span><br><span class="line">                       context:(void *)context</span><br><span class="line">&#123;</span><br><span class="line">    //当观察到这些set方法被调用了，而且不为Null就会添加到集合里，否则移除</span><br><span class="line">    if (context == AFHTTPRequestSerializerObserverContext) &#123;</span><br><span class="line">        if ([change[NSKeyValueChangeNewKey] isEqual:[NSNull null]]) &#123;</span><br><span class="line">            [self.mutableObservedChangedKeyPaths removeObject:keyPath];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            [self.mutableObservedChangedKeyPaths addObject:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此我们知道<code>self.mutableObservedChangedKeyPaths</code>其实就是我们自己设置的request属性值的集合。<br>接下来调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];</span><br></pre></td></tr></table></figure>
<p>用KVC的方式，把属性值都设置到我们请求的request中去。</p>
<p>3）把需要传递的参数进行编码，并且设置到request中去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//将传入的parameters进行编码，并添加到request中</span><br><span class="line">mutableRequest = [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"> - (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request</span><br><span class="line">                               withParameters:(id)parameters</span><br><span class="line">                                        error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    NSParameterAssert(request);</span><br><span class="line"></span><br><span class="line">    NSMutableURLRequest *mutableRequest = [request mutableCopy];</span><br><span class="line"></span><br><span class="line">    //从自己的head里去遍历，如果有值则设置给request的head</span><br><span class="line">    [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) &#123;</span><br><span class="line">        if (![request valueForHTTPHeaderField:field]) &#123;</span><br><span class="line">            [mutableRequest setValue:value forHTTPHeaderField:field];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    //来把各种类型的参数，array dic set转化成字符串，给request</span><br><span class="line">    NSString *query = nil;</span><br><span class="line">    if (parameters) &#123;</span><br><span class="line">        //自定义的解析方式</span><br><span class="line">        if (self.queryStringSerialization) &#123;</span><br><span class="line">            NSError *serializationError;</span><br><span class="line">            query = self.queryStringSerialization(request, parameters, &amp;serializationError);</span><br><span class="line"></span><br><span class="line">            if (serializationError) &#123;</span><br><span class="line">                if (error) &#123;</span><br><span class="line">                    *error = serializationError;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return nil;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //默认解析方式</span><br><span class="line">            switch (self.queryStringSerializationStyle) &#123;</span><br><span class="line">                case AFHTTPRequestQueryStringDefaultStyle:</span><br><span class="line">                    query = AFQueryStringFromParameters(parameters);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //最后判断该request中是否包含了GET、HEAD、DELETE（都包含在HTTPMethodsEncodingParametersInURI）。因为这几个method的quey是拼接到url后面的。而POST、PUT是把query拼接到http body中的。</span><br><span class="line">    if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</span><br><span class="line">        if (query &amp;&amp; query.length &gt; 0) &#123;</span><br><span class="line">            mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @&quot;&amp;%@&quot; : @&quot;?%@&quot;, query]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //post put请求</span><br><span class="line">        </span><br><span class="line">        // #2864: an empty string is a valid x-www-form-urlencoded payload</span><br><span class="line">        if (!query) &#123;</span><br><span class="line">            query = @&quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) &#123;</span><br><span class="line">            [mutableRequest setValue:@&quot;application/x-www-form-urlencoded&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];</span><br><span class="line">        &#125;</span><br><span class="line">        //设置请求体</span><br><span class="line">        [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法做了3件事：<br>1.从<code>self.HTTPRequestHeaders</code>中拿到设置的参数，赋值要请求的request里去<br>2.把请求网络的参数，从array dic set这些容器类型转换为字符串，具体转码方式，我们可以使用自定义的方式，也可以用AF默认的转码方式。自定义的方式没什么好说的，想怎么去解析由你自己来决定。我们可以来看看默认的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">NSString * AFQueryStringFromParameters(NSDictionary *parameters) &#123;</span><br><span class="line">    NSMutableArray *mutablePairs = [NSMutableArray array];</span><br><span class="line">    </span><br><span class="line">    //把参数给AFQueryStringPairsFromDictionary，拿到AF的一个类型的数据就一个key，value对象，在URLEncodedStringValue拼接keyValue，一个加到数组里</span><br><span class="line">    for (AFQueryStringPair *pair in AFQueryStringPairsFromDictionary(parameters)) &#123;</span><br><span class="line">        [mutablePairs addObject:[pair URLEncodedStringValue]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //拆分数组返回参数字符串</span><br><span class="line">    return [mutablePairs componentsJoinedByString:@&quot;&amp;&quot;];</span><br><span class="line">&#125;</span><br><span class="line">NSArray * AFQueryStringPairsFromDictionary(NSDictionary *dictionary) &#123;</span><br><span class="line">    //往下调用</span><br><span class="line">    return AFQueryStringPairsFromKeyAndValue(nil, dictionary);</span><br><span class="line">&#125;</span><br><span class="line">NSArray * AFQueryStringPairsFromKeyAndValue(NSString *key, id value) &#123;</span><br><span class="line">    NSMutableArray *mutableQueryStringComponents = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">    // 根据需要排列的对象的description来进行升序排列，并且selector使用的是compare:</span><br><span class="line">    // 因为对象的description返回的是NSString，所以此处compare:使用的是NSString的compare函数</span><br><span class="line">    // 即@[@&quot;foo&quot;, @&quot;bar&quot;, @&quot;bae&quot;] ----&gt; @[@&quot;bae&quot;, @&quot;bar&quot;,@&quot;foo&quot;]</span><br><span class="line">    NSSortDescriptor *sortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@&quot;description&quot; ascending:YES selector:@selector(compare:)];</span><br><span class="line"></span><br><span class="line">    //判断vaLue是什么类型的，然后去递归调用自己，直到解析的是除了array dic set以外的元素，然后把得到的参数数组返回。</span><br><span class="line">    if ([value isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">        NSDictionary *dictionary = value;</span><br><span class="line">        // Sort dictionary keys to ensure consistent ordering in query string, which is important when deserializing potentially ambiguous sequences, such as an array of dictionaries</span><br><span class="line">        </span><br><span class="line">        //拿到</span><br><span class="line">        for (id nestedKey in [dictionary.allKeys sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class="line">            id nestedValue = dictionary[nestedKey];</span><br><span class="line">            if (nestedValue) &#123;</span><br><span class="line">                [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue((key ? [NSString stringWithFormat:@&quot;%@[%@]&quot;, key, nestedKey] : nestedKey), nestedValue)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if ([value isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">        NSArray *array = value;</span><br><span class="line">        for (id nestedValue in array) &#123;</span><br><span class="line">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue([NSString stringWithFormat:@&quot;%@[]&quot;, key], nestedValue)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if ([value isKindOfClass:[NSSet class]]) &#123;</span><br><span class="line">        NSSet *set = value;</span><br><span class="line">        for (id obj in [set sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class="line">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue(key, obj)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [mutableQueryStringComponents addObject:[[AFQueryStringPair alloc] initWithField:key value:value]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return mutableQueryStringComponents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>转码主要是以上三个函数，配合着注释应该也很好理解：主要是在递归调用<code>AFQueryStringPairsFromKeyAndValue</code>。判断vaLue是什么类型的，然后去递归调用自己，直到解析的是除了array dic set以外的元素，然后把得到的参数数组返回。</li>
<li>其中有个<code>AFQueryStringPair</code>对象，其只有两个属性和两个方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@property (readwrite, nonatomic, strong) id field;</span><br><span class="line">@property (readwrite, nonatomic, strong) id value;</span><br><span class="line">   </span><br><span class="line">    - (instancetype)initWithField:(id)field value:(id)value &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (!self) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self.field = field;</span><br><span class="line">    self.value = value;</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   - (NSString *)URLEncodedStringValue &#123;</span><br><span class="line">    if (!self.value || [self.value isEqual:[NSNull null]]) &#123;</span><br><span class="line">        return AFPercentEscapedStringFromString([self.field description]);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return [NSString stringWithFormat:@&quot;%@=%@&quot;, AFPercentEscapedStringFromString([self.field description]), AFPercentEscapedStringFromString([self.value description])];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法很简单，现在我们也很容易理解这整个转码过程了，我们举个例子梳理下，就是以下这3步：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@&#123; </span><br><span class="line">     @&quot;name&quot; : @&quot;bang&quot;, </span><br><span class="line">     @&quot;phone&quot;: @&#123;@&quot;mobile&quot;: @&quot;xx&quot;, @&quot;home&quot;: @&quot;xx&quot;&#125;, </span><br><span class="line">     @&quot;families&quot;: @[@&quot;father&quot;, @&quot;mother&quot;], </span><br><span class="line">     @&quot;nums&quot;: [NSSet setWithObjects:@&quot;1&quot;, @&quot;2&quot;, nil] </span><br><span class="line">&#125; </span><br><span class="line">-&gt; </span><br><span class="line">@[ </span><br><span class="line">     field: @&quot;name&quot;, value: @&quot;bang&quot;, </span><br><span class="line">     field: @&quot;phone[mobile]&quot;, value: @&quot;xx&quot;, </span><br><span class="line">     field: @&quot;phone[home]&quot;, value: @&quot;xx&quot;, </span><br><span class="line">     field: @&quot;families[]&quot;, value: @&quot;father&quot;, </span><br><span class="line">     field: @&quot;families[]&quot;, value: @&quot;mother&quot;, </span><br><span class="line">     field: @&quot;nums&quot;, value: @&quot;1&quot;, </span><br><span class="line">     field: @&quot;nums&quot;, value: @&quot;2&quot;, </span><br><span class="line">] </span><br><span class="line">-&gt; </span><br><span class="line">name=bang&amp;phone[mobile]=xx&amp;phone[home]=xx&amp;families[]=father&amp;families[]=mother&amp;nums=1&amp;num=2</span><br></pre></td></tr></table></figure>
<p>至此，我们原来的容器类型的参数，就这样变成字符串类型了。</p>
<p>紧接着这个方法还根据该request中请求类型，来判断参数字符串应该如何设置到request中去。如果是GET、HEAD、DELETE，则把参数quey是拼接到url后面的。而POST、PUT是把query拼接到http body中的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</span><br><span class="line">    if (query &amp;&amp; query.length &gt; 0) &#123;</span><br><span class="line">        mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @&quot;&amp;%@&quot; : @&quot;?%@&quot;, query]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    //post put请求</span><br><span class="line">    </span><br><span class="line">    // #2864: an empty string is a valid x-www-form-urlencoded payload</span><br><span class="line">    if (!query) &#123;</span><br><span class="line">        query = @&quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) &#123;</span><br><span class="line">        [mutableRequest setValue:@&quot;application/x-www-form-urlencoded&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    //设置请求体</span><br><span class="line">    [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们生成了一个request。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-bc2238dee34f8acd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>分割图.png</p>
<h6 id="我们再回到AFHTTPSessionManager类中来-回到这个方法："><a href="#我们再回到AFHTTPSessionManager类中来-回到这个方法：" class="headerlink" title="我们再回到AFHTTPSessionManager类中来,回到这个方法："></a>我们再回到AFHTTPSessionManager类中来,回到这个方法：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method</span><br><span class="line">                                       URLString:(NSString *)URLString</span><br><span class="line">                                      parameters:(id)parameters</span><br><span class="line">                                  uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress</span><br><span class="line">                                downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress</span><br><span class="line">                                         success:(void (^)(NSURLSessionDataTask *, id))success</span><br><span class="line">                                         failure:(void (^)(NSURLSessionDataTask *, NSError *))failure</span><br><span class="line">&#123;</span><br><span class="line">    NSError *serializationError = nil;</span><br><span class="line">    //把参数，还有各种东西转化为一个request</span><br><span class="line">    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];</span><br><span class="line">    </span><br><span class="line">    if (serializationError) &#123;</span><br><span class="line">        if (failure) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</span><br><span class="line">            //如果解析错误，直接返回</span><br><span class="line">            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                failure(nil, serializationError);</span><br><span class="line">            &#125;);</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    __block NSURLSessionDataTask *dataTask = nil;</span><br><span class="line">    dataTask = [self dataTaskWithRequest:request</span><br><span class="line">                          uploadProgress:uploadProgress</span><br><span class="line">                        downloadProgress:downloadProgress</span><br><span class="line">                       completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            if (failure) &#123;</span><br><span class="line">                failure(dataTask, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (success) &#123;</span><br><span class="line">                success(dataTask, responseObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>绕了一圈我们又回来了。。</p>
<ul>
<li>我们继续往下看：当解析错误，我们直接调用传进来的fauler的Block失败返回了，这里有一个<code>self.completionQueue</code>,这个是我们自定义的，这个是一个GCD的Queue如果设置了那么从这个Queue中回调结果，否则从主队列回调。</li>
<li>实际上这个Queue还是挺有用的，之前还用到过。我们公司有自己的一套数据加解密的解析模式，所以我们回调回来的数据并不想是主线程，我们可以设置这个Queue,在分线程进行解析数据，然后自己再调回到主线程去刷新UI。</li>
</ul>
<p>言归正传，我们接着调用了父类的生成task的方法，并且执行了一个成功和失败的回调，我们接着去父类AFURLSessionManger里看（总算到我们的核心类了..）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</span><br><span class="line">                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    __block NSURLSessionDataTask *dataTask = nil;</span><br><span class="line">    //第一件事，创建NSURLSessionDataTask，里面适配了Ios8以下taskIdentifiers，函数创建task对象。</span><br><span class="line">    //其实现应该是因为iOS 8.0以下版本中会并发地创建多个task对象，而同步有没有做好，导致taskIdentifiers 不唯一…这边做了一个串行处理</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        dataTask = [self.session dataTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们注意到这个方法非常简单，就调用了一个<code>url_session_manager_create_task_safely()</code>函数，传了一个Block进去，Block里就是iOS原生生成dataTask的方法。此外，还调用了一个<code>addDelegateForDataTask</code>的方法。</li>
<li>我们到这先到这个函数里去看看：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static void url_session_manager_create_task_safely(dispatch_block_t block) &#123;</span><br><span class="line">    if (NSFoundationVersionNumber &lt; NSFoundationVersionNumber_With_Fixed_5871104061079552_bug) &#123;</span><br><span class="line">        // Fix of bug</span><br><span class="line">        // Open Radar:http://openradar.appspot.com/radar?id=5871104061079552 (status: Fixed in iOS8)</span><br><span class="line">        // Issue about:https://github.com/AFNetworking/AFNetworking/issues/2093</span><br><span class="line">      </span><br><span class="line">      //理解下，第一为什么用sync，因为是想要主线程等在这，等执行完，在返回，因为必须执行完dataTask才有数据，传值才有意义。</span><br><span class="line">      //第二，为什么要用串行队列，因为这块是为了防止ios8以下内部的dataTaskWithRequest是并发创建的，</span><br><span class="line">      //这样会导致taskIdentifiers这个属性值不唯一，因为后续要用taskIdentifiers来作为Key对应delegate。</span><br><span class="line">        dispatch_sync(url_session_manager_creation_queue(), block);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">static dispatch_queue_t url_session_manager_creation_queue() &#123;</span><br><span class="line">    static dispatch_queue_t af_url_session_manager_creation_queue;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    //保证了即使是在多线程的环境下，也不会创建其他队列</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        af_url_session_manager_creation_queue = dispatch_queue_create(&quot;com.alamofire.networking.session.manager.creation&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return af_url_session_manager_creation_queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法非常简单，关键是理解这么做的目的：为什么我们不直接去调用<br><code>dataTask = [self.session dataTaskWithRequest:request];</code><br>非要绕这么一圈，我们点进去bug日志里看看，<strong>原来这是为了适配iOS8的以下，创建session的时候，偶发的情况会出现session的属性taskIdentifier这个值不唯一</strong>，而这个taskIdentifier是我们后面来映射delegate的key,所以它必须是唯一的。</li>
<li><strong>具体原因应该是NSURLSession内部去生成task的时候是用多线程并发去执行的。</strong>想通了这一点，我们就很好解决了，我们只需要在iOS8以下<strong>同步串行</strong>的去生成task就可以防止这一问题发生（如果还是不理解同步串行的原因，可以看看注释）。</li>
<li>题外话：很多同学都会抱怨为什么sync我从来用不到，看，有用到的地方了吧，<strong>很多东西不是没用，而只是你想不到怎么用</strong>。</li>
</ul>
<p>我们接着看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br></pre></td></tr></table></figure>
<p>调用到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</span><br><span class="line">   </span><br><span class="line">    // AFURLSessionManagerTaskDelegate与AFURLSessionManager建立相互关系</span><br><span class="line">    delegate.manager = self;</span><br><span class="line">    delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">    //这个taskDescriptionForSessionTasks用来发送开始和挂起通知的时候会用到,就是用这个值来Post通知，来两者对应</span><br><span class="line">    dataTask.taskDescription = self.taskDescriptionForSessionTasks;</span><br><span class="line">    </span><br><span class="line">    // ***** 将AF delegate对象与 dataTask建立关系</span><br><span class="line">    [self setDelegate:delegate forTask:dataTask];</span><br><span class="line"></span><br><span class="line">    // 设置AF delegate的上传进度，下载进度块。</span><br><span class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</span><br><span class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>总结一下:<br>1）这个方法，生成了一个<code>AFURLSessionManagerTaskDelegate</code>,这个其实就是AF的自定义代理。我们请求传来的参数，都赋值给这个AF的代理了。<br>2）<code>delegate.manager = self;</code>代理把AFURLSessionManager这个类作为属性了,我们可以看到：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, weak) AFURLSessionManager *manager;</span><br></pre></td></tr></table></figure>
<p>这个属性是弱引用的，所以不会存在循环引用的问题。<br>3）我们调用了<code>[self setDelegate:delegate forTask:dataTask];</code></p>
<p>我们进去看看这个方法做了什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class="line">            forTask:(NSURLSessionTask *)task</span><br><span class="line">&#123;</span><br><span class="line">    //断言，如果没有这个参数，debug下crash在这</span><br><span class="line">    NSParameterAssert(task);</span><br><span class="line">    NSParameterAssert(delegate);</span><br><span class="line"></span><br><span class="line">    //加锁保证字典线程安全</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    // 将AF delegate放入以taskIdentifier标记的词典中（同一个NSURLSession中的taskIdentifier是唯一的）</span><br><span class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</span><br><span class="line">   </span><br><span class="line">    // 为AF delegate 设置task 的progress监听</span><br><span class="line">    [delegate setupProgressForTask:task];</span><br><span class="line">    </span><br><span class="line">    //添加task开始和暂停的通知</span><br><span class="line">    [self addNotificationObserverForTask:task];</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个方法主要就是把AF代理和task建立映射，存在了一个我们事先声明好的字典里。</li>
<li>而要加锁的原因是因为本身我们这个字典属性是mutable的，是线程不安全的。而我们对这些方法的调用，确实是会在复杂的多线程环境中，后面会仔细提到线程问题。</li>
<li>还有个<code>[delegate setupProgressForTask:task];</code>我们到方法里去看看：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">- (void)setupProgressForTask:(NSURLSessionTask *)task &#123;</span><br><span class="line">    </span><br><span class="line">    __weak __typeof__(task) weakTask = task;</span><br><span class="line"></span><br><span class="line">    //拿到上传下载期望的数据大小</span><br><span class="line">    self.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend;</span><br><span class="line">    self.downloadProgress.totalUnitCount = task.countOfBytesExpectedToReceive;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //将上传与下载进度和 任务绑定在一起，直接cancel suspend resume进度条，可以cancel...任务</span><br><span class="line">    [self.uploadProgress setCancellable:YES];</span><br><span class="line">    [self.uploadProgress setCancellationHandler:^&#123;</span><br><span class="line">        __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">        [strongTask cancel];</span><br><span class="line">    &#125;];</span><br><span class="line">    [self.uploadProgress setPausable:YES];</span><br><span class="line">    [self.uploadProgress setPausingHandler:^&#123;</span><br><span class="line">        __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">        [strongTask suspend];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    if ([self.uploadProgress respondsToSelector:@selector(setResumingHandler:)]) &#123;</span><br><span class="line">        [self.uploadProgress setResumingHandler:^&#123;</span><br><span class="line">            __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">            [strongTask resume];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [self.downloadProgress setCancellable:YES];</span><br><span class="line">    [self.downloadProgress setCancellationHandler:^&#123;</span><br><span class="line">        __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">        [strongTask cancel];</span><br><span class="line">    &#125;];</span><br><span class="line">    [self.downloadProgress setPausable:YES];</span><br><span class="line">    [self.downloadProgress setPausingHandler:^&#123;</span><br><span class="line">        __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">        [strongTask suspend];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    if ([self.downloadProgress respondsToSelector:@selector(setResumingHandler:)]) &#123;</span><br><span class="line">        [self.downloadProgress setResumingHandler:^&#123;</span><br><span class="line">            __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">            [strongTask resume];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //观察task的这些属性</span><br><span class="line">    [task addObserver:self</span><br><span class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))</span><br><span class="line">              options:NSKeyValueObservingOptionNew</span><br><span class="line">              context:NULL];</span><br><span class="line">    [task addObserver:self</span><br><span class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))</span><br><span class="line">              options:NSKeyValueObservingOptionNew</span><br><span class="line">              context:NULL];</span><br><span class="line"></span><br><span class="line">    [task addObserver:self</span><br><span class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))</span><br><span class="line">              options:NSKeyValueObservingOptionNew</span><br><span class="line">              context:NULL];</span><br><span class="line">    [task addObserver:self</span><br><span class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToSend))</span><br><span class="line">              options:NSKeyValueObservingOptionNew</span><br><span class="line">              context:NULL];</span><br><span class="line"></span><br><span class="line">    //观察progress这两个属性</span><br><span class="line">    [self.downloadProgress addObserver:self</span><br><span class="line">                            forKeyPath:NSStringFromSelector(@selector(fractionCompleted))</span><br><span class="line">                               options:NSKeyValueObservingOptionNew</span><br><span class="line">                               context:NULL];</span><br><span class="line">    [self.uploadProgress addObserver:self</span><br><span class="line">                          forKeyPath:NSStringFromSelector(@selector(fractionCompleted))</span><br><span class="line">                             options:NSKeyValueObservingOptionNew</span><br><span class="line">                             context:NULL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个方法也非常简单，主要做了以下几件事：<br>1）设置  <code>downloadProgress</code>与<code>uploadProgress</code>的一些属性，并且把两者和task的任务状态绑定在了一起。注意这两者都是NSProgress的实例对象，（这里可能又一群小伙伴楞在这了，这是个什么…）简单来说，这就是iOS7引进的一个用来管理进度的类，可以开始，暂停，取消，完整的对应了task的各种状态，当progress进行各种操作的时候，task也会引发对应操作。<br>2）给task和progress的各个属及添加KVO监听，至于监听了干什么用，我们接着往下看：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    </span><br><span class="line">    //是task</span><br><span class="line">    if ([object isKindOfClass:[NSURLSessionTask class]] || [object isKindOfClass:[NSURLSessionDownloadTask class]]) &#123;</span><br><span class="line">        //给进度条赋新值</span><br><span class="line">        if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesReceived))]) &#123;</span><br><span class="line">            self.downloadProgress.completedUnitCount = [change[NSKeyValueChangeNewKey] longLongValue];</span><br><span class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))]) &#123;</span><br><span class="line">            self.downloadProgress.totalUnitCount = [change[NSKeyValueChangeNewKey] longLongValue];</span><br><span class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesSent))]) &#123;</span><br><span class="line">            self.uploadProgress.completedUnitCount = [change[NSKeyValueChangeNewKey] longLongValue];</span><br><span class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToSend))]) &#123;</span><br><span class="line">            self.uploadProgress.totalUnitCount = [change[NSKeyValueChangeNewKey] longLongValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //上面的赋新值会触发这两个，调用block回调，用户拿到进度</span><br><span class="line">    else if ([object isEqual:self.downloadProgress]) &#123;</span><br><span class="line">        if (self.downloadProgressBlock) &#123;</span><br><span class="line">            self.downloadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ([object isEqual:self.uploadProgress]) &#123;</span><br><span class="line">        if (self.uploadProgressBlock) &#123;</span><br><span class="line">            self.uploadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法非常简单直观，主要就是如果task触发KVO,则给progress进度赋值，应为赋值了，所以会触发progress的KVO，也会调用到这里，然后去执行我们传进来的<code>downloadProgressBlock</code>和<code>uploadProgressBlock</code>。主要的作用就是为了让进度实时的传递。</li>
<li>主要是观摩一下大神的写代码的结构，这个解耦的编程思想，不愧是大神…</li>
<li>还有一点需要注意：我们之前的setProgress和这个KVO监听，都是在我们AF自定义的delegate内的，是<strong>有一个task就会有一个delegate的。所以说我们是每个task都会去监听这些属性，分别在各自的AF代理内。</strong>看到这，可能有些小伙伴会有点乱，没关系。等整个讲完之后我们还会详细的去讲捋一捋manager、task、还有AF自定义代理三者之前的对应关系。</li>
</ul>
<p>到这里我们整个对task的处理就完成了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-77ff15b37bfbeac3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>分割图.png</p>
<p>接着task就开始请求网络了，还记得我们初始化方法中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];</span><br></pre></td></tr></table></figure>
<p>我们把AFUrlSessionManager作为了所有的task的delegate。当我们请求网络的时候，这些代理开始调用了：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-5a404cc7d92fb8ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>NSUrlSession的代理.png</p>
<ul>
<li><p>AFUrlSessionManager一共实现了如上图所示这么一大堆NSUrlSession相关的代理。（小伙伴们的顺序可能不一样，楼主根据代理隶属重新排序了一下）</p>
</li>
<li><p>而只转发了其中3条到AF自定义的delegate中：</p>
<p>​</p>
<p>​</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-e6469f92ca6a550e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>AF自定义delegate.png</p>
</li>
</ul>
<p>这就是我们一开始说的，AFUrlSessionManager对这一大堆代理做了一些公共的处理，而转发到AF自定义代理的3条，则负责把每个task对应的数据回调出去。</p>
<p>又有小伙伴问了，我们设置的这个代理不是<code>NSURLSessionDelegate</code>吗？怎么能响应NSUrlSession这么多代理呢？我们点到类的声明文件中去看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@protocol NSURLSessionDelegate &lt;NSObject&gt;</span><br><span class="line">@protocol NSURLSessionTaskDelegate &lt;NSURLSessionDelegate&gt;</span><br><span class="line">@protocol NSURLSessionDataDelegate &lt;NSURLSessionTaskDelegate&gt;</span><br><span class="line">@protocol NSURLSessionDownloadDelegate &lt;NSURLSessionTaskDelegate&gt;</span><br><span class="line">@protocol NSURLSessionStreamDelegate &lt;NSURLSessionTaskDelegate&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们可以看到这些代理都是继承关系，而在<code>NSURLSession</code>实现中，只要设置了这个代理，它会去判断这些所有的代理，是否<code>respondsToSelector</code>这些代理中的方法，如果响应了就会去调用。</li>
<li>而AF还重写了<code>respondsToSelector</code>方法:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> - (BOOL)respondsToSelector:(SEL)selector &#123;</span><br><span class="line">    </span><br><span class="line">    //复写了selector的方法，这几个方法是在本类有实现的，但是如果外面的Block没赋值的话，则返回NO，相当于没有实现！</span><br><span class="line">    if (selector == @selector(URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:)) &#123;</span><br><span class="line">        return self.taskWillPerformHTTPRedirection != nil;</span><br><span class="line">    &#125; else if (selector == @selector(URLSession:dataTask:didReceiveResponse:completionHandler:)) &#123;</span><br><span class="line">        return self.dataTaskDidReceiveResponse != nil;</span><br><span class="line">    &#125; else if (selector == @selector(URLSession:dataTask:willCacheResponse:completionHandler:)) &#123;</span><br><span class="line">        return self.dataTaskWillCacheResponse != nil;</span><br><span class="line">    &#125; else if (selector == @selector(URLSessionDidFinishEventsForBackgroundURLSession:)) &#123;</span><br><span class="line">        return self.didFinishEventsForBackgroundURLSession != nil;</span><br><span class="line">    &#125;</span><br><span class="line">    return [[self class] instancesRespondToSelector:selector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样如果没实现这些我们自定义的Block也不会去回调这些代理。因为本身某些代理，只执行了这些自定义的Block，如果Block都没有赋值，那我们调用代理也没有任何意义。<br>讲到这，我们顺便看看AFUrlSessionManager的一些自定义Block：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDidBecomeInvalidBlock sessionDidBecomeInvalid;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDidReceiveAuthenticationChallengeBlock sessionDidReceiveAuthenticationChallenge;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDidFinishEventsForBackgroundURLSessionBlock didFinishEventsForBackgroundURLSession;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskWillPerformHTTPRedirectionBlock taskWillPerformHTTPRedirection;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskDidReceiveAuthenticationChallengeBlock taskDidReceiveAuthenticationChallenge;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskNeedNewBodyStreamBlock taskNeedNewBodyStream;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskDidSendBodyDataBlock taskDidSendBodyData;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskDidCompleteBlock taskDidComplete;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidReceiveResponseBlock dataTaskDidReceiveResponse;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidBecomeDownloadTaskBlock dataTaskDidBecomeDownloadTask;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidReceiveDataBlock dataTaskDidReceiveData;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDataTaskWillCacheResponseBlock dataTaskWillCacheResponse;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidWriteDataBlock downloadTaskDidWriteData;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidResumeBlock downloadTaskDidResume;</span><br></pre></td></tr></table></figure>
<p>各自对应的还有一堆这样的set方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> - (void)setSessionDidBecomeInvalidBlock:(void (^)(NSURLSession *session, NSError *error))block &#123;</span><br><span class="line">    self.sessionDidBecomeInvalid = block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法都是一样的，就不重复粘贴占篇幅了。<br>主要谈谈这个设计思路</p>
<ul>
<li>作者用@property把这个些Block属性在.m文件中声明,然后复写了set方法。</li>
<li>然后在.h中去声明这些set方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setSessionDidBecomeInvalidBlock:(nullable void (^)(NSURLSession *session, NSError *error))block;</span><br></pre></td></tr></table></figure>
<p>为什么要绕这么一大圈呢？<strong>原来这是为了我们这些用户使用起来方便，调用set方法去设置这些Block，能很清晰的看到Block的各个参数与返回值。</strong>大神的精髓的编程思想无处不体现…</p>
<p>接下来我们就讲讲这些代理方法做了什么（按照顺序来）：</p>
<h6 id="NSURLSessionDelegate"><a href="#NSURLSessionDelegate" class="headerlink" title="NSURLSessionDelegate"></a>NSURLSessionDelegate</h6><h6 id="代理1："><a href="#代理1：" class="headerlink" title="代理1："></a>代理1：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//当前这个session已经失效时，该代理方法被调用。</span><br><span class="line">/*</span><br><span class="line"> 如果你使用finishTasksAndInvalidate函数使该session失效，</span><br><span class="line"> 那么session首先会先完成最后一个task，然后再调用URLSession:didBecomeInvalidWithError:代理方法，</span><br><span class="line"> 如果你调用invalidateAndCancel方法来使session失效，那么该session会立即调用上面的代理方法。</span><br><span class="line"> */</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">didBecomeInvalidWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    if (self.sessionDidBecomeInvalid) &#123;</span><br><span class="line">        self.sessionDidBecomeInvalid(session, error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法调用时机注释写的很清楚，就调用了一下我们自定义的Block,还发了一个失效的通知，至于这个通知有什么用。很抱歉，AF没用它做任何事，只是发了…目的是用户自己可以利用这个通知做什么事吧。</li>
<li>其实AF大部分通知都是如此。当然，还有一部分通知AF还是有自己用到的，包括配合对UIKit的一些扩展来使用，后面我们会有单独篇幅展开讲讲这些UIKit的扩展类的实现。</li>
</ul>
<h6 id="代理2："><a href="#代理2：" class="headerlink" title="代理2："></a>代理2：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//2、https认证</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    //挑战处理类型为 默认</span><br><span class="line">    /*</span><br><span class="line">     NSURLSessionAuthChallengePerformDefaultHandling：默认方式处理</span><br><span class="line">     NSURLSessionAuthChallengeUseCredential：使用指定的证书</span><br><span class="line">     NSURLSessionAuthChallengeCancelAuthenticationChallenge：取消挑战</span><br><span class="line">     */</span><br><span class="line">    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">    __block NSURLCredential *credential = nil;</span><br><span class="line"></span><br><span class="line">    // sessionDidReceiveAuthenticationChallenge是自定义方法，用来如何应对服务器端的认证挑战</span><br><span class="line"></span><br><span class="line">    if (self.sessionDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 此处服务器要求客户端的接收认证挑战方法是NSURLAuthenticationMethodServerTrust</span><br><span class="line">        // 也就是说服务器端需要客户端返回一个根据认证挑战的保护空间提供的信任（即challenge.protectionSpace.serverTrust）产生的挑战证书。</span><br><span class="line">       </span><br><span class="line">        // 而这个证书就需要使用credentialForTrust:来创建一个NSURLCredential对象</span><br><span class="line">        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</span><br><span class="line">            </span><br><span class="line">            // 基于客户端的安全策略来决定是否信任该服务器，不信任的话，也就没必要响应挑战</span><br><span class="line">            if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">               </span><br><span class="line">                // 创建挑战证书（注：挑战方式为UseCredential和PerformDefaultHandling都需要新建挑战证书）</span><br><span class="line">                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">                // 确定挑战的方式</span><br><span class="line">                if (credential) &#123;</span><br><span class="line">                    //证书挑战</span><br><span class="line">                    disposition = NSURLSessionAuthChallengeUseCredential;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //默认挑战  唯一区别，下面少了这一步！</span><br><span class="line">                    disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //取消挑战</span><br><span class="line">                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //默认挑战方式</span><br><span class="line">            disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //完成挑战</span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>函数作用：<br>web服务器接收到客户端请求时，有时候需要先验证客户端是否为正常用户，再决定是够返回真实数据。这种情况称之为服务端要求客户端接收挑战（NSURLAuthenticationChallenge <em>challenge）。接收到挑战后，客户端要根据服务端传来的challenge来生成completionHandler所需的NSURLSessionAuthChallengeDisposition disposition和NSURLCredential </em>credential（disposition指定应对这个挑战的方法，而credential是客户端生成的挑战证书，注意只有challenge中认证方法为NSURLAuthenticationMethodServerTrust的时候，才需要生成挑战证书）。最后调用completionHandler回应服务器端的挑战。</li>
</ul>
</blockquote>
<ul>
<li>函数讨论：<br>该代理方法会在下面两种情况调用：</li>
</ul>
<ol>
<li>当服务器端要求客户端提供证书时或者进行NTLM认证（Windows NT LAN Manager，微软提出的WindowsNT挑战/响应验证机制）时，此方法允许你的app提供正确的挑战证书。</li>
<li>当某个session使用SSL/TLS协议，第一次和服务器端建立连接的时候，服务器会发送给iOS客户端一个证书，此方法允许你的app验证服务期端的证书链（certificate keychain）<br>注：如果你没有实现该方法，该session会调用其NSURLSessionTaskDelegate的代理方法URLSession:task:didReceiveChallenge:completionHandler: 。</li>
</ol>
<p>这里，我把官方文档对这个方法的描述翻译了一下。<br>总结一下，这个方法其实就是做https认证的。看看上面的注释，大概能看明白这个方法做认证的步骤，我们还是如果有自定义的做认证的Block，则调用我们自定义的，否则去执行默认的认证步骤，最后调用完成认证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//完成挑战 </span><br><span class="line">if (completionHandler) &#123; </span><br><span class="line">      completionHandler(disposition, credential); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="代理3："><a href="#代理3：" class="headerlink" title="代理3："></a>代理3：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//3、 当session中所有已经入队的消息被发送出去后，会调用该代理方法。</span><br><span class="line">- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session &#123;</span><br><span class="line">    if (self.didFinishEventsForBackgroundURLSession) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            self.didFinishEventsForBackgroundURLSession(session);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>官方文档翻译：</p>
<blockquote>
<p>函数讨论：</p>
</blockquote>
<ul>
<li>在iOS中，当一个后台传输任务完成或者后台传输时需要证书，而此时你的app正在后台挂起，那么你的app在后台会自动重新启动运行，并且这个app的UIApplicationDelegate会发送一个application:handleEventsForBackgroundURLSession:completionHandler:消息。该消息包含了对应后台的session的identifier，而且这个消息会导致你的app启动。你的app随后应该先存储completion handler，然后再使用相同的identifier创建一个background configuration，并根据这个background configuration创建一个新的session。这个新创建的session会自动与后台任务重新关联在一起。</li>
<li>当你的app获取了一个URLSessionDidFinishEventsForBackgroundURLSession:消息，这就意味着之前这个session中已经入队的所有消息都转发出去了，这时候再调用先前存取的completion handler是安全的，或者因为内部更新而导致调用completion handler也是安全的。</li>
</ul>
<h6 id="NSURLSessionTaskDelegate"><a href="#NSURLSessionTaskDelegate" class="headerlink" title="NSURLSessionTaskDelegate"></a>NSURLSessionTaskDelegate</h6><h6 id="代理4："><a href="#代理4：" class="headerlink" title="代理4："></a>代理4：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//被服务器重定向的时候调用</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">willPerformHTTPRedirection:(NSHTTPURLResponse *)response</span><br><span class="line">        newRequest:(NSURLRequest *)request</span><br><span class="line"> completionHandler:(void (^)(NSURLRequest *))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSURLRequest *redirectRequest = request;</span><br><span class="line"></span><br><span class="line">    // step1. 看是否有对应的user block 有的话转发出去，通过这4个参数，返回一个NSURLRequest类型参数，request转发、网络重定向.</span><br><span class="line">    if (self.taskWillPerformHTTPRedirection) &#123;</span><br><span class="line">        //用自己自定义的一个重定向的block实现，返回一个新的request。</span><br><span class="line">        redirectRequest = self.taskWillPerformHTTPRedirection(session, task, response, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        // step2. 用request重新请求</span><br><span class="line">        completionHandler(redirectRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一开始我以为这个方法是类似<code>NSURLProtocol</code>，可以在请求时自己主动的去重定向request，后来发现不是，这个方法是在服务器去重定向的时候，才会被调用。为此我写了段简单的PHP测了测：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">defined(&apos;BASEPATH&apos;) OR exit(&apos;No direct script access allowed&apos;);</span><br><span class="line"></span><br><span class="line">class Welcome extends CI_Controller &#123;</span><br><span class="line">    public function index()</span><br><span class="line">    &#123;</span><br><span class="line">        header(&quot;location: http://www.huixionghome.cn/&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>证实确实如此，当我们服务器重定向的时候，代理就被调用了，我们可以去重新定义这个重定向的request。</p>
<ul>
<li>关于这个代理还有一些需要注意的地方：</li>
</ul>
<blockquote>
<p>此方法只会在default session或者ephemeral session中调用，而在background session中，session task会自动重定向。</p>
</blockquote>
<p>这里指的模式是我们一开始Init的模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (!configuration) &#123;</span><br><span class="line">    configuration = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">&#125;</span><br><span class="line">self.sessionConfiguration = configuration;</span><br></pre></td></tr></table></figure>
<p>这个模式总共分为3种：</p>
<blockquote>
<p>对于NSURLSession对象的初始化需要使用NSURLSessionConfiguration，而NSURLSessionConfiguration有三个类工厂方法：<br>+defaultSessionConfiguration 返回一个标准的 configuration，这个配置实际上与 NSURLConnection 的网络堆栈（networking stack）是一样的，具有相同的共享 NSHTTPCookieStorage，共享 NSURLCache 和共享NSURLCredentialStorage。<br>+ephemeralSessionConfiguration 返回一个预设配置，这个配置中不会对缓存，Cookie 和证书进行持久性的存储。这对于实现像秘密浏览这种功能来说是很理想的。<br>+backgroundSessionConfiguration:(NSString *)identifier 的独特之处在于，它会创建一个后台 session。后台 session 不同于常规的，普通的 session，它甚至可以在应用程序挂起，退出或者崩溃的情况下运行上传和下载任务。初始化时指定的标识符，被用于向任何可能在进程外恢复后台传输的守护进程（daemon）提供上下文。</p>
</blockquote>
<h6 id="代理5："><a href="#代理5：" class="headerlink" title="代理5："></a>代理5：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//https认证</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">    __block NSURLCredential *credential = nil;</span><br><span class="line"></span><br><span class="line">    if (self.taskDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = self.taskDidReceiveAuthenticationChallenge(session, task, challenge, &amp;credential);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</span><br><span class="line">            if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">                disposition = NSURLSessionAuthChallengeUseCredential;</span><br><span class="line">                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>鉴于篇幅，就不去贴官方文档的翻译了，大概总结一下：<br>之前我们也有一个https认证，功能一样，执行的内容也完全一样。</li>
<li>区别在于这个是non-session-level级别的认证，而之前的是session-level级别的。</li>
<li>相对于它，多了一个参数task,然后调用我们自定义的Block会多回传这个task作为参数，这样我们就可以根据每个task去自定义我们需要的https认证方式。</li>
</ul>
<h6 id="代理6："><a href="#代理6：" class="headerlink" title="代理6："></a>代理6：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//当一个session task需要发送一个新的request body stream到服务器端的时候，调用该代理方法。</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line"> needNewBodyStream:(void (^)(NSInputStream *bodyStream))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    NSInputStream *inputStream = nil;</span><br><span class="line"></span><br><span class="line">    //有自定义的taskNeedNewBodyStream,用自定义的，不然用task里原始的stream</span><br><span class="line">    if (self.taskNeedNewBodyStream) &#123;</span><br><span class="line">        inputStream = self.taskNeedNewBodyStream(session, task);</span><br><span class="line">    &#125; else if (task.originalRequest.HTTPBodyStream &amp;&amp; [task.originalRequest.HTTPBodyStream conformsToProtocol:@protocol(NSCopying)]) &#123;</span><br><span class="line">        inputStream = [task.originalRequest.HTTPBodyStream copy];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>该代理方法会在下面两种情况被调用：<ol>
<li>如果task是由uploadTaskWithStreamedRequest:创建的，那么提供初始的request body stream时候会调用该代理方法。</li>
<li>因为认证挑战或者其他可恢复的服务器错误，而导致需要客户端重新发送一个含有body stream的request，这时候会调用该代理。</li>
</ol>
</li>
</ul>
<h6 id="代理7："><a href="#代理7：" class="headerlink" title="代理7："></a>代理7：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> //周期性地通知代理发送到服务器端数据的进度。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">   didSendBodyData:(int64_t)bytesSent</span><br><span class="line">    totalBytesSent:(int64_t)totalBytesSent</span><br><span class="line">totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend</span><br><span class="line">&#123;</span><br><span class="line">     // 如果totalUnitCount获取失败，就使用HTTP header中的Content-Length作为totalUnitCount</span><br><span class="line"></span><br><span class="line">    int64_t totalUnitCount = totalBytesExpectedToSend;</span><br><span class="line">    if(totalUnitCount == NSURLSessionTransferSizeUnknown) &#123;</span><br><span class="line">        NSString *contentLength = [task.originalRequest valueForHTTPHeaderField:@&quot;Content-Length&quot;];</span><br><span class="line">        if(contentLength) &#123;</span><br><span class="line">            totalUnitCount = (int64_t) [contentLength longLongValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (self.taskDidSendBodyData) &#123;</span><br><span class="line">        self.taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalUnitCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>就是每次发送数据给服务器，会回调这个方法，通知已经发送了多少，总共要发送多少。</li>
<li>代理方法里也就是仅仅调用了我们自定义的Block而已。</li>
</ul>
<h6 id="未完总结："><a href="#未完总结：" class="headerlink" title="未完总结："></a>未完总结：</h6><ul>
<li>其实写了这么多，还没有讲到真正重要的地方，但是因为已经接近简书最大篇幅，所以只能先在这里结个尾了。</li>
<li>如果能看到这里，说明你是个非常有耐心，非常好学，非常nice的iOS开发。楼主为你点个赞。那么相信你也不吝啬手指动一动，给本文点个喜欢…顺便关注一下楼主…毕竟写了这么多…也很辛苦…咳咳，我不小心说出心声了么？</li>
<li>最后，万一如果本文有人转载，麻烦注明出处~谢谢！</li>
</ul>
<p>后续文章:<br><a href="https://www.jianshu.com/p/f32bd79233da" target="_blank" rel="noopener">AFNetworking到底做了什么（二）?</a><br><a href="https://www.jianshu.com/p/a84237b07611" target="_blank" rel="noopener">AFNetworking之于https认证</a><br><a href="https://www.jianshu.com/p/4ffeb1ba3046" target="_blank" rel="noopener">AFNetworking之UIKit扩展与缓存实现</a><br><a href="https://www.jianshu.com/p/7ed7c0be15b4" target="_blank" rel="noopener">AFNetworking到底做了什么？(终)</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/网络数据传输安全及SSH与HTTPS工作原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/网络数据传输安全及SSH与HTTPS工作原理/" itemprop="url">
                  网络数据传输安全及SSH与HTTPS工作原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 15:24:57 / 修改时间：15:46:32" itemprop="dateCreated datePublished" datetime="2018-09-17T15:24:57+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络相关/" itemprop="url" rel="index"><span itemprop="name">网络相关</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[转自 <a href="https://home.cnblogs.com/u/yyds/" target="_blank" rel="noopener">云游道士</a>]（<a href="https://www.cnblogs.com/yyds/p/6992125.html）" target="_blank" rel="noopener">https://www.cnblogs.com/yyds/p/6992125.html）</a></p>
<h2 id="本节内容"><a href="#本节内容" class="headerlink" title="本节内容"></a>本节内容</h2><hr>
<ol>
<li>网络数据传输安全概述</li>
<li>数据加密算法分类</li>
<li>SSH工作原理</li>
<li>HTTPS工作原理</li>
<li>参考资料</li>
</ol>
<p>个人一直在努力推动git在公司内部的普及和使用，前些日子在公司内部做了一次分享课，给大家介绍了下项目发布流程相关的内容，顺便普及了一些git的相关知识。对git是什么，以及怎样配置和使用它做了一些说明。但事后，很多同事的反馈，让我意识到他们很多人都卡在ssh免密钥登录的配置上。我们常说，学习一个新的东西应该遵循3W1H法则–WAHT(是什么)，WHEN(什么时候用)，HOW（怎样用）和 WHY（为什么这样用）。我想大家应该是因为不知道为什么这样用，所以才会感到困惑。刚好，最近也在整理“使用Python相关模块进行数据加密”的文档，需要做些理论性的铺垫，所以才想写这篇文章，希望对大家有所帮助。</p>
<blockquote>
<p>另外需要说明的是，网络安全涉及很多方面的很多内容，本文只是针对网络数据传输过程中的安全性发表一下个人认识和看法。如果描述的有什么不妥之处，欢迎大家留言交流和指正。</p>
</blockquote>
<h2 id="一、网络数据传输安全概述"><a href="#一、网络数据传输安全概述" class="headerlink" title="一、网络数据传输安全概述"></a>一、网络数据传输安全概述</h2><hr>
<p>我们说的数据加密与解密通常是为了保证数据在网络传输过程中的安全性。在网络发展初期，网络的数据安全性是没有被足够的重视的。事实上，当时为了实现数据可以通过网络进行传输已经耗费了科学家大部分男细胞，因此在TCP/IP协议设计的初期，他们也实在没有太多精力去过多考虑数据在网络传输过程中可能存在的安全性问题。随着TCP/IP协议及相关技术的日渐成熟，网络数据传输技术越来越稳定，人们才慢慢开始重视这个问题，美国国家标准与技术研究院（National Institue of Standard and Technology，简称NIST）也开始制定相关的安全标准。</p>
<p>网络安全涉及到很多个方面，我们这里仅仅讨论下网络数据传输过程中可能受到的威胁，其中常见的有：</p>
<ul>
<li>数据窃听</li>
<li>数据篡改</li>
<li>身份伪装</li>
</ul>
<p>针对以上威胁，我们介绍下网络数据传输的安全性涉及的几个方面：</p>
<h3 id="1-机密性"><a href="#1-机密性" class="headerlink" title="1. 机密性"></a>1. 机密性</h3><p>机密性是指对要传输的数据进行加密和解密，防止第三方看到通信数据的明文内容。其对应的通信过程如下：</p>
<p>数据发送方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plaintext(明文) ==&gt; 转换算法 ==&gt; ciphertext(密文)</span><br></pre></td></tr></table></figure>
<p>数据接收方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ciphertext(密文) ==&gt; 转换算法 ==&gt; plaintext(明文)</span><br></pre></td></tr></table></figure>
<h3 id="2-完整性"><a href="#2-完整性" class="headerlink" title="2. 完整性"></a>2. 完整性</h3><p>数据完整性是指不允许数据在传输过程中被修改（第三方恶意篡改或电平信号造成的部分数据丢失），但是它不要求数据的机密性，也就是说允许其他人看到明文数据。我们通常通过以不可逆的算法对数据提取特征码（也叫数据指纹），通过验证特征码的一致性来判断数据是否被修改过，通信过程如下：</p>
<p>数据发送发：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plaintext(明文) ==&gt; 转换算法 ==&gt; plaintext(明文) + footprint(数据指纹A)</span><br></pre></td></tr></table></figure>
<p>数据接收方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plaintext(明文) + footprint(数据指纹A) ==&gt; 转换算法 ==&gt; footprint(数据指纹B) ==&gt; 对比数据指纹A与B是否一致</span><br></pre></td></tr></table></figure>
<h3 id="3-身份验证"><a href="#3-身份验证" class="headerlink" title="3. 身份验证"></a>3. 身份验证</h3><p>身份验证通常是指数据接收方需要确认发送数据给自己的数据是自己想要通信的那一方，防止他人冒充通信对方的身份进行通信。身份验证的大体原理是：数据发送方与数据接收方约定一种特殊的数据加解密方式，数据发送方将一个通过约定的加密方式进行加密后的数据发送给数据接收方，数据接收方如能按照约定的加密方式正确解密该数据就表示对数据发送方的身份验证成功。其对应的通信过程如下：</p>
<p>数据发送方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plaintext(明文) ==&gt; 转换算法 ==&gt; ciphertext(密文)</span><br></pre></td></tr></table></figure>
<p>数据接收方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ciphertext(密文) ==&gt; 转换算法 ==&gt; plaintext(明文)</span><br></pre></td></tr></table></figure>
<h2 id="二、数据加密算法分类"><a href="#二、数据加密算法分类" class="headerlink" title="二、数据加密算法分类"></a>二、数据加密算法分类</h2><hr>
<p>上面提到的网络数据传输所涉及到的几个方面都需要特定的转换算法来实现，常用的转换算法（数据加密/解密算法）大体上可以分为以下几类：</p>
<h3 id="1-对称加密"><a href="#1-对称加密" class="headerlink" title="1. 对称加密"></a>1. 对称加密</h3><p>对称加密是指数据加密与解密使用相同的密钥。</p>
<h5 id="主要功能："><a href="#主要功能：" class="headerlink" title="主要功能："></a>主要功能：</h5><p>通常用于保证数据的机密性。</p>
<h5 id="常用的算法实现："><a href="#常用的算法实现：" class="headerlink" title="常用的算法实现："></a>常用的算法实现：</h5><ul>
<li><strong>DES：</strong> Data Encryption Standard，秘钥长度为56位，2003年左右被破解–秘钥可以暴力破解。</li>
<li><strong>3DES：</strong> DES的改进版本。</li>
<li><strong>AES：</strong> Advanced Encryption Standard，支持的秘钥长度包括 128bits，192bits，258bits，384bits，512bits。</li>
</ul>
<blockquote>
<p>需要说明的是，秘钥长度越长，数据加密与解密的时间就越久。</p>
</blockquote>
<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><ul>
<li>加密与解密使用的密钥相同。</li>
<li>在一定程度上实现了数据的机密性，且简单、快速。</li>
<li>但是由于算法一般都是公开的，因此机密性几乎完全依赖于密钥。</li>
<li>同一发送方与不同接收方进行通信时应使用不同的密钥，防止数据被窃听或拦截后被解密。</li>
</ul>
<h5 id="存在的问题："><a href="#存在的问题：" class="headerlink" title="存在的问题："></a>存在的问题：</h5><ul>
<li>当通信对象很多时会面临众多秘钥的有效管理问题。</li>
<li>对于一个新的数据通信对象，密钥怎样进行传输的问题。</li>
</ul>
<h3 id="2-单向加密"><a href="#2-单向加密" class="headerlink" title="2. 单向加密"></a>2. 单向加密</h3><p>单向加密是指只能对明文数据进行加密，而不能解密数据。</p>
<h5 id="主要功能：-1"><a href="#主要功能：-1" class="headerlink" title="主要功能："></a>主要功能：</h5><p>通常用于保证数据的完整性。</p>
<h5 id="常用的算法实现：-1"><a href="#常用的算法实现：-1" class="headerlink" title="常用的算法实现："></a>常用的算法实现：</h5><ul>
<li><strong>MD5：</strong> 128bits</li>
<li><strong>SHA：</strong> SHA1(160bits), SHA224, SHA256, SHA384</li>
</ul>
<h5 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h5><ul>
<li>不可逆：无法根据数据指纹/特征码还原原来的数据。</li>
<li>输入相同，输出必然相同。</li>
<li>雪崩效应：输入的微小改变，将会引起结果的巨大改变。</li>
<li>定长输出：无论原始数据有多长，结果的长度是相同的。</li>
</ul>
<h5 id="存在的问题：-1"><a href="#存在的问题：-1" class="headerlink" title="存在的问题："></a>存在的问题：</h5><p>可能出现中间人攻击，中间人可以对原始内容进行修改之后重新生成数据指纹，数据接收方验证数据指纹时会发现数据是正常的。此时，数据发送方只能把生成的数据指纹进行加密后再发送给数据接收方，<strong>那么问题就又回到了加密密钥的传输和管理上。</strong></p>
<h3 id="3-公钥加密（也叫非对称加密）"><a href="#3-公钥加密（也叫非对称加密）" class="headerlink" title="3. 公钥加密（也叫非对称加密）"></a>3. 公钥加密（也叫非对称加密）</h3><p>公钥加密，也被称作非对称加密，也就是说加密和解密所使用的密钥是不同的。</p>
<h5 id="主要作用："><a href="#主要作用：" class="headerlink" title="主要作用："></a>主要作用：</h5><p>通常用于保证身份验证。</p>
<h5 id="常用的公钥加密算法有："><a href="#常用的公钥加密算法有：" class="headerlink" title="常用的公钥加密算法有："></a>常用的公钥加密算法有：</h5><ul>
<li><strong>RSA：</strong> 可以实现数字签名 和 数据加密</li>
<li><strong>DSA：</strong> 只能实现数字签名，不能实现数据加密</li>
</ul>
<h5 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h5><ul>
<li>加密与解密使用的不同的密钥。</li>
<li>实际上它所使用的密钥是一对儿，一个交公钥，一个叫私钥。这对密钥不是独立的，公钥是从私钥中提炼出来，因此私钥是很长的，968位、1024位、2048位、4096位的都有。</li>
<li>通常公钥是公开的，所有人都可以得到；私钥是不能公开的，只有自己才有。</li>
<li>用公钥机密的内容只能用与之对应的私钥才能解密，反之亦然，这个特点尤为重要。</li>
</ul>
<p>我们发现公钥加密“貌似”已经解决了密钥管理的问题–所有人只需要知道自己的那一对儿密钥即可，需要跟谁通信就去获取对方的公钥，然后通过这个公钥对数据进行加密和机密就可以了。我们可以用它来完成以下两件事情：</p>
<ul>
<li><strong>用自己的私钥加密，</strong> 可以保证身份验证，因为用你的私钥加密的数据只能用你的公开的公钥才能解密数据；但是不能保证数据的机密性，因为所有人都知道你的公钥。浏览器检查CA证书合法性时，验证CA机构的数字签名时就是通过这种方式进行的。</li>
<li><strong>用对方的公钥加密，</strong> 可以保证数据的机密性，因为只有用对方的私钥才能解密，而对方的私钥只有他一个人有。HTTPS通信时，通过密钥协商技术得到的密钥进行传输时就是通过这种方式来保证机密性的。其实用对方公钥加密也可以用于用于身份验证，验证过程是：A用B的公钥加密数据后将密文传输给B，B用自己的私钥进行解密并将明文发送回给A，A对比B返回的明文和自己加密前的明文一致则表示对B完成了身份验证，通过SSH进行免密钥登录时就是通过这种方式来完成用户身份验证的。</li>
</ul>
<blockquote>
<p>事实上，<strong>公钥加密算法很少用于数据加密，它通常只是用来做身份认证</strong>，因为它的密钥太长，加密速度太慢–公钥加密算法的速度甚至比对称加密算法的速度慢上3个数量级（1000倍）。</p>
</blockquote>
<h5 id="存在的问题：-2"><a href="#存在的问题：-2" class="headerlink" title="存在的问题："></a>存在的问题：</h5><ul>
<li>既然公钥加密通常只用于身份验证，而不是用于保证数据的机密性，也就意味着这个密钥对儿并不能完全作为加密和解密数据的秘钥来用。那么，秘钥的管理和传输问题依然存在着，这个问题到底怎样来解决呢？</li>
<li>另外还有个问题就是，如果有人伪造了一对儿密钥，把其中的公钥发送给别人怎么办？怎样验证以获取公钥的合法性呢？</li>
</ul>
<h5 id="密钥管理的解决方案："><a href="#密钥管理的解决方案：" class="headerlink" title="密钥管理的解决方案："></a>密钥管理的解决方案：</h5><p>实际上，已经存在一种专门用于秘钥交换的算法–Diffie-Hellman加密算法。该加密算法本身仅限于秘钥的交换用途，被许多商用产品用作秘钥交换技术。这种秘钥交换技术的目的在于使得两个用户安全的交换一个密钥，以便用于之后的数据对称加密。也就是说，通信双方可以通过这个技术，动态的协商生成一个用于对称加密的密钥，而不用管理很多静态的密钥，这样就解决了密钥的管理问题。</p>
<blockquote>
<p>需要说明的是，在通过秘钥交互技术动态协商生成密钥之前，通常需要先通过公钥加密算法对对方的身份进行验证。实际上，https就是这样工作的。</p>
</blockquote>
<h5 id="防止公钥被伪造的解决方案"><a href="#防止公钥被伪造的解决方案" class="headerlink" title="防止公钥被伪造的解决方案"></a>防止公钥被伪造的解决方案</h5><p>公钥实际上也是一段文本，验证公钥的合法性涉及到两个方面：</p>
<ul>
<li>1）该公钥的发布者身份是否合法</li>
<li>2）该公钥的内容是否被篡改过</li>
</ul>
<p>其实，这个已经不是靠纯技术能解决的问题了，这需要借助一些机构和人为约定来解决。常见的解决方案有两种：</p>
<ul>
<li>1）<strong>公钥的合法拥有者，通过官方渠道声明其密钥的数据指纹：</strong> 既然时官方发布的信息，那么身份的合法性是有保证的；用户在获取公钥后也生成一个数据指纹，通过对比这两个数据指纹就知道公钥内容是否被修改过；SSH的身份验证实际上就是这个原理。</li>
<li>2）<strong>通过一些权威的机构来完成这些验证：</strong> 比如https使用的证书就是由CA机构签发的，这个在后面讲https原理时再做具体介绍。</li>
</ul>
<p>我们常见的对于上面这些加密算法的经典应用就是ssh和https了，它们都是使用这些加密算法实现的网络协议。下面我们对ssh和https的工作原理进行下介绍，一方面当做上面这些加密算法的实例讲解，帮助大家了解这些算法的经典应用；另一方面，也帮助大家更深入的理解ssh和https是什么，以及它们是怎样工作的。</p>
<h2 id="三、SSH工作原理"><a href="#三、SSH工作原理" class="headerlink" title="三、SSH工作原理"></a>三、SSH工作原理</h2><hr>
<h3 id="1-SSH是什么？"><a href="#1-SSH是什么？" class="headerlink" title="1. SSH是什么？"></a>1. SSH是什么？</h3><p>简单来说，<strong>SSH就是一种网络协议，主要用于计算机之间的加密登录与数据传输</strong>，使用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ssh user@host</span><br></pre></td></tr></table></figure>
<p>表示要以user这个用户的身份登录host这台网络机器。也可以省略前面的user，这样来用<code>ssh host</code>，表示以当前本地登录的用户名登录host这台网络机器。</p>
<p>早期，人们主要是通过telnet协议进行计算机之间的登录操作，但是它有一个很严重的安全隐患就是“数据是明文传输的”，登录时传输的包括用户名和密码在内的所有信息都有可能会被恶意拦截而暴露。而SSH则是将登录信息全部加密后进行传输的，因此使用SSH进行登录时安全的，即使数据在传输过程中被截获，里面的密码已经被加密而不会泄露。</p>
<blockquote>
<p>现在SSH作为互联网安全的一个基本解决方案，已经在全世界获得推广，且目前已经成为Linux系统的标准配置。需要说明的是，SSH只是一种协议，它有多种软件实现，既有商业的，也有开源的。OpenSSH是当前使用最为广泛的一个SSH协议的开源实现。</p>
</blockquote>
<h3 id="2-SSH工作原理"><a href="#2-SSH工作原理" class="headerlink" title="2. SSH工作原理"></a>2. SSH工作原理</h3><p>其实SSH是充分利用了公钥加密/非对称机密 、对称加密 和 单向加密 来实现数据安全登录的。在使用SSH进行通信时，通信过程分为以下几个步骤：</p>
<ul>
<li>1）<strong>生成会话密钥：</strong> 这个会话密钥，不是密钥对儿中公钥或私钥，而是通过密钥协商技术生成密钥。这个密钥会被通过被登录机器的密钥对进行加密后传输，用于后续所有（通过对称加密方式进行的)加密通信。</li>
<li>2）<strong>用户身份认证（登录）：*</strong> 这个对登录者进行身份验证的过程是通过登录者的密钥对儿对数据进行加解密验证实现的，这个过程中传输的所有数据都是通过上一步生成的密钥加密过的。</li>
<li>3）<strong>数据加密通信：</strong> 后面就行基于第1步生成的密钥进行数据加密传输的通信过程了。</li>
</ul>
<p>下面来看具体解析。</p>
<h5 id="账号密码安全登录的实现"><a href="#账号密码安全登录的实现" class="headerlink" title="账号密码安全登录的实现"></a>账号密码安全登录的实现</h5><p>上面提到，SSH是通过对数据进行加密后进行传输来保证数据安全的。但是，SSH的数据加密采用的是对称加密算法，只是对称加密所使用的密钥是通过公钥加密/非对称加密实现加密后的安全传输的。另外，每台Linux机器都有自己的密钥对儿（通常放在/etc/ssh目录下），这个密钥对儿跟具体的用户无关。其工作流程是：</p>
<ul>
<li>1）在主机A上向主机B发送连接请求；</li>
<li>2）主机B在与用户建立连接后，把自己的公钥发送给主机A；</li>
<li>3）主机A通过密钥协商技术产生一个随机密钥，然后使用主机B的公钥对这个随机密钥进行加密后发送给主机B;</li>
<li>4） 主机B接收到主机A发送过来的密文形式的密钥后，通过自己的私钥进行解密，得到对称加密使用的密钥明文；至此，会话密钥已经生成完毕了；</li>
<li>5）主机A通过生成的会话密钥对账号和密码等信息进行加密然后发送给主机B；</li>
<li>6）主机B接收到加密信息后，使用会话密钥进行解密，从而得到明文的账号和密码进行账号验证；</li>
<li>7）主机B在验证账号和密码后通知主机A是否登录成功；</li>
</ul>
<p>这样即便有人结果了账号密码信息，也是密文信息，并不能知道里面是什么内容。貌似已经OK了，但是，主机A怎么验证主机B的身份呢？如果有主机C冒充主机B截获了登录请求，将自己伪造的公钥发送给主机A，怎么办？尽管信息是加密过的，通信过程也是合法的，但是通信信息都被主机C截获了，其实这就是所谓的“中间人攻击”（Man-in-the-middle attack）。其实，<strong>对主机B进行验证就是对主机B发送过来的公钥的合法性进行验证的过程。</strong></p>
<h5 id="公钥合法性验证的实现"><a href="#公钥合法性验证的实现" class="headerlink" title="公钥合法性验证的实现"></a>公钥合法性验证的实现</h5><p>上面我们提到过，验证公钥的合法性有两种方式：</p>
<ul>
<li>1）验证公钥的官方发布的公钥数据指纹</li>
<li>2）通过权威的结构进行验证</li>
</ul>
<p>SSH主要用于机器之间的安全登录，因此通常不会通过权威的机构去签发证书，它主要是通过验证数据指纹的方式来验证公钥的合法性的。公钥的合法性验证是发生在主机A接收到主机B发送的公钥之后，主机A向主机B协商产生会话密钥之前，也就是上个部分所列举的数据机密时间的第2个步骤和第3个步骤之间。具体的工作流程如下：</p>
<ul>
<li>1）上个部分所列举的数据加密实现的第1-2步；</li>
<li>2）主机A会去当前用户家目录下的.ssh/known_hosts文件中查找是否存在该机器的公钥，如果不存在，表示主机A是第一次与该主机进行通信，那么主机A会计算出该公钥的数据指纹并要求用户对该指纹进行合法性确认。就是我们经常看到的的这样子：<br><img src="https://images2015.cnblogs.com/blog/1063221/201706/1063221-20170610110552778-2137595593.png" alt="img"></li>
<li>3）用户需要把目标主机管理员公布的公钥的数据指纹与主机A计算得到的数据指纹进行比对，如果一致，则说明该公钥是合法的；如果不一致则说明不合法；</li>
<li>4）用户如果确认该公钥是合法的，则输入yes表示继续后面的连接，主机A则会把这个公钥的内容保存到当前用户家目录下的.ssh/known_hosts文件中，然后提示用户输入密码，如下图所示：<br><img src="https://images2015.cnblogs.com/blog/1063221/201706/1063221-20170610110717965-1712933521.png" alt="img">下次再登录，执行到步骤2时，主机A发现该公钥已经在.ssh/known_hosts文件中存在了，就不用要求再次确认了，而是会直接提示输出密码：<br><img src="https://images2015.cnblogs.com/blog/1063221/201706/1063221-20170610110310809-1975093095.png" alt="img"></li>
<li>5）至此，主机B的身份合法性验证就结束了。</li>
</ul>
<blockquote>
<p>每个用户都有自己的kown_hosts文件，它们是相互独立的。我们也可以为所有用户保存一份公共的可信赖的远程主机的公钥，这个文件通常是/etc/ssh/ssh_known_hosts。</p>
</blockquote>
<h5 id="问题：假如之前我们通过ssh登录过的一台机器的IP被绑定到其他机器上了会出现什么情况？"><a href="#问题：假如之前我们通过ssh登录过的一台机器的IP被绑定到其他机器上了会出现什么情况？" class="headerlink" title="问题：假如之前我们通过ssh登录过的一台机器的IP被绑定到其他机器上了会出现什么情况？"></a>问题：假如之前我们通过ssh登录过的一台机器的IP被绑定到其他机器上了会出现什么情况？</h5><p>当机器A接收到机器B的公钥指纹时，发现knowns_hosts文件中虽然有机器B的公钥，但是计算得出的公钥指纹与机器B发送过来的公钥指纹不一致。这肯定是不一致的，因为每台机器的密钥对都是随机生成的，几乎不可能出现重复。因此，我们会看到如下提示信息：</p>
<p><img src="https://images2015.cnblogs.com/blog/1063221/201706/1063221-20170615172106587-1711264707.png" alt="img"></p>
<p>上面的大概意思是，主机A发现主机B的公钥指纹对不上了，怀疑我们正在遭受中间人攻击（即有人在冒充主机B），并且密码验证方式和键盘交互验证方式都被禁止使用了。其实，我们自己知道是因为IP被绑定到其他机器上引起的这个问题，所以我们如果想继续登录新的主机B，<strong>只需要在.ssh/known_hosts文件中把原来保存的主机B的公钥删掉就可以了</strong>。</p>
<h3 id="3-SSH免密钥登录的实现"><a href="#3-SSH免密钥登录的实现" class="headerlink" title="3. SSH免密钥登录的实现"></a>3. SSH免密钥登录的实现</h3><h5 id="使用SSH免密钥登录的优点"><a href="#使用SSH免密钥登录的优点" class="headerlink" title="使用SSH免密钥登录的优点"></a>使用SSH免密钥登录的优点</h5><p>大家都知道，SSH免密钥登录是通过公钥认证的，用户登录时只需要提供用户名，而不需要输入密码。其实其优点不止这一个，我们来总结下：</p>
<ul>
<li>1）使用账号和密码进行登录时，由于用户无法设置空密码，因此每次登录都要输入密码。而且即使系统允许给用户设置空密码，也是十分危险的行为。而公钥认证允许用户给私钥设置空密码，同时还能保证安全性。</li>
<li>2）使用账号和密码进行登录时密码容易被人看到，且密码也容易被猜到；而公钥认证所使用的密钥不用手动输入，而且内容很长，因此安全性比较高。</li>
<li>3）使用账号和密码进行登录时，服务器上的一个账号如果想给多个人同时使用，机器密码维护工作会变得很繁琐，因为他们所有人都需要知道密码是什么，当修改密码也要通知他们每个人。而使用公钥认证只需要把它们的公钥保存在服务器上，如果要取消某个人的操作权限，只需要把这个人的公钥删掉，而不需要修改服务器密码。</li>
</ul>
<h5 id="SSH免密钥登录过程"><a href="#SSH免密钥登录过程" class="headerlink" title="SSH免密钥登录过程"></a>SSH免密钥登录过程</h5><p>其实<strong>登录的过程就是被登录端对登录用户进行“身份验证”的过程</strong>，前面是通过账号和密码来验证用户身份，因为密码应该只有该账号的拥有者才知道。而我们知道公钥加密算法中，用公钥加密的数据只能由与其配对的私钥才能解密，而私钥只有用户自己才有。那么，我们是否可以通过这种方式来验证用户身份呢？实际上SSH免密钥登录就是这样的原理。比如，我们想在主机A上以root用户以SSH免密钥的方式登录主机B，登录验证过程是这样的：</p>
<ul>
<li>1）主机A与主机B协商产生会话密钥；</li>
<li>2）主机A会向主机B发送一个登录请求（如：<code>root@192.168.1.2</code>），发送的信息包括用户名root和root的公钥指纹，且所有信息都是通过会话密钥加密过的。</li>
<li>3）主机B通过会话密钥解密主机A发送的数据得到请求登录的用户名root和root的公钥指纹，然后读取root用户家目录下的所有公钥数据（/root/.ssh/autorized_keys文件中），并分别通过单向加密算法获取各公钥的数据指纹与主机A发送过来的数据指纹做对比，从而找到主机A上的root用户的公钥；</li>
<li>4）主机B使用找到的root用户的公钥对一个随机数进行加密发送发送给主机A；</li>
<li>5）主机A使用root用户的私钥对主机B发送的随机数密文进行解密，然后把解密结果发送给主机B;</li>
<li>6）主机B验证主机A解密后的数据与自己发送的数据一致，则对root用户的身份验证成功；</li>
</ul>
<p><strong>那么主机A是怎样获取root用户的私钥的呢？主机B又是怎样获取root用户的公钥的呢？</strong> 这个就是实现SSH免密钥登录所要配置的内容：</p>
<ul>
<li>1）生成密钥对儿：在当前机器A上，可以通过<code>ssh-keygen</code>命令生成一个ssh密钥对儿，一路回车就可以；生成的密钥对儿默认保存在当前登录用户家目录下的.ssh目录，也可以指定保存目录。我们当前是以root用户登录，因此是保存在/root/.ssh目录：<br><img src="https://images2015.cnblogs.com/blog/1063221/201706/1063221-20170610122423965-60669097.png" alt="img"></li>
<li>2）我们可以把这个密钥对儿中的两个文件复制到其他用户家目录的.ssh目录下（如/home/wader/.ssh/目录），也可以复制到其他任意目录。需要说明的是一定要注意目录和文件的权限：.ssh 目录的权限必须是0700，authorized_keys 文件权限必须是0600。</li>
<li>3）当在主机A上通过 <code>ssh root@hostB</code>进行登录时，主机A会尝试读取登录用户的家目录下的私钥文件（这里是以root用户登录主机B，因此主机A会读取/root/.ssh/id_rsa文件作为私钥），也可以通过-i选项指定要使用的私钥文件；</li>
<li>4）我们需要手动把公钥的内容复制到要登录机器B的相应用户（如root）家目录下的指定文件中：/home/root/.ssh/autorized_keys；可以使用<code>ssh-copy-id root@hostB</code>命令直接完成这个操作，也可以通过复制粘贴的方式来完成；</li>
<li>5）在当前机器上就可以通过ssh私钥使用root用户登录机器B了。</li>
</ul>
<h3 id="4-ssh免密钥登录在git中的使用"><a href="#4-ssh免密钥登录在git中的使用" class="headerlink" title="4. ssh免密钥登录在git中的使用"></a>4. ssh免密钥登录在git中的使用</h3><p>我们在管理git仓库中的项目时，可以使用http/https协议，也可以使用ssh协议来管理我们的项目代码：</p>
<p>http/https协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.1.1/GROUP_OR_USER/PROJECT_NAME.git</span><br><span class="line">https://192.168.1.1/GROUP_OR_USER/PROJECT_NAME.git</span><br></pre></td></tr></table></figure>
<p>ssh协议:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh://git@192.168.1.1/GROUP_OR_USER/PROJECT_NAME.git</span><br></pre></td></tr></table></figure>
<p>无论使用http/https协议还是ssh协议来管理项目仓库，对于非公开的仓库都是需要进行登录（即账户身份验证）的。如果我们使用http/https协议的话，就需要提供用户名和密码进行验证；如果我们使用ssh协议的话，就可以把我们公钥保存到项目仓库机器的指定位置，来通过非对称加密的方式进行身份验证，验证的原理上面已经详细说明过了。</p>
<h2 id="四、HTTPS工作原理"><a href="#四、HTTPS工作原理" class="headerlink" title="四、HTTPS工作原理"></a>四、HTTPS工作原理</h2><hr>
<p>HTTPS实际上就是HTTP协议和SSL/TSL协议的组合，可以把HTTPS大致理解为“HTTP over SSL”或“HTTP over TSL”。关于它们的相关介绍，可以参考<a href="http://www.techug.com/post/https-ssl-tls.html" target="_blank" rel="noopener">这篇文章</a>。对于HTTPS我们应该有以下几个认知：</p>
<ul>
<li>1）使用HTTPS传输数据是安全的，因为数据都是被加密传输的；</li>
<li>2）使用HTTPS需要在服务器端配置密钥对；</li>
<li>3）使用HTTPS需要花钱找专业的权威机构进行CA证书的签发。</li>
</ul>
<p>那么使用HTTPS与网站服务器进行交互的流程和原理到底是怎样的呢？让我们先以逆向思考的方式来进行说明：</p>
<ul>
<li>我们说过，公钥加密/非对称加密方式虽然安全，但是由于密钥过长，加密和解密速度都远远低于对称加密。因此，出于对性能方面的考虑，HTTPS并不是把所有传输的数据都使用公钥加密的方式进行机密性的保护，而是继续使用对称加密的方式来加密数据。还有一个原因就是，使用公钥机密算法来保证数据机密性的话，需要通信双方都要有密钥对儿，否则总有一方发出的数据是能被对方公布的公钥解密的。</li>
<li>既然时使用对称加密的方式加密数据，就需要有一个通信双方都知道的加解密所使用的密钥。HTTPS是通过上面提到的密钥交换技术来动态协商这个密钥的，实际上就是由客户端生成一个随机密钥，然后发送给服务器端，这样就解决了密钥的管理问题。</li>
<li>既然说HTTPS是安全的，那么客户端生成的这个随机密钥肯定不能以明文的方式发送给服务器端啊。是的，当客户端以https的方式访问一个站点时，该站点会自动下发其公钥信息。客户端会使用这个公钥对产生的随机密钥进行加密，然后传送给服务器端。服务器端以自己的私钥对这个密文进行解密，然后得到这个密钥的明文内容。至此，客户端与服务端用于对称加密和解密的密钥协商与传输工作已经安全的完成了。</li>
<li>那么要通过网络获取服务器端的公钥信息，那么怎么验证该公钥信息的合法性呢？我们上面说过，不是所有问题都能依赖技术来解决的。这里要验证公钥信息的合法性就要依靠CA证书签发机构了，网站服务的提供者必须找一个大家都信任的机构来对他提供的公钥进行签名，用户得到一个网站下发的公钥后看到有这个机构的签名就认为这个公钥是合法的，是可信赖的。</li>
<li>那么CA机构的签名要以什么样的形式来提供呢？实际上网站服务器下发给客户端（通常是浏览器）的公钥已经不仅仅是密钥对儿中公钥的内容了，而是包含了证书签发机构写入的其他信息的CA证书。这个CA证书中包括证书签发机构的标识和公钥的数据指纹，当然还有包含网站服务提供者的公钥信息以及证书到期时间等等。但是，我们前面提到过，单向加密只能保证数据的完整性，不能保证数据机密性。CA证书的伪造者完全可以伪造公钥信息并生成相应的数据指纹，然后发送给用户。那么现在的问题就变成了要验证CA证书中公钥的合法性以及CA证书提供者的身份了。貌似问题只是转移了，而没有被解决。</li>
<li>其实每个CA证书的签发机构也都有自己的密钥对儿，他们放在CA证书中的公钥的数据指纹时通过自己的私钥加密过的，而这些CA证书签发机构的公钥是被各浏览器厂商内置在浏览器内部的。当浏览器接收到某网站服务器下发的CA证书后会根据CA证书中签发机构的标识来读取浏览器内置的相应CA签发机构的公钥信息，通过这个公钥信息对公钥数据指纹的密文进行解密就可以得到CA证书中包含的公钥信息的真实数据指纹。浏览器再通过单向加密的方式自己计算一次CA证书中包含的公钥信息的数据指纹，两个数据指纹一致则说明这个CA证书确实是该CA机构签发的，同时也证明了CA证书中的公钥信息没有被篡改过。至此，所有的问题就都解决了。</li>
</ul>
<p>现在我们再来以正常的顺序描述一下使用HTTPS与网站服务器进行交互的过程：</p>
<ul>
<li>1）浏览器A与网站服务器B通过三次握手后建立网络连接。</li>
<li>2）浏览器A告诉网站服务器B：我想跟你通过HTTPS协议进行秘密交流。</li>
<li>3）网站服务器B把包含自己公钥信息的CA证书下发给浏览器A，并告诉浏览器A这个CA证书里有我的公钥信息，你决定一个对称加密使用的秘钥串，然后通过这个公钥加密后发送给我。</li>
<li>4） 浏览器A接收到网站服务器B下发的CA证书后，对这个CA证书的及其包含的公钥信息的合法性表示怀疑。于是根据CA证书中包含的证书签发机构的标识找到自身内置的该签发机构的公钥对CA证书中公钥的数据指纹进行解密，然后再自己计算一下CA证书中公钥的数据指纹，对了一下这两个数据指纹是一致的。浏览器A放心了，知道这个CA证书是合法的，CA证书中的公钥也没有被篡改过。</li>
<li>5）然后浏览器A通过通过密钥协商技术产生了一个随机的字符串作为与网站服务器B进行秘密通信的密钥，并把这个密钥通过CA证书中包含的公钥进行加密后发送给网站服务器B。</li>
<li>6）网站服务器B接收到密文格式的密钥后，通过自己的私钥进行解密得到密钥的明文内容。</li>
<li>7）浏览器A和网站服务器B开始了秘密交流。</li>
</ul>
<h2 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h2><ul>
<li>某哥视频学习笔记</li>
<li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html</a></li>
<li><a href="http://www.techug.com/post/https-ssl-tls.html" target="_blank" rel="noopener">http://www.techug.com/post/https-ssl-tls.html</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/HTTP协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/HTTP协议/" itemprop="url">
                  HTTP协议
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 15:05:17 / 修改时间：15:57:42" itemprop="dateCreated datePublished" datetime="2018-09-17T15:05:17+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络相关/" itemprop="url" rel="index"><span itemprop="name">网络相关</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.cnblogs.com/ranyonsue/p/5984001.html" target="_blank" rel="noopener">转自 <a href="https://home.cnblogs.com/u/ranyonsue/" target="_blank" rel="noopener">ranyonsue</a></a></p>
<h2 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h2><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p>
<p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>
<p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。</p>
<p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2964446-5a35e17f298a48e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>http请求-响应模型.jpg</p>
<h2 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h2><p>1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p>
<p>2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p>
<p>3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
<p>4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。<br>5、支持B/S及C/S模式。</p>
<h2 id="HTTP之URL"><a href="#HTTP之URL" class="headerlink" title="HTTP之URL"></a>HTTP之URL</h2><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息</p>
<p>URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：</p>
<h4 id="http-www-aspxfans-com-8080-news-index-asp-boardID-5-amp-ID-24618-amp-page-1-name"><a href="#http-www-aspxfans-com-8080-news-index-asp-boardID-5-amp-ID-24618-amp-page-1-name" class="headerlink" title="http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name"></a><a href="http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name" target="_blank" rel="noopener">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</a></h4><p>从上面的URL可以看出，一个完整的URL包括以下几部分：<br>1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符</p>
<p>2.域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用</p>
<p>3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</p>
<p>4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”</p>
<p>5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</p>
<p>6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</p>
<p>7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</p>
<p>（原文：<a href="http://blog.csdn.net/ergouge/article/details/8185219" target="_blank" rel="noopener">http://blog.csdn.net/ergouge/article/details/8185219</a> ）</p>
<h2 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h2><h5 id="URI，是uniform-resource-identifier，统一资源标识符，用来唯一的标识一个资源。"><a href="#URI，是uniform-resource-identifier，统一资源标识符，用来唯一的标识一个资源。" class="headerlink" title="URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。"></a>URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。</h5><p>Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的<br>URI一般由三部组成：<br>①访问资源的命名机制<br>②存放资源的主机名<br>③资源自身的名称，由路径表示，着重强调于资源。</p>
<h5 id="URL是uniform-resource-locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。"><a href="#URL是uniform-resource-locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。" class="headerlink" title="URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。"></a>URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。</h5><p>URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。<br>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：<br>①协议(或称为服务方式)<br>②存有该资源的主机IP地址(有时也包括端口号)<br>③主机资源的具体地址。如目录和文件名等</p>
<h5 id="URN，uniform-resource-name，统一资源命名，是通过名字来标识资源，比如mailto-java-net-java-sun-com。"><a href="#URN，uniform-resource-name，统一资源命名，是通过名字来标识资源，比如mailto-java-net-java-sun-com。" class="headerlink" title="URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。"></a>URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。</h5><p>URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。</p>
<p>在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。<br>在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。<br>相反的是，URL类可以打开一个到达资源的流。</p>
<h2 id="HTTP之请求消息Request"><a href="#HTTP之请求消息Request" class="headerlink" title="HTTP之请求消息Request"></a>HTTP之请求消息Request</h2><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：</p>
<h5 id="请求行（request-line）、请求头部（header）、空行和请求数据四个部分组成。"><a href="#请求行（request-line）、请求头部（header）、空行和请求数据四个部分组成。" class="headerlink" title="请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。"></a>请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。</h5><p><img src="http://upload-images.jianshu.io/upload_images/2964446-fdfb1a8fce8de946.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>Http请求消息结构.png</p>
<ul>
<li>请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。</li>
</ul>
<h5 id="Get请求例子，使用Charles抓取的request："><a href="#Get请求例子，使用Charles抓取的request：" class="headerlink" title="Get请求例子，使用Charles抓取的request："></a>Get请求例子，使用Charles抓取的request：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /562f25980001b1b106000338.jpg HTTP/1.1</span><br><span class="line">Host    img.mukewang.com</span><br><span class="line">User-Agent    Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36</span><br><span class="line">Accept    image/webp,image/*,*/*;q=0.8</span><br><span class="line">Referer    http://www.imooc.com/</span><br><span class="line">Accept-Encoding    gzip, deflate, sdch</span><br><span class="line">Accept-Language    zh-CN,zh;q=0.8</span><br></pre></td></tr></table></figure>
<h5 id="第一部分：请求行，用来说明请求类型-要访问的资源以及所使用的HTTP版本"><a href="#第一部分：请求行，用来说明请求类型-要访问的资源以及所使用的HTTP版本" class="headerlink" title="第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本."></a>第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.</h5><p>GET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。</p>
<h5 id="第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息"><a href="#第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息" class="headerlink" title="第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息"></a>第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息</h5><p>从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等</p>
<h5 id="第三部分：空行，请求头部后面的空行是必须的"><a href="#第三部分：空行，请求头部后面的空行是必须的" class="headerlink" title="第三部分：空行，请求头部后面的空行是必须的"></a>第三部分：空行，请求头部后面的空行是必须的</h5><p>即使第四部分的请求数据为空，也必须有空行。</p>
<h5 id="第四部分：请求数据也叫主体，可以添加任意的其他数据。"><a href="#第四部分：请求数据也叫主体，可以添加任意的其他数据。" class="headerlink" title="第四部分：请求数据也叫主体，可以添加任意的其他数据。"></a>第四部分：请求数据也叫主体，可以添加任意的其他数据。</h5><p>这个例子的请求数据为空。</p>
<h5 id="POST请求例子，使用Charles抓取的request："><a href="#POST请求例子，使用Charles抓取的request：" class="headerlink" title="POST请求例子，使用Charles抓取的request："></a>POST请求例子，使用Charles抓取的request：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP1.1</span><br><span class="line">Host:www.wrox.com</span><br><span class="line">User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)</span><br><span class="line">Content-Type:application/x-www-form-urlencoded</span><br><span class="line">Content-Length:40</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line"></span><br><span class="line">name=Professional%20Ajax&amp;publisher=Wiley</span><br></pre></td></tr></table></figure>
<p>第一部分：请求行，第一行明了是post请求，以及http1.1版本。<br>第二部分：请求头部，第二行至第六行。<br>第三部分：空行，第七行的空行。<br>第四部分：请求数据，第八行。</p>
<h2 id="HTTP之响应消息Response"><a href="#HTTP之响应消息Response" class="headerlink" title="HTTP之响应消息Response"></a>HTTP之响应消息Response</h2><p>一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。</p>
<h5 id="HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。"><a href="#HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。" class="headerlink" title="HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。"></a>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</h5><p><img src="http://upload-images.jianshu.io/upload_images/2964446-1c4cab46f270d8ee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>http响应消息格式.jpg</p>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Fri, 22 May 2009 06:07:21 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">      &lt;head&gt;&lt;/head&gt;</span><br><span class="line">      &lt;body&gt;</span><br><span class="line">            &lt;!--body goes here--&gt;</span><br><span class="line">      &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h5 id="第一部分：状态行，由HTTP协议版本号，-状态码，-状态消息-三部分组成。"><a href="#第一部分：状态行，由HTTP协议版本号，-状态码，-状态消息-三部分组成。" class="headerlink" title="第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。"></a>第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</h5><p>第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）</p>
<h5 id="第二部分：消息报头，用来说明客户端要使用的一些附加信息"><a href="#第二部分：消息报头，用来说明客户端要使用的一些附加信息" class="headerlink" title="第二部分：消息报头，用来说明客户端要使用的一些附加信息"></a>第二部分：消息报头，用来说明客户端要使用的一些附加信息</h5><p>第二行和第三行为消息报头，<br>Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8</p>
<h5 id="第三部分：空行，消息报头后面的空行是必须的"><a href="#第三部分：空行，消息报头后面的空行是必须的" class="headerlink" title="第三部分：空行，消息报头后面的空行是必须的"></a>第三部分：空行，消息报头后面的空行是必须的</h5><h5 id="第四部分：响应正文，服务器返回给客户端的文本信息。"><a href="#第四部分：响应正文，服务器返回给客户端的文本信息。" class="headerlink" title="第四部分：响应正文，服务器返回给客户端的文本信息。"></a>第四部分：响应正文，服务器返回给客户端的文本信息。</h5><p>空行后面的html部分为响应正文。</p>
<h2 id="HTTP之状态码"><a href="#HTTP之状态码" class="headerlink" title="HTTP之状态码"></a>HTTP之状态码</h2><p>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p>
<h6 id="1xx：指示信息–表示请求已接收，继续处理"><a href="#1xx：指示信息–表示请求已接收，继续处理" class="headerlink" title="1xx：指示信息–表示请求已接收，继续处理"></a>1xx：指示信息–表示请求已接收，继续处理</h6><h6 id="2xx：成功–表示请求已被成功接收、理解、接受"><a href="#2xx：成功–表示请求已被成功接收、理解、接受" class="headerlink" title="2xx：成功–表示请求已被成功接收、理解、接受"></a>2xx：成功–表示请求已被成功接收、理解、接受</h6><h6 id="3xx：重定向–要完成请求必须进行更进一步的操作"><a href="#3xx：重定向–要完成请求必须进行更进一步的操作" class="headerlink" title="3xx：重定向–要完成请求必须进行更进一步的操作"></a>3xx：重定向–要完成请求必须进行更进一步的操作</h6><h6 id="4xx：客户端错误–请求有语法错误或请求无法实现"><a href="#4xx：客户端错误–请求有语法错误或请求无法实现" class="headerlink" title="4xx：客户端错误–请求有语法错误或请求无法实现"></a>4xx：客户端错误–请求有语法错误或请求无法实现</h6><h6 id="5xx：服务器端错误–服务器未能实现合法的请求"><a href="#5xx：服务器端错误–服务器未能实现合法的请求" class="headerlink" title="5xx：服务器端错误–服务器未能实现合法的请求"></a>5xx：服务器端错误–服务器未能实现合法的请求</h6><p>常见状态码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">200 OK                        //客户端请求成功</span><br><span class="line">400 Bad Request               //客户端请求有语法错误，不能被服务器所理解</span><br><span class="line">401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </span><br><span class="line">403 Forbidden                 //服务器收到请求，但是拒绝提供服务</span><br><span class="line">404 Not Found                 //请求资源不存在，eg：输入了错误的URL</span><br><span class="line">500 Internal Server Error     //服务器发生不可预期的错误</span><br><span class="line">503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</span><br></pre></td></tr></table></figure>
<p>更多状态码<a href="http://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener">http://www.runoob.com/http/http-status-codes.html</a></p>
<h2 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h2><p>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET     请求指定的页面信息，并返回实体主体。</span><br><span class="line">HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</span><br><span class="line">POST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</span><br><span class="line">PUT     从客户端向服务器传送的数据取代指定的文档的内容。</span><br><span class="line">DELETE      请求服务器删除指定的页面。</span><br><span class="line">CONNECT     HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</span><br><span class="line">OPTIONS     允许客户端查看服务器的性能。</span><br><span class="line">TRACE     回显服务器收到的请求，主要用于测试或诊断。</span><br></pre></td></tr></table></figure>
<h2 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h2><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
<p>以下是 HTTP 请求/响应的步骤：</p>
<h6 id="1、客户端连接到Web服务器"><a href="#1、客户端连接到Web服务器" class="headerlink" title="1、客户端连接到Web服务器"></a>1、客户端连接到Web服务器</h6><p>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.oakcms.cn./" target="_blank" rel="noopener">http://www.oakcms.cn。</a></p>
<h6 id="2、发送HTTP请求"><a href="#2、发送HTTP请求" class="headerlink" title="2、发送HTTP请求"></a>2、发送HTTP请求</h6><p>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p>
<h6 id="3、服务器接受请求并返回HTTP响应"><a href="#3、服务器接受请求并返回HTTP响应" class="headerlink" title="3、服务器接受请求并返回HTTP响应"></a>3、服务器接受请求并返回HTTP响应</h6><p>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p>
<h6 id="4、释放连接TCP连接"><a href="#4、释放连接TCP连接" class="headerlink" title="4、释放连接TCP连接"></a>4、释放连接<a href="http://www.jianshu.com/p/ef892323e68f" target="_blank" rel="noopener">TCP连接</a></h6><p>若connection 模式为close，则服务器主动关闭<a href="http://www.jianshu.com/p/ef892323e68f" target="_blank" rel="noopener">TCP连接</a>，客户端被动关闭连接，释放<a href="http://www.jianshu.com/p/ef892323e68f" target="_blank" rel="noopener">TCP连接</a>;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p>
<h6 id="5、客户端浏览器解析HTML内容"><a href="#5、客户端浏览器解析HTML内容" class="headerlink" title="5、客户端浏览器解析HTML内容"></a>5、客户端浏览器解析HTML内容</h6><p>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p>
<p>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p>
<p>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</p>
<p>2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立<a href="http://www.jianshu.com/p/ef892323e68f" target="_blank" rel="noopener">TCP连接</a>;</p>
<p>3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 <a href="http://www.jianshu.com/p/ef892323e68f" target="_blank" rel="noopener">TCP 三次握手</a>的第三个报文的数据发送给服务器;</p>
<p>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</p>
<p>5、释放 <a href="http://www.jianshu.com/p/ef892323e68f" target="_blank" rel="noopener">TCP连接</a>;</p>
<p>6、浏览器将该 html 文本并显示内容; 　　</p>
<h2 id="GET和POST请求的区别"><a href="#GET和POST请求的区别" class="headerlink" title="GET和POST请求的区别"></a>GET和POST请求的区别</h2><h6 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /books/?sex=man&amp;name=Professional HTTP/1.1</span><br><span class="line">Host: www.wrox.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class="line">Gecko/20050225 Firefox/1.0.1</span><br><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure>
<p>注意最后一行是空行</p>
<h6 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: www.wrox.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class="line">Gecko/20050225 Firefox/1.0.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 40</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line"></span><br><span class="line">name=Professional%20Ajax&amp;publisher=Wiley</span><br></pre></td></tr></table></figure>
<p>1、GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接；例 如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。</p>
<p>POST提交：把提交的数据放置在是HTTP包的包体中。上文示例中红色字体标明的就是实际的传输数据</p>
<h6 id="因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变"><a href="#因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变" class="headerlink" title="因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变"></a>因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变</h6><p>2、传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。</p>
<p>而在实际开发中存在的限制主要有：</p>
<p><strong>GET</strong>:特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系 统的支持。</p>
<p>因此对于GET提交时，传输数据就会受到URL长度的 限制。</p>
<p><strong>POST</strong>:由于不是通过URL传值，理论上数据不受 限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。</p>
<p>3、安全性</p>
<p>POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存；(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击</p>
<p>4、Http get,post,soap协议都是在http上运行的</p>
<p>（1）get：请求参数是作为一个key/value对的序列（查询字符串）附加到URL上的<br>查询字符串的长度受到web浏览器和web服务器的限制（如IE最多支持2048个字符），不适合传输大型数据集同时，它很不安全</p>
<p>（2）post：请求参数是在http标题的一个不同部分（名为entity body）传输的，这一部分用来传输表单信息，因此必须将Content-type设置为:application/x-www-form- urlencoded。post设计用来支持web窗体上的用户字段，其参数也是作为key/value对传输。<br>但是：它不支持复杂数据类型，因为post没有定义传输数据结构的语义和规则。</p>
<p>（3）soap：是http post的一个专用版本，遵循一种特殊的xml消息格式<br>Content-type设置为: text/xml 任何数据都可以xml化。</p>
<p>Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.</p>
<p>我们看看GET和POST的区别</p>
<ol>
<li><ol>
<li>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中.</li>
<li>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</li>
<li>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</li>
<li>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</li>
</ol>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/TCP和UDP的区别和优缺点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/TCP和UDP的区别和优缺点/" itemprop="url">
                  TCP和UDP的区别和优缺点
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 14:44:15 / 修改时间：14:58:27" itemprop="dateCreated datePublished" datetime="2018-09-17T14:44:15+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络相关/" itemprop="url" rel="index"><span itemprop="name">网络相关</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://blog.csdn.net/xiaobangkuaipao/article/details/76793702" target="_blank" rel="noopener">转自 <a href="https://blog.csdn.net/xiaobangkuaipao" target="_blank" rel="noopener">xiaobangkuaipao</a></a></p>
<h1 id="TCP与UDP区别总结："><a href="#TCP与UDP区别总结：" class="headerlink" title="TCP与UDP区别总结："></a>TCP与UDP区别总结：</h1><p>1、TCP面向连接（如打电话要先拨号建立连接）;</p>
<p>UDP是无连接的，即发送数据之前不需要建立连接</p>
<p>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</p>
<p>Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</p>
<p>3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</p>
<p>4.每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</p>
<p>5、TCP对系统资源要求较多，UDP对系统资源要求较少。</p>
<h2 id="为什么UDP有时比TCP更有优势"><a href="#为什么UDP有时比TCP更有优势" class="headerlink" title="为什么UDP有时比TCP更有优势?"></a>为什么UDP有时比TCP更有优势?</h2><p>UDP以其简单、传输快的优势，在越来越多场景下取代了TCP,如实时游戏。</p>
<p>（1）网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。</p>
<p>（2）TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。</p>
<p>采用TCP，一旦发生丢包，TCP会将后续的包缓存起来，等前面的包重传并接收到后再继续发送，延时会越来越大，基于UDP对实时性要求较为严格的情况下，采用自定义重传机制，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成影响。</p>
<p>3、UDP和TCP编程步骤也有些不同，如下：</p>
<p><strong>TCP: </strong><br>TCP编程的服务器端一般步骤是：<br>　　1、创建一个socket，用函数socket()；     SOCKET SocketListen =socket(AF_INET,SOCK_STREAM, IPPROTO_TCP);<br>　　2、设置socket属性，用函数setsockopt(); <em> 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind(); SOCKET_ERROR = bind(SocketListen,(const sockaddr</em>)&amp;addr,sizeof(addr))<br>　　4、开启监听，用函数listen()；                 SOCKET_ERROR == listen(SocketListen,2)<br>　　5、接收客户端上来的连接，用函数accept()；    SOCKET SocketWaiter = accept(SocketListen,</p>
<p>​                                                  <em>Out</em>    struct sockaddr *addr</p>
<p> <em>Inout</em>  int <em>addrlen);<br>　　6、收发数据，用函数send()和recv()，或者read()和write();<br>　　7、关闭网络连接； closesocket(SocketListen);closesocket(SocketWaiter);<br>　　8、关闭监听；<br>SOCK_STREAM这种的特点是面向连接的，即每次收发数据之前必须通过connect建立连接，而SOCK_DGRAM这种是User Datagram Protocol协议的网络通讯，它是无连接的，不可靠的。<br>TCP编程的客户端一般步骤是：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt();</em> 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选<br>　　4、设置要连接的对方的IP地址和端口等属性；<br>　　5、连接服务器，用函数connect()；<br>　　6、收发数据，用函数send()和recv()，或者read()和write();<br>　　7、关闭网络连接；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int send(</span><br><span class="line">  _In_  SOCKET s,         //向哪个socket发送，accept返回的socket。</span><br><span class="line">  _In_  const char *buf,</span><br><span class="line">  _In_  int len,</span><br><span class="line">  _In_  int flags</span><br><span class="line">);                               由于</span><br></pre></td></tr></table></figure>
<p>send(SocketClient,(const char *)&amp;fh,sizeof(fh),0);</p>
<p>recv(SocketClient,szbuf,sizeof(szbuf),0);<br><strong>UDP:</strong><br>与之对应的UDP编程步骤要简单许多，分别如下：<br>　　UDP编程的服务器端一般步骤是：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt();<em> 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();<br>　　4、循环接收数据，用函数recvfrom();<br>　　5、关闭网络连接；<br>UDP编程的客户端一般步骤是：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt();</em> 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选<br>　　4、设置对方的IP地址和端口等属性;<br>　　5、发送数据，用函数sendto();<br>　　6、关闭网络连接；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int recvfrom(</span><br><span class="line">  _In_         SOCKET s,       //绑定的socket</span><br><span class="line">  _Out_        char *buf,</span><br><span class="line">  _In_         int len,</span><br><span class="line">  _In_         int flags,</span><br><span class="line">  _Out_        struct sockaddr *from,  //用来接收对方的</span><br><span class="line">  _Inout_opt_  int *fromlen</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>int nres=</p>
<p>recvfrom</p>
<p>(pThis-&gt;m_socketListen,szBuf,sizeof(szBuf),0,(sockaddr<em>)&amp;addrClient,&amp;nSize);//0处标志位<br>sendto(m_socketListen,szBuffer,nSize,0,(const sockaddr</em>)&amp;addr,sizeof(sockaddr_in))</p>
<p>TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。</p>
<p>4、将socket设置为广播属性<br>bool optval=true;<br>setsockopt(m_socketListen,SOL_SOCKET,SO_BROADCAST,(const char *)&amp;optval,sizeof(bool));</p>
<p>5、将Socket设置为非阻塞。<br>//bool benable=true;<br>//ioctlsocket(m_socketListen,FIONBIO,(u_long*)&amp;benable);</p>
<p>6、Tcp头，20字节</p>
<p><img src="http://ovwhbnlx7.bkt.clouddn.com/20170806225229000.png" alt="20170806225229000"></p>
<p>7、UDP首部,8个字节</p>
<p><img src="http://ovwhbnlx7.bkt.clouddn.com/20170806225326602.png" alt="20170806225326602"></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/RunLoop详尽总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/RunLoop详尽总结/" itemprop="url">
                  RunLoop详尽总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 14:22:30 / 修改时间：14:24:43" itemprop="dateCreated datePublished" datetime="2018-09-17T14:22:30+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/RunLoop/" itemprop="url" rel="index"><span itemprop="name">RunLoop</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.bujige.net/blog/iOS-Complete-learning-RunLoop.html" target="_blank" rel="noopener">转自 行走的少年郎</a></p>
<h2 id="1-RunLoop简介"><a href="#1-RunLoop简介" class="headerlink" title="1. RunLoop简介"></a>1. RunLoop简介</h2><h3 id="1-1-什么是RunLoop？"><a href="#1-1-什么是RunLoop？" class="headerlink" title="1.1 什么是RunLoop？"></a>1.1 什么是RunLoop？</h3><p>可以理解为字面意思：Run表示运行，Loop表示循环。结合在一起就是运行的循环的意思。哈哈，我更愿意翻译为『跑圈』。直观理解就像是不停的跑圈。</p>
<p>RunLoop实际上是一个对象，这个对象在循环中用来处理程序运行过程中出现的各种事件（比如说触摸事件、UI刷新事件、定时器事件、Selector事件），从而保持程序的持续运行；而且在没有事件处理的时候，会进入睡眠模式，从而节省CPU资源，提高程序性能。</p>
<h3 id="1-2-RunLoop和线程"><a href="#1-2-RunLoop和线程" class="headerlink" title="1.2 RunLoop和线程"></a>1.2 RunLoop和线程</h3><p>RunLoop和线程是息息相关的，我们知道线程的作用是用来执行特定的一个或多个任务，但是在默认情况下，线程执行完之后就会退出，就不能再执行任务了。这时我们就需要采用一种方式来让线程能够处理任务，并不退出。所以，我们就有了RunLoop。</p>
<ol>
<li>一条线程对应一个RunLoop对象，每条线程都有唯一一个与之对应的RunLoop对象。</li>
<li>我们只能在当前线程中操作当前线程的RunLoop，而不能去操作其他线程的RunLoop。</li>
<li>RunLoop对象在第一次获取RunLoop时创建，销毁则是在线程结束的时候。</li>
<li>主线程的RunLoop对象系统自动帮助我们创建好了(原理如下)，而子线程的RunLoop对象需要我们主动创建。</li>
</ol>
<h3 id="1-3-默认情况下主线程的RunLoop原理"><a href="#1-3-默认情况下主线程的RunLoop原理" class="headerlink" title="1.3 默认情况下主线程的RunLoop原理"></a>1.3 默认情况下主线程的RunLoop原理</h3><p>我们在启动一个iOS程序的时候，系统会调用创建项目时自动生成的main.m的文件。main.m文件如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>UIApplicationMain</code>函数内部帮我们开启了主线程的RunLoop，<code>UIApplicationMain</code>内部拥有一个无线循环的代码。上边的代码中开启RunLoop的过程可以简单的理解为如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;        </span><br><span class="line">    BOOL running = YES;</span><br><span class="line">    do &#123;</span><br><span class="line">        // 执行各种任务，处理各种事件</span><br><span class="line">        // ......</span><br><span class="line">    &#125; while (running);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上边可看出，程序一直在do-while循环中执行，所以UIApplicationMain函数一直没有返回，我们在运行程序之后程序不会马上退出，会保持持续运行状态。</p>
<p>下图是苹果官方给出的RunLoop模型图。</p>
<p><a href="https://upload-images.jianshu.io/upload_images/1877784-6ab632fc118e31f3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/1877784-6ab632fc118e31f3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="官方RunLoop模型图"></a></p>
<p>从上图中可以看出，RunLoop就是线程中的一个循环，RunLoop在循环中会不断检测，通过Input sources（输入源）和Timer sources（定时源）两种来源等待接受事件；然后对接受到的事件通知线程进行处理，并在没有事件的时候进行休息。</p>
<h2 id="2-RunLoop相关类"><a href="#2-RunLoop相关类" class="headerlink" title="2. RunLoop相关类"></a>2. RunLoop相关类</h2><p>下面我们来了解一下Core Foundation框架下关于RunLoop的5个类，只有弄懂这几个类的含义，我们才能深入了解RunLoop运行机制。</p>
<ol>
<li>CFRunLoopRef：代表RunLoop的对象</li>
<li>CFRunLoopModeRef：RunLoop的运行模式</li>
<li>CFRunLoopSourceRef：就是RunLoop模型图中提到的输入源/事件源</li>
<li>CFRunLoopTimerRef：就是RunLoop模型图中提到的定时源</li>
<li>CFRunLoopObserverRef：观察者，能够监听RunLoop的状态改变</li>
</ol>
<p>下边详细讲解下几种类的具体含义和关系。</p>
<p>先来看一张表示这5个类的关系图（来源：<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">https://blog.ibireme.com/2015/05/18/runloop/</a>）。</p>
<p><a href="https://upload-images.jianshu.io/upload_images/1877784-2177aa2828b1ad34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/1877784-2177aa2828b1ad34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RunLoop相关类关系图.png"></a></p>
<p>接着来讲解这5个类的相互关系（来源：<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">https://blog.ibireme.com/2015/05/18/runloop/</a>），这篇文章总结的特别好，就拿来参考一下，有兴趣的朋友可以去看看，写的很好。</p>
<p>一个RunLoop对象（CFRunLoopRef）中包含若干个运行模式（CFRunLoopModeRef）。而每一个运行模式下又包含若干个输入源（CFRunLoopSourceRef）、定时源（CFRunLoopTimerRef）、观察者（CFRunLoopObserverRef）。</p>
<ul>
<li>每次RunLoop启动时，只能指定其中一个运行模式（CFRunLoopModeRef），这个运行模式（CFRunLoopModeRef）被称作CurrentMode。</li>
<li>如果需要切换运行模式（CFRunLoopModeRef），只能退出Loop，再重新指定一个运行模式（CFRunLoopModeRef）进入。</li>
<li>这样做主要是为了分隔开不同组的输入源（CFRunLoopSourceRef）、定时源（CFRunLoopTimerRef）、观察者（CFRunLoopObserverRef），让其互不影响 。</li>
</ul>
<p>下边我们来详细讲解下这五个类：</p>
<h3 id="2-1-CFRunLoopRef"><a href="#2-1-CFRunLoopRef" class="headerlink" title="2.1 CFRunLoopRef"></a>2.1 CFRunLoopRef</h3><p>CFRunLoopRef就是Core Foundation框架下RunLoop对象类。我们可通过以下方式来获取RunLoop对象：</p>
<ul>
<li>Core Foundation<ul>
<li><code>CFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象</code></li>
<li><code>CFRunLoopGetMain(); // 获得主线程的RunLoop对象</code></li>
</ul>
</li>
</ul>
<p>当然，在Foundation框架下获取RunLoop对象类的方法如下：</p>
<ul>
<li>Foundation<ul>
<li><code>[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象</code></li>
<li><code>[NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象</code></li>
</ul>
</li>
</ul>
<h3 id="2-2-CFRunLoopModeRef"><a href="#2-2-CFRunLoopModeRef" class="headerlink" title="2.2 CFRunLoopModeRef"></a>2.2 CFRunLoopModeRef</h3><p>系统默认定义了多种运行模式（CFRunLoopModeRef），如下：</p>
<ol>
<li><strong>kCFRunLoopDefaultMode</strong>：App的默认运行模式，通常主线程是在这个运行模式下运行</li>
<li><strong>UITrackingRunLoopMode</strong>：跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响）</li>
<li>UIInitializationRunLoopMode：在刚启动App时第进入的第一个 Mode，启动完成后就不再使用</li>
<li>GSEventReceiveRunLoopMode：接受系统内部事件，通常用不到</li>
<li><strong>kCFRunLoopCommonModes</strong>：伪模式，不是一种真正的运行模式（后边会用到）</li>
</ol>
<p>其中<strong>kCFRunLoopDefaultMode</strong>、<strong>UITrackingRunLoopMode</strong>、<strong>kCFRunLoopCommonModes</strong>是我们开发中需要用到的模式，具体使用方法我们在 <strong>2.3 CFRunLoopTimerRef</strong> 中结合CFRunLoopTimerRef来演示说明。</p>
<h3 id="2-3-CFRunLoopTimerRef"><a href="#2-3-CFRunLoopTimerRef" class="headerlink" title="2.3 CFRunLoopTimerRef"></a>2.3 CFRunLoopTimerRef</h3><p>CFRunLoopTimerRef是定时源（RunLoop模型图中提到过），理解为基于时间的触发器，基本上就是NSTimer（哈哈，这个理解就简单了吧）。</p>
<p>下面我们来演示下CFRunLoopModeRef和CFRunLoopTimerRef结合的使用用法，从而加深理解。</p>
<ol>
<li><p>首先我们新建一个iOS项目，在Main.storyboard中拖入一个Text View。</p>
</li>
<li><p>在ViewController.m文件中加入以下代码，<a href="https://github.com/lianai911/YSC-RunLoopDemo" target="_blank" rel="noopener">Demo</a>中请调用<code>[self ShowDemo1];</code>来演示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    // 定义一个定时器，约定两秒之后调用self的run方法</span><br><span class="line">    NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];</span><br><span class="line"></span><br><span class="line">    // 将定时器添加到当前RunLoop的NSDefaultRunLoopMode下</span><br><span class="line">    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)run</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;---run&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后运行，这时候我们发现如果我们不对模拟器进行任何操作的话，定时器会稳定的每隔2秒调用run方法打印。</p>
</li>
<li><p>但是当我们拖动Text View滚动时，我们发现：run方法不打印了，也就是说NSTimer不工作了。而当我们松开鼠标的时候，NSTimer就又开始正常工作了。</p>
</li>
</ol>
<p>这是因为：</p>
<ul>
<li>当我们不做任何操作的时候，RunLoop处于NSDefaultRunLoopMode下。</li>
<li>而当我们拖动Text View的时候，RunLoop就结束NSDefaultRunLoopMode，切换到了UITrackingRunLoopMode模式下，这个模式下没有添加NSTimer，所以我们的NSTimer就不工作了。</li>
<li>但当我们松开鼠标的时候，RunLoop就结束UITrackingRunLoopMode模式，又切换回NSDefaultRunLoopMode模式，所以NSTimer就又开始正常工作了。</li>
</ul>
<p>你可以试着将上述代码中的<code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</code>语句换为<code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];</code>，也就是将定时器添加到当前RunLoop的UITrackingRunLoopMode下，你就会发现定时器只会在拖动Text View的模式下工作，而不做操作的时候定时器就不工作。</p>
<p>那难道我们就不能在这两种模式下让NSTimer都能正常工作吗？</p>
<p>当然可以，这就用到了我们之前说过的<strong>伪模式（kCFRunLoopCommonModes）</strong>，这其实不是一种真实的模式，而是一种标记模式，意思就是可以在打上Common Modes标记的模式下运行。</p>
<p>那么哪些模式被标记上了Common Modes呢？</p>
<p><strong>NSDefaultRunLoopMode</strong> 和 <strong>UITrackingRunLoopMode</strong>。</p>
<p>所以我们只要我们将NSTimer添加到当前RunLoop的kCFRunLoopCommonModes（Foundation框架下为NSRunLoopCommonModes）下，我们就可以让NSTimer在不做操作和拖动Text View两种情况下愉快的正常工作了。</p>
<p>具体做法就是讲添加语句改为<code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</code></p>
<p>既然讲到了NSTimer，这里顺便讲下NSTimer中的<code>scheduledTimerWithTimeInterval</code>方法和RunLoop的关系。添加下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];</span><br></pre></td></tr></table></figure>
<p>这句代码调用了scheduledTimer返回的定时器，NSTimer会自动被加入到了RunLoop的NSDefaultRunLoopMode模式下。这句代码相当于下面两句代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</span><br></pre></td></tr></table></figure>
<h3 id="2-4-CFRunLoopSourceRef"><a href="#2-4-CFRunLoopSourceRef" class="headerlink" title="2.4 CFRunLoopSourceRef"></a>2.4 CFRunLoopSourceRef</h3><p>CFRunLoopSourceRef是事件源（RunLoop模型图中提到过），CFRunLoopSourceRef有两种分类方法。</p>
<ul>
<li>第一种按照官方文档来分类（就像RunLoop模型图中那样）：<ul>
<li>Port-Based Sources（基于端口）</li>
<li>Custom Input Sources（自定义）</li>
<li>Cocoa Perform Selector Sources</li>
</ul>
</li>
<li>第二种按照函数调用栈来分类：<ul>
<li>Source0 ：非基于Port</li>
<li>Source1：基于Port，通过内核和其他线程通信，接收、分发系统事件</li>
</ul>
</li>
</ul>
<p>这两种分类方式其实没有区别，只不过第一种是通过官方理论来分类，第二种是在实际应用中通过调用函数来分类。</p>
<p>下边我们举个例子大致来了解一下函数调用栈和Source。</p>
<ol>
<li><p>在我们的项目中的Main.storyboard中添加一个Button按钮，并添加点击动作。</p>
</li>
<li><p>然后在点击动作的代码中加入一句输出语句，并打上断点，如下图所示：</p>
<p><a href="https://upload-images.jianshu.io/upload_images/1877784-f801715c95de19f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/1877784-f801715c95de19f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加Button.png"></a></p>
</li>
<li><p>然后运行程序，并点击按钮。</p>
</li>
<li><p>然后在项目中单击下下图红色部分。</p>
<p><a href="https://upload-images.jianshu.io/upload_images/1877784-970c15ff611d4d6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/1877784-970c15ff611d4d6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="函数调用栈展示图"></a></p>
</li>
<li><p>可以看到如下图所示就是点击事件产生的函数调用栈。</p>
<p><a href="https://upload-images.jianshu.io/upload_images/1877784-c014e77adce248c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/1877784-c014e77adce248c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="函数调用栈"></a></p>
</li>
</ol>
<p>所以点击事件是这样来的：</p>
<ol>
<li>首先程序启动，调用16行的main函数，main函数调用15行UIApplicationMain函数，然后一直往上调用函数，最终调用到0行的BtnClick函数，即点击函数。</li>
<li>同时我们可以看到11行中有Sources0，也就是说我们点击事件是属于Sources0函数的，点击事件就是在Sources0中处理的。</li>
<li>而至于Sources1，则是用来接收、分发系统事件，然后再分发到Sources0中处理的。</li>
</ol>
<h3 id="2-5-CFRunLoopObserverRef"><a href="#2-5-CFRunLoopObserverRef" class="headerlink" title="2.5 CFRunLoopObserverRef"></a>2.5 CFRunLoopObserverRef</h3><p>CFRunLoopObserverRef是观察者，用来监听RunLoop的状态改变</p>
<p>CFRunLoopObserverRef可以监听的状态改变有以下几种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0),               // 即将进入Loop：1</span><br><span class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),        // 即将处理Timer：2    </span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),       // 即将处理Source：4</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),       // 即将进入休眠：32</span><br><span class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),        // 即将从休眠中唤醒：64</span><br><span class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7),                // 即将从Loop中退出：128</span><br><span class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU       // 监听全部状态改变  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下边我们通过代码来监听下RunLoop中的状态改变。</p>
<ol>
<li><p>在ViewController.m中添加如下代码，<a href="https://github.com/lianai911/YSC-RunLoopDemo" target="_blank" rel="noopener">Demo</a>中请调用<code>[self showDemo2];</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    // 创建观察者</span><br><span class="line">    CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">        NSLog(@&quot;监听到RunLoop发生改变---%zd&quot;,activity);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 添加观察者到当前RunLoop中</span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);</span><br><span class="line"></span><br><span class="line">    // 释放observer，最后添加完需要释放掉</span><br><span class="line">    CFRelease(observer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后运行，看下打印结果，如下图。</p>
</li>
</ol>
<p><a href="https://upload-images.jianshu.io/upload_images/1877784-2005e92565b30e68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/1877784-2005e92565b30e68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打印结果"></a></p>
<p>可以看到RunLoop的状态在不断的改变，最终变成了状态 32，也就是即将进入睡眠状态，说明RunLoop之后就会进入睡眠状态。</p>
<h2 id="3-RunLoop原理"><a href="#3-RunLoop原理" class="headerlink" title="3. RunLoop原理"></a>3. RunLoop原理</h2><p>好了，五个类都讲解完了，下边开始放大招了。这下我们就可以来理解RunLoop的运行逻辑了。</p>
<p>下边上一张之前提到的文章中博主提供的运行逻辑图（来源：<a href="https://blog.ibireme.com/2015/05/18/runloop/%EF%BC%89" target="_blank" rel="noopener">https://blog.ibireme.com/2015/05/18/runloop/）</a></p>
<p><a href="https://upload-images.jianshu.io/upload_images/1877784-94c6cdb3a7864593.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/1877784-94c6cdb3a7864593.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RunLoop运行逻辑图"></a></p>
<p>这张图对于我们理解RunLoop来说太有帮助了，下边我们可以来说下官方文档给我们的RunLoop逻辑。</p>
<p>在每次运行开启RunLoop的时候，所在线程的RunLoop会自动处理之前未处理的事件，并且通知相关的观察者。</p>
<p>具体的顺序如下：</p>
<ol>
<li>通知观察者RunLoop已经启动</li>
<li>通知观察者即将要开始的定时器</li>
<li>通知观察者任何即将启动的非基于端口的源</li>
<li>启动任何准备好的非基于端口的源</li>
<li>如果基于端口的源准备好并处于等待状态，立即启动；并进入步骤9</li>
<li>通知观察者线程进入休眠状态</li>
<li>将线程置于休眠知道任一下面的事件发生：<ul>
<li>某一事件到达基于端口的源</li>
<li>定时器启动</li>
<li>RunLoop设置的时间已经超时</li>
<li>RunLoop被显示唤醒</li>
</ul>
</li>
<li>通知观察者线程将被唤醒</li>
<li>处理未处理的事件<ul>
<li>如果用户定义的定时器启动，处理定时器事件并重启RunLoop。进入步骤2</li>
<li>如果输入源启动，传递相应的消息</li>
<li>如果RunLoop被显示唤醒而且时间还没超时，重启RunLoop。进入步骤2</li>
</ul>
</li>
<li>通知观察者RunLoop结束。</li>
</ol>
<h2 id="4-RunLoop实战应用"><a href="#4-RunLoop实战应用" class="headerlink" title="4. RunLoop实战应用"></a>4. RunLoop实战应用</h2><p>哈哈，讲了这么多云里雾里的原理知识，下边终于到了实战应用环节。</p>
<p>光弄懂是没啥用的，能够实战应用才是硬道理。下面讲解一下RunLoop的几种应用。</p>
<h3 id="4-1-NSTimer的使用"><a href="#4-1-NSTimer的使用" class="headerlink" title="4.1 NSTimer的使用"></a>4.1 NSTimer的使用</h3><p>NSTimer的使用方法在讲解<code>CFRunLoopTimerRef</code>类的时候详细讲解过，具体参考上边 <strong>2.3 CFRunLoopTimerRef</strong>。</p>
<h3 id="4-2-ImageView推迟显示"><a href="#4-2-ImageView推迟显示" class="headerlink" title="4.2 ImageView推迟显示"></a>4.2 ImageView推迟显示</h3><p>有时候，我们会遇到这种情况：<br>当界面中含有UITableView，而且每个UITableViewCell里边都有图片。这时候当我们滚动UITableView的时候，如果有一堆的图片需要显示，那么可能会出现卡顿的现象。</p>
<p>怎么解决这个问题呢？</p>
<p>这时候，我们应该推迟图片的显示，也就是ImageView推迟显示图片。有两种方法：</p>
<h4 id="1-监听UIScrollView的滚动"><a href="#1-监听UIScrollView的滚动" class="headerlink" title="1. 监听UIScrollView的滚动"></a>1. 监听UIScrollView的滚动</h4><p>因为UITableView继承自UIScrollView，所以我们可以通过监听UIScrollView的滚动，实现UIScrollView相关delegate即可。</p>
<h4 id="2-利用PerformSelector设置当前线程的RunLoop的运行模式"><a href="#2-利用PerformSelector设置当前线程的RunLoop的运行模式" class="headerlink" title="2. 利用PerformSelector设置当前线程的RunLoop的运行模式"></a>2. 利用PerformSelector设置当前线程的RunLoop的运行模式</h4><p>利用<code>performSelector</code>方法为UIImageView调用<code>setImage:</code>方法，并利用<code>inModes</code>将其设置为RunLoop下NSDefaultRunLoopMode运行模式。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@&quot;tupian&quot;] afterDelay:4.0 inModes:NSDefaultRunLoopMode];</span><br></pre></td></tr></table></figure>
<p>下边利用Demo演示一下该方法。</p>
<ol>
<li><p>在项目中的Main.storyboard中添加一个UIImageView，并添加属性，并简单添加一下约束（不然无法显示）如下图所示。</p>
<p><a href="https://upload-images.jianshu.io/upload_images/1877784-8253c4b57f1b674e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/1877784-8253c4b57f1b674e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加UIImageView"></a></p>
</li>
<li><p>在项目中拖入一张图片，比如下图。</p>
<p><a href="https://upload-images.jianshu.io/upload_images/1877784-b4777f945878a0b9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/1877784-b4777f945878a0b9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tupian.jpg"></a></p>
</li>
<li><p>然后我们在<code>touchesBegan</code>方法中添加下面的代码，在<a href="https://github.com/lianai911/YSC-RunLoopDemo" target="_blank" rel="noopener">Demo</a>中请在<code>touchesBegan</code>中调用<code>[self showDemo3];</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    [self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@&quot;tupian&quot;] afterDelay:4.0 inModes:@[NSDefaultRunLoopMode]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行程序，点击一下屏幕，然后拖动UIText View，拖动4秒以上，发现过了4秒之后，UIImageView还没有显示图片，当我们松开的时候，则显示图片，效果如下：</p>
</li>
</ol>
<p><a href="https://upload-images.jianshu.io/upload_images/1877784-13880540c8c89552.gif?imageMogr2/auto-orient/strip" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/1877784-13880540c8c89552.gif?imageMogr2/auto-orient/strip" alt="UIImageView延迟显示效果.gif"></a></p>
<p>这样我们就实现了在拖动完之后，在延迟显示UIImageView。</p>
<h3 id="4-3-后台常驻线程（很常用）"><a href="#4-3-后台常驻线程（很常用）" class="headerlink" title="4.3 后台常驻线程（很常用）"></a>4.3 后台常驻线程（很常用）</h3><p>我们在开发应用程序的过程中，如果后台操作特别频繁，经常会在子线程做一些耗时操作（下载文件、后台播放音乐等），我们最好能让这条线程永远常驻内存。</p>
<p>那么怎么做呢？</p>
<p>添加一条用于常驻内存的强引用的子线程，在该线程的RunLoop下添加一个Sources，开启RunLoop。</p>
<p>具体实现过程如下：</p>
<ol>
<li><p>在项目的ViewController.m中添加一条强引用的thread线程属性，如下图：</p>
<p><a href="https://upload-images.jianshu.io/upload_images/1877784-ffce8301e3bd4736.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/1877784-ffce8301e3bd4736.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加thread属性"></a></p>
</li>
<li><p>在viewDidLoad中创建线程self.thread，使线程启动并执行run1方法，代码如下。在<a href="https://github.com/lianai911/YSC-RunLoopDemo" target="_blank" rel="noopener">Demo</a>中，请在viewDidLoad调用<code>[self showDemo4];</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    // 创建线程，并调用run1方法执行任务</span><br><span class="line">    self.thread = [[NSThread alloc] initWithTarget:self selector:@selector(run1) object:nil];</span><br><span class="line">    // 开启线程</span><br><span class="line">    [self.thread start];    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) run1</span><br><span class="line">&#123;</span><br><span class="line">    // 这里写任务</span><br><span class="line">    NSLog(@&quot;----run1-----&quot;);</span><br><span class="line"></span><br><span class="line">    // 添加下边两句代码，就可以开启RunLoop，之后self.thread就变成了常驻线程，可随时添加任务，并交于RunLoop处理</span><br><span class="line">    [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">    [[NSRunLoop currentRunLoop] run];</span><br><span class="line"></span><br><span class="line">    // 测试是否开启了RunLoop，如果开启RunLoop，则来不了这里，因为RunLoop开启了循环。</span><br><span class="line">    NSLog(@&quot;未开启RunLoop&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行之后发现打印了<strong>—-run1—–</strong>，而<strong>未开启RunLoop</strong>则未打印。</p>
</li>
</ol>
<p>这时，我们就开启了一条常驻线程，下边我们来试着添加其他任务，除了之前创建的时候调用了run1方法，我们另外在点击的时候调用run2方法。</p>
<p>那么，我们在touchesBegan中调用PerformSelector，从而实现在点击屏幕的时候调用run2方法。<a href="https://github.com/lianai911/YSC-RunLoopDemo" target="_blank" rel="noopener">Demo地址</a>。具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;   </span><br><span class="line">    // 利用performSelector，在self.thread的线程中调用run2方法执行任务</span><br><span class="line">    [self performSelector:@selector(run2) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) run2</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;----run2------&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过运行测试，除了之前打印的<strong>—-run1—–</strong>，每当我们点击屏幕，都能调用<strong>—-run2——</strong>。<br>这样我们就实现了常驻线程的需求。</p>
<hr>
<p>彻底学会多线程系列其他文章：</p>
<ul>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-pthread-and-NSThread.html" target="_blank" rel="noopener">iOS多线程–彻底学会多线程之『pthread、NSThread』</a></li>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-GCD.html" target="_blank" rel="noopener">iOS多线程–彻底学会多线程之『GCD』</a></li>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-NSOperation.html" target="_blank" rel="noopener">iOS多线程–彻底学会多线程之『NSOperation』</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/pthread、NSThread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/pthread、NSThread/" itemprop="url">
                  pthread、NSThread
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 12:24:19 / 修改时间：14:28:05" itemprop="dateCreated datePublished" datetime="2018-09-17T12:24:19+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/多线程/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.bujige.net/blog/iOS-Complete-learning-pthread-and-NSThread.html" target="_blank" rel="noopener">转自 行走的少年郎</a></p>
<p><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-background.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-background.png" alt="img"></a></p>
<blockquote>
<p>本文用来介绍 iOS 多线程中，<strong>pthread、NSThread</strong> 的使用方法及实现。<br>第一部分：pthread 的使用、其他相关方法。<br>第二部分：NSThread 的使用、线程相关用法、线程状态控制方法、线程之间的通信、线程安全和线程同步，以及线程的状态转换相关知识。</p>
<p>文中 Demo 我已放在了 Github 上，Demo 链接：<a href="https://github.com/bujige/YSC-pthread-NSThread-demo" target="_blank" rel="noopener">传送门</a></p>
</blockquote>
<h1 id="1-pthread"><a href="#1-pthread" class="headerlink" title="1. pthread"></a>1. pthread</h1><h2 id="1-1-pthread-简介"><a href="#1-1-pthread-简介" class="headerlink" title="1.1 pthread 简介"></a>1.1 pthread 简介</h2><p>pthread 是一套通用的多线程的 API，可以在Unix / Linux / Windows 等系统跨平台使用，使用 C 语言编写，需要程序员自己管理线程的生命周期，使用难度较大，我们在 iOS 开发中几乎不使用 pthread，但是还是来可以了解一下的。</p>
<blockquote>
<p>引自 <a href="https://baike.baidu.com/item/Pthread" target="_blank" rel="noopener">百度百科</a><br>POSIX 线程（POSIX threads），简称 Pthreads，是线程的 POSIX 标准。该标准定义了创建和操纵线程的一整套 API。在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用 Pthreads 作为操作系统的线程。Windows 操作系统也有其移植版 pthreads-win32。</p>
<p>引自 <a href="https://zh.wikipedia.org/wiki/POSIX%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener">维基百科</a><br>POSIX 线程（英语：POSIX Threads，常被缩写 为 Pthreads）是 POSIX 的线程标准，定义了创建和操纵线程的一套 API。<br>实现 POSIX 线程标准的库常被称作 Pthreads，一般用于 Unix-like POSIX 系统，如 Linux、Solaris。但是 Microsoft Windows 上的实现也存在，例如直接使用 Windows API 实现的第三方库 pthreads-w32；而利用 Windows 的 SFU/SUA 子系统，则可以使用微软提供的一部分原生 POSIX API。</p>
</blockquote>
<h2 id="1-2-pthread-使用方法"><a href="#1-2-pthread-使用方法" class="headerlink" title="1.2 pthread 使用方法"></a>1.2 pthread 使用方法</h2><ol>
<li>首先要包含头文件<code>#import &lt;pthread.h&gt;</code></li>
<li>其次要创建线程，并开启线程执行任务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 1. 创建线程: 定义一个pthread_t类型变量</span><br><span class="line">pthread_t thread;</span><br><span class="line">// 2. 开启线程: 执行任务</span><br><span class="line">pthread_create(&amp;thread, NULL, run, NULL);</span><br><span class="line">// 3. 设置子线程的状态设置为 detached，该线程运行结束后会自动释放所有资源</span><br><span class="line">pthread_detach(thread);</span><br><span class="line"></span><br><span class="line">void * run(void *param)    // 新线程调用方法，里边为需要执行的任务</span><br><span class="line">&#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line"></span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pthread_create(&amp;thread, NULL, run, NULL);</code> 中各项参数含义：</li>
<li>第一个参数<code>&amp;thread</code>是线程对象，指向线程标识符的指针</li>
<li>第二个是线程属性，可赋值<code>NULL</code></li>
<li>第三个<code>run</code>表示指向函数的指针(run对应函数里是需要在新线程中执行的任务)</li>
<li>第四个是运行函数的参数，可赋值<code>NULL</code></li>
</ul>
<h2 id="1-3-pthread-其他相关方法"><a href="#1-3-pthread-其他相关方法" class="headerlink" title="1.3 pthread 其他相关方法"></a>1.3 pthread 其他相关方法</h2><ul>
<li><code>pthread_create()</code> 创建一个线程</li>
<li><code>pthread_exit()</code> 终止当前线程</li>
<li><code>pthread_cancel()</code> 中断另外一个线程的运行</li>
<li><code>pthread_join()</code> 阻塞当前的线程，直到另外一个线程运行结束</li>
<li><code>pthread_attr_init()</code> 初始化线程的属性</li>
<li><code>pthread_attr_setdetachstate()</code> 设置脱离状态的属性（决定这个线程在终止时是否可以被结合）</li>
<li><code>pthread_attr_getdetachstate()</code> 获取脱离状态的属性</li>
<li><code>pthread_attr_destroy()</code> 删除线程的属性</li>
<li><code>pthread_kill()</code> 向线程发送一个信号</li>
</ul>
<hr>
<h1 id="2-NSThread"><a href="#2-NSThread" class="headerlink" title="2. NSThread"></a>2. NSThread</h1><p>NSThread 是苹果官方提供的，使用起来比 pthread 更加面向对象，简单易用，可以直接操作线程对象。不过也需要需要程序员自己管理线程的生命周期(主要是创建)，我们在开发的过程中偶尔使用 NSThread。比如我们会经常调用<code>[NSThread currentThread]</code>来显示当前的进程信息。</p>
<p>下边我们说说 NSThread 如何使用。</p>
<h2 id="2-1-创建、启动线程"><a href="#2-1-创建、启动线程" class="headerlink" title="2.1 创建、启动线程"></a>2.1 创建、启动线程</h2><ul>
<li>先创建线程，再启动线程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 1. 创建线程</span><br><span class="line">NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];</span><br><span class="line">// 2. 启动线程</span><br><span class="line">[thread start];    // 线程一启动，就会在线程thread中执行self的run方法</span><br><span class="line"></span><br><span class="line">// 新线程调用方法，里边为需要执行的任务</span><br><span class="line">- (void)run &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建线程后自动启动线程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 1. 创建线程后自动启动线程</span><br><span class="line">[NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];</span><br><span class="line"></span><br><span class="line">// 新线程调用方法，里边为需要执行的任务</span><br><span class="line">- (void)run &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>隐式创建并启动线程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 1. 隐式创建并启动线程</span><br><span class="line">[self performSelectorInBackground:@selector(run) withObject:nil];</span><br><span class="line"></span><br><span class="line">// 新线程调用方法，里边为需要执行的任务</span><br><span class="line">- (void)run &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-线程相关用法"><a href="#2-2-线程相关用法" class="headerlink" title="2.2 线程相关用法"></a>2.2 线程相关用法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 获得主线程</span><br><span class="line">+ (NSThread *)mainThread;</span><br><span class="line"></span><br><span class="line">// 判断是否为主线程(对象方法)</span><br><span class="line">- (BOOL)isMainThread;</span><br><span class="line"></span><br><span class="line">// 判断是否为主线程(类方法)</span><br><span class="line">+ (BOOL)isMainThread;</span><br><span class="line"></span><br><span class="line">// 获得当前线程</span><br><span class="line">NSThread *current = [NSThread currentThread];</span><br><span class="line"></span><br><span class="line">// 线程的名字——setter方法</span><br><span class="line">- (void)setName:(NSString *)n;</span><br><span class="line"></span><br><span class="line">// 线程的名字——getter方法</span><br><span class="line">- (NSString *)name;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-线程状态控制方法"><a href="#2-3-线程状态控制方法" class="headerlink" title="2.3 线程状态控制方法"></a>2.3 线程状态控制方法</h2><ul>
<li>启动线程方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)start;</span><br><span class="line">// 线程进入就绪状态 -&gt; 运行状态。当线程任务执行完毕，自动进入死亡状态</span><br></pre></td></tr></table></figure>
<ul>
<li>阻塞（暂停）线!程方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (void)sleepUntilDate:(NSDate *)date;</span><br><span class="line">+ (void)sleepForTimeInterval:(NSTimeInterval)ti;</span><br><span class="line">// 线程进入阻塞状态</span><br></pre></td></tr></table></figure>
<ul>
<li>强制停止线程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (void)exit;</span><br><span class="line">// 线程进入死亡状态</span><br></pre></td></tr></table></figure>
<h2 id="2-4-线程之间的通信"><a href="#2-4-线程之间的通信" class="headerlink" title="2.4 线程之间的通信"></a>2.4 线程之间的通信</h2><p>在开发中，我们经常会在子线程进行耗时操作，操作结束后再回到主线程去刷新 UI。这就涉及到了子线程和主线程之间的通信。我们先来了解一下官方关于 NSThread 的线程间通信的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 在主线程上执行操作</span><br><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;</span><br><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray&lt;NSString *&gt; *)array;</span><br><span class="line">// equivalent to the first method with kCFRunLoopCommonModes</span><br><span class="line"></span><br><span class="line">// 在指定线程上执行操作</span><br><span class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array NS_AVAILABLE(10_5, 2_0);</span><br><span class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait NS_AVAILABLE(10_5, 2_0);</span><br><span class="line"></span><br><span class="line">// 在当前线程上执行操作，调用 NSObject 的 performSelector:相关方法</span><br><span class="line">- (id)performSelector:(SEL)aSelector;</span><br><span class="line">- (id)performSelector:(SEL)aSelector withObject:(id)object;</span><br><span class="line">- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;</span><br></pre></td></tr></table></figure>
<p>下面通过一个经典的下载图片 DEMO 来展示线程之间的通信。具体步骤如下：</p>
<ol>
<li>开启一个子线程，在子线程中下载图片。</li>
<li>回到主线程刷新 UI，将图片展示在 UIImageView 中。</li>
</ol>
<p>DEMO 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 创建一个线程下载图片</span><br><span class="line">*/</span><br><span class="line">- (void)downloadImageOnSubThread &#123;</span><br><span class="line">// 在创建的子线程中调用downloadImage下载图片</span><br><span class="line">[NSThread detachNewThreadSelector:@selector(downloadImage) toTarget:self withObject:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 下载图片，下载完之后回到主线程进行 UI 刷新</span><br><span class="line">*/</span><br><span class="line">- (void)downloadImage &#123;</span><br><span class="line">NSLog(@&quot;current thread -- %@&quot;, [NSThread currentThread]);</span><br><span class="line"></span><br><span class="line">// 1. 获取图片 imageUrl</span><br><span class="line">NSURL *imageUrl = [NSURL URLWithString:@&quot;https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-icon.jpg&quot;];</span><br><span class="line"></span><br><span class="line">// 2. 从 imageUrl 中读取数据(下载图片) -- 耗时操作</span><br><span class="line">NSData *imageData = [NSData dataWithContentsOfURL:imageUrl];</span><br><span class="line">// 通过二进制 data 创建 image</span><br><span class="line">UIImage *image = [UIImage imageWithData:imageData];</span><br><span class="line"></span><br><span class="line">// 3. 回到主线程进行图片赋值和界面刷新</span><br><span class="line">[self performSelectorOnMainThread:@selector(refreshOnMainThread:) withObject:image waitUntilDone:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 回到主线程进行图片赋值和界面刷新</span><br><span class="line">*/</span><br><span class="line">- (void)refreshOnMainThread:(UIImage *)image &#123;</span><br><span class="line">NSLog(@&quot;current thread -- %@&quot;, [NSThread currentThread]);</span><br><span class="line"></span><br><span class="line">// 赋值图片到imageview</span><br><span class="line">self.imageView.image = image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-5-NSThread-线程安全和线程同步"><a href="#2-5-NSThread-线程安全和线程同步" class="headerlink" title="2.5 NSThread 线程安全和线程同步"></a>2.5 NSThread 线程安全和线程同步</h2><p><strong>线程安全</strong>：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<p>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。</p>
<p><strong>线程同步</strong>：可理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。</p>
<p>举个简单例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清(操作冲突)。等一个人说完(一个线程结束操作)，另一个再说(另一个线程再开始操作)。</p>
<p>下面，我们模拟火车票售卖的方式，实现 NSThread 线程安全和解决线程同步问题。</p>
<p>场景：总共有50张火车票，有两个售卖火车票的窗口，一个是北京火车票售卖窗口，另一个是上海火车票售卖窗口。两个窗口同时售卖火车票，卖完为止。</p>
<h3 id="2-5-1-NSThread-非线程安全"><a href="#2-5-1-NSThread-非线程安全" class="headerlink" title="2.5.1 NSThread 非线程安全"></a>2.5.1 NSThread 非线程安全</h3><p>先来看看不考虑线程安全的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 初始化火车票数量、卖票窗口(非线程安全)、并开始卖票</span><br><span class="line">*/</span><br><span class="line">- (void)initTicketStatusNotSave &#123;</span><br><span class="line">// 1. 设置剩余火车票为 50</span><br><span class="line">self.ticketSurplusCount = 50;</span><br><span class="line"></span><br><span class="line">// 2. 设置北京火车票售卖窗口的线程</span><br><span class="line">self.ticketSaleWindow1 = [[NSThread alloc]initWithTarget:self selector:@selector(saleTicketNotSafe) object:nil];</span><br><span class="line">self.ticketSaleWindow1.name = @&quot;北京火车票售票窗口&quot;;</span><br><span class="line"></span><br><span class="line">// 3. 设置上海火车票售卖窗口的线程</span><br><span class="line">self.ticketSaleWindow2 = [[NSThread alloc]initWithTarget:self selector:@selector(saleTicketNotSafe) object:nil];</span><br><span class="line">self.ticketSaleWindow2.name = @&quot;上海火车票售票窗口&quot;;</span><br><span class="line"></span><br><span class="line">// 4. 开始售卖火车票</span><br><span class="line">[self.ticketSaleWindow1 start];</span><br><span class="line">[self.ticketSaleWindow2 start];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 售卖火车票(非线程安全)</span><br><span class="line">*/</span><br><span class="line">- (void)saleTicketNotSafe &#123;</span><br><span class="line">while (1) &#123;</span><br><span class="line">//如果还有票，继续售卖</span><br><span class="line">if (self.ticketSurplusCount &gt; 0) &#123;</span><br><span class="line">self.ticketSurplusCount --;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%ld 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread].name]);</span><br><span class="line">[NSThread sleepForTimeInterval:0.2];</span><br><span class="line">&#125;</span><br><span class="line">//如果已卖完，关闭售票窗口</span><br><span class="line">else &#123;</span><br><span class="line">NSLog(@&quot;所有火车票均已售完&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后部分结果为：</p>
<p><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-NotSave.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-NotSave.png" alt="YSC-phread-NSThread-demo-NotSave.png"></a></p>
<p>可以看到在不考虑线程安全的情况下，得到票数是错乱的，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。</p>
<h3 id="2-5-2-NSThread-线程安全"><a href="#2-5-2-NSThread-线程安全" class="headerlink" title="2.5.2 NSThread 线程安全"></a>2.5.2 NSThread 线程安全</h3><p>线程安全解决方案：可以给线程加锁，在一个线程执行该操作的时候，不允许其他线程进行操作。iOS 实现线程加锁有很多种方式。@synchronized、 NSLock、NSRecursiveLock、NSCondition、NSConditionLock、pthread_mutex、dispatch_semaphore、OSSpinLock、atomic(property) set/ge等等各种方式。为了简单起见，这里不对各种锁的解决方案和性能做分析，只用最简单的<code>@synchronized</code>来保证线程安全，从而解决线程同步问题。</p>
<p>考虑线程安全的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 初始化火车票数量、卖票窗口(线程安全)、并开始卖票</span><br><span class="line">*/</span><br><span class="line">- (void)initTicketStatusSave &#123;</span><br><span class="line">// 1. 设置剩余火车票为 50</span><br><span class="line">self.ticketSurplusCount = 50;</span><br><span class="line"></span><br><span class="line">// 2. 设置北京火车票售卖窗口的线程</span><br><span class="line">self.ticketSaleWindow1 = [[NSThread alloc]initWithTarget:self selector:@selector(saleTicketSafe) object:nil];</span><br><span class="line">self.ticketSaleWindow1.name = @&quot;北京火车票售票窗口&quot;;</span><br><span class="line"></span><br><span class="line">// 3. 设置上海火车票售卖窗口的线程</span><br><span class="line">self.ticketSaleWindow2 = [[NSThread alloc]initWithTarget:self selector:@selector(saleTicketSafe) object:nil];</span><br><span class="line">self.ticketSaleWindow2.name = @&quot;上海火车票售票窗口&quot;;</span><br><span class="line"></span><br><span class="line">// 4. 开始售卖火车票</span><br><span class="line">[self.ticketSaleWindow1 start];</span><br><span class="line">[self.ticketSaleWindow2 start];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 售卖火车票(线程安全)</span><br><span class="line">*/</span><br><span class="line">- (void)saleTicketSafe &#123;</span><br><span class="line">while (1) &#123;</span><br><span class="line">// 互斥锁</span><br><span class="line">@synchronized (self) &#123;</span><br><span class="line">//如果还有票，继续售卖</span><br><span class="line">if (self.ticketSurplusCount &gt; 0) &#123;</span><br><span class="line">self.ticketSurplusCount --;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%ld 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread].name]);</span><br><span class="line">[NSThread sleepForTimeInterval:0.2];</span><br><span class="line">&#125;</span><br><span class="line">//如果已卖完，关闭售票窗口</span><br><span class="line">else &#123;</span><br><span class="line">NSLog(@&quot;所有火车票均已售完&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后结果为：</p>
<p><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-Save.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-Save.png" alt="YSC-phread-NSThread-demo-Save.png"></a></p>
<p>省略一部分结果图。。。</p>
<p><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-Save1.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-Save1.png" alt="YSC-phread-NSThread-demo-Save1.png"></a></p>
<p>可以看出，在考虑了线程安全的情况下，加锁之后，得到的票数是正确的，没有出现混乱的情况。我们也就解决了多个线程同步的问题。</p>
<h2 id="2-6-线程的状态转换"><a href="#2-6-线程的状态转换" class="headerlink" title="2.6 线程的状态转换"></a>2.6 线程的状态转换</h2><p>当我们新建一条线程<code>NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];</code>，在内存中的表现为：</p>
<p><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-StatusChange.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-StatusChange.png" alt="YSC-phread-NSThread-demo-StatusChange.png"></a></p>
<p>当调用<code>[thread start];</code>后，系统把线程对象放入可调度线程池中，线程对象进入就绪状态，如下图所示。</p>
<p><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-StatusChange1.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-StatusChange1.png" alt="YSC-phread-NSThread-demo-StatusChange1.png"></a></p>
<p>当然，可调度线程池中，会有其他的线程对象，如下图所示。在这里我们只关心左边的线程对象。</p>
<p><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-StatusChange2.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-StatusChange2.png" alt="YSC-phread-NSThread-demo-StatusChange2.png"></a></p>
<p><strong>下边我们来看看当前线程的状态转换。</strong></p>
<ul>
<li>如果CPU现在调度当前线程对象，则当前线程对象进入运行状态，如果CPU调度其他线程对象，则当前线程对象回到就绪状态。</li>
<li>如果CPU在运行当前线程对象的时候调用了sleep方法\等待同步锁，则当前线程对象就进入了阻塞状态，等到sleep到时\得到同步锁，则回到就绪状态。</li>
<li>如果CPU在运行当前线程对象的时候线程任务执行完毕\异常强制退出，则当前线程对象进入死亡状态。</li>
</ul>
<p>只看文字可能不太好理解，具体当前线程对象的状态变化如下图所示。</p>
<p><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-StatusChange3.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-StatusChange3.png" alt="YSC-phread-NSThread-demo-StatusChange3.png"></a></p>
<hr>
<p>iOS多线程详尽总结系列文章：</p>
<ul>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-pthread-and-NSThread.html" target="_blank" rel="noopener">iOS多线程：『pthread、NSThread』详尽总结</a></li>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-GCD.html" target="_blank" rel="noopener">iOS多线程：『GCD』详解总结</a></li>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-NSOperation.html" target="_blank" rel="noopener">iOS多线程：『NSOperation』详解总结</a></li>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-RunLoop.html" target="_blank" rel="noopener">iOS多线程：『RunLoop』详解总结</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/NSOperation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/NSOperation/" itemprop="url">
                  NSOperation
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 12:17:42 / 修改时间：14:29:19" itemprop="dateCreated datePublished" datetime="2018-09-17T12:17:42+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/多线程/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[转自 <a href="https://bujige.net/" target="_blank" rel="noopener">『不羁阁』 | 行走的少年郎 - 博客</a></p>
<p><a href="https://bujige.net/blog/iOS-Complete-learning-NSOperation.html" target="_blank" rel="noopener">**](https://bujige.net/)</a></p>
<p><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-background.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-background.png" alt="img"></a></p>
<blockquote>
<p>本文用来介绍 iOS 多线程中 NSOperation、NSOperationQueue 的相关知识以及使用方法。<br>通过本文，您将了解到：<br><strong>NSOperation、NSOperationQueue 简介</strong>、<strong>操作和操作队列</strong>、<strong>使用步骤和基本使用方法</strong>、<strong>控制串行/并发执行</strong>、<strong>NSOperation 操作依赖和优先级</strong>、<strong>线程间的通信</strong>、<strong>线程同步和线程安全</strong>，以及 <strong>NSOperation、NSOperationQueue 常用属性和方法归纳</strong>。</p>
<p>文中 Demo 我已放在了 Github 上，Demo 链接：<a href="https://github.com/bujige/YSC-NSOperation-demo" target="_blank" rel="noopener">传送门</a></p>
</blockquote>
<h1 id="1-NSOperation、NSOperationQueue-简介"><a href="#1-NSOperation、NSOperationQueue-简介" class="headerlink" title="1. NSOperation、NSOperationQueue 简介"></a>1. NSOperation、NSOperationQueue 简介</h1><p>NSOperation、NSOperationQueue 是苹果提供给我们的一套多线程解决方案。实际上 NSOperation、NSOperationQueue 是基于 GCD 更高一层的封装，完全面向对象。但是比 GCD 更简单易用、代码可读性也更高。</p>
<p><strong>为什么要使用 NSOperation、NSOperationQueue？</strong></p>
<ol>
<li>可添加完成的代码块，在操作完成后执行。</li>
<li>添加操作之间的依赖关系，方便的控制执行顺序。</li>
<li>设定操作执行的优先级。</li>
<li>可以很方便的取消一个操作的执行。</li>
<li>使用 KVO 观察对操作执行状态的更改：isExecuteing、isFinished、isCancelled。</li>
</ol>
<h1 id="2-NSOperation、NSOperationQueue-操作和操作队列"><a href="#2-NSOperation、NSOperationQueue-操作和操作队列" class="headerlink" title="2. NSOperation、NSOperationQueue 操作和操作队列"></a>2. NSOperation、NSOperationQueue 操作和操作队列</h1><p>既然是基于 GCD 的更高一层的封装。那么，GCD 中的一些概念同样适用于 NSOperation、NSOperationQueue。在 NSOperation、NSOperationQueue 中也有类似的<strong>任务（操作）</strong>和<strong>队列（操作队列）</strong>的概念。</p>
<ul>
<li>操作（Operation）：<ul>
<li>执行操作的意思，换句话说就是你在线程中执行的那段代码。</li>
<li>在 GCD 中是放在 block 中的。在 NSOperation 中，我们使用 NSOperation 子类 <strong>NSInvocationOperation</strong>、<strong>NSBlockOperation</strong>，或者<strong>自定义子类</strong>来封装操作。</li>
</ul>
</li>
<li>操作队列（Operation Queues）：<ul>
<li>这里的队列指操作队列，即用来存放操作的队列。不同于 GCD 中的调度队列 FIFO（先进先出）的原则。NSOperationQueue 对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的<strong>开始执行顺序</strong>（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。</li>
<li>操作队列通过设置<strong>最大并发操作数（maxConcurrentOperationCount）</strong>来控制并发、串行。</li>
<li>NSOperationQueue 为我们提供了两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。</li>
</ul>
</li>
</ul>
<h1 id="3-NSOperation、NSOperationQueue-使用步骤"><a href="#3-NSOperation、NSOperationQueue-使用步骤" class="headerlink" title="3. NSOperation、NSOperationQueue 使用步骤"></a>3. NSOperation、NSOperationQueue 使用步骤</h1><p>NSOperation 需要配合 NSOperationQueue 来实现多线程。因为默认情况下，NSOperation 单独使用时系统同步执行操作，配合 NSOperationQueue 我们能更好的实现异步执行。</p>
<p>NSOperation 实现多线程的使用步骤分为三步：</p>
<ol>
<li>创建操作：先将需要执行的操作封装到一个 NSOperation 对象中。</li>
<li>创建队列：创建 NSOperationQueue 对象。</li>
<li>将操作加入到队列中：将 NSOperation 对象添加到 NSOperationQueue 对象中。</li>
</ol>
<p>之后呢，系统就会自动将 NSOperationQueue 中的 NSOperation 取出来，在新线程中执行操作。</p>
<p>下面我们来学习下 NSOperation 和 NSOperationQueue 的基本使用。</p>
<h1 id="4-NSOperation-和-NSOperationQueue-基本使用"><a href="#4-NSOperation-和-NSOperationQueue-基本使用" class="headerlink" title="4. NSOperation 和 NSOperationQueue 基本使用"></a>4. NSOperation 和 NSOperationQueue 基本使用</h1><h2 id="4-1-创建操作"><a href="#4-1-创建操作" class="headerlink" title="4.1 创建操作"></a>4.1 创建操作</h2><p>NSOperation 是个抽象类，不能用来封装操作。我们只有使用它的子类来封装操作。我们有三种方式来封装操作。</p>
<ol>
<li>使用子类 NSInvocationOperation</li>
<li>使用子类 NSBlockOperation</li>
<li>自定义继承自 NSOperation 的子类，通过实现内部相应的方法来封装操作。</li>
</ol>
<p>在不使用 NSOperationQueue，单独使用 NSOperation 的情况下系统同步执行操作，下面我们学习以下操作的三种创建方式。</p>
<h3 id="4-1-1-使用子类-NSInvocationOperation"><a href="#4-1-1-使用子类-NSInvocationOperation" class="headerlink" title="4.1.1 使用子类 NSInvocationOperation"></a>4.1.1 使用子类 <code>NSInvocationOperation</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用子类 NSInvocationOperation</span><br><span class="line"> */</span><br><span class="line">- (void)useInvocationOperation &#123;</span><br><span class="line"></span><br><span class="line">    // 1.创建 NSInvocationOperation 对象</span><br><span class="line">    NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task1) object:nil];</span><br><span class="line"></span><br><span class="line">    // 2.调用 start 方法开始执行操作</span><br><span class="line">    [op start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 任务1</span><br><span class="line"> */</span><br><span class="line">- (void)task1 &#123;</span><br><span class="line">    for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">        NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result01.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result01.png" alt="img"></a></p>
</blockquote>
<ul>
<li>可以看到：在没有使用 NSOperationQueue、在主线程中单独使用使用子类 NSInvocationOperation 执行一个操作的情况下，操作是在当前线程执行的，并没有开启新线程。</li>
</ul>
<p>如果在其他线程中执行操作，则打印结果为其他线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 在其他线程使用子类 NSInvocationOperation</span><br><span class="line">[NSThread detachNewThreadSelector:@selector(useInvocationOperation) toTarget:self withObject:nil];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result02.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result02.png" alt="img"></a></p>
</blockquote>
<ul>
<li>可以看到：在其他线程中单独使用子类 NSInvocationOperation，操作是在当前调用的其他线程执行的，并没有开启新线程。</li>
</ul>
<p>下边再来看看 NSBlockOperation。</p>
<h3 id="4-1-2-使用子类-NSBlockOperation"><a href="#4-1-2-使用子类-NSBlockOperation" class="headerlink" title="4.1.2 使用子类 NSBlockOperation"></a>4.1.2 使用子类 <code>NSBlockOperation</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用子类 NSBlockOperation</span><br><span class="line"> */</span><br><span class="line">- (void)useBlockOperation &#123;</span><br><span class="line"></span><br><span class="line">    // 1.创建 NSBlockOperation 对象</span><br><span class="line">    NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 2.调用 start 方法开始执行操作</span><br><span class="line">    [op start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result03.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result03.png" alt="img"></a></p>
</blockquote>
<ul>
<li>可以看到：在没有使用 NSOperationQueue、在主线程中单独使用 NSBlockOperation 执行一个操作的情况下，操作是在当前线程执行的，并没有开启新线程。</li>
</ul>
<blockquote>
<p>注意：和上边 NSInvocationOperation 使用一样。因为代码是在主线程中调用的，所以打印结果为主线程。如果在其他线程中执行操作，则打印结果为其他线程。</p>
</blockquote>
<p>但是，NSBlockOperation 还提供了一个方法 <code>addExecutionBlock:</code>，通过 <code>addExecutionBlock:</code> 就可以为 NSBlockOperation 添加额外的操作。这些操作（包括 blockOperationWithBlock 中的操作）可以在不同的线程中同时（并发）执行。只有当所有相关的操作已经完成执行时，才视为完成。</p>
<p>如果添加的操作多的话，<code>blockOperationWithBlock:</code> 中的操作也可能会在其他线程（非当前线程）中执行，这是由系统决定的，并不是说添加到 <code>blockOperationWithBlock:</code> 中的操作一定会在当前线程中执行。（可以使用 <code>addExecutionBlock:</code> 多添加几个操作试试）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用子类 NSBlockOperation</span><br><span class="line"> * 调用方法 AddExecutionBlock:</span><br><span class="line"> */</span><br><span class="line">- (void)useBlockOperationAddExecutionBlock &#123;</span><br><span class="line"></span><br><span class="line">    // 1.创建 NSBlockOperation 对象</span><br><span class="line">    NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 2.添加额外的操作</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;5---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;6---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;7---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;8---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 3.调用 start 方法开始执行操作</span><br><span class="line">    [op start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result04.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result04.png" alt="img"></a></p>
</blockquote>
<ul>
<li>可以看出：使用子类 <code>NSBlockOperation</code>，并调用方法 <code>AddExecutionBlock:</code> 的情况下，<code>blockOperationWithBlock:</code>方法中的操作 和 <code>addExecutionBlock:</code> 中的操作是在不同的线程中异步执行的。而且，这次执行结果中 <code>blockOperationWithBlock:</code>方法中的操作也不是在当前线程（主线程）中执行的。从而印证了<code>blockOperationWithBlock:</code> 中的操作也可能会在其他线程（非当前线程）中执行。</li>
</ul>
<p>一般情况下，如果一个 NSBlockOperation 对象封装了多个操作。NSBlockOperation 是否开启新线程，取决于操作的个数。如果添加的操作的个数多，就会自动开启新线程。当然开启的线程数是由系统来决定的。</p>
<h3 id="4-1-3-使用自定义继承自-NSOperation-的子类"><a href="#4-1-3-使用自定义继承自-NSOperation-的子类" class="headerlink" title="4.1.3 使用自定义继承自 NSOperation 的子类"></a>4.1.3 使用自定义继承自 NSOperation 的子类</h3><p>如果使用子类 NSInvocationOperation、NSBlockOperation 不能满足日常需求，我们可以使用自定义继承自 NSOperation 的子类。可以通过重写 <code>main</code> 或者 <code>start</code> 方法 来定义自己的 NSOperation 对象。重写<code>main</code>方法比较简单，我们不需要管理操作的状态属性 <code>isExecuting</code> 和 <code>isFinished</code>。当 <code>main</code> 执行完返回的时候，这个操作就结束了。</p>
<p>先定义一个继承自 NSOperation 的子类，重写<code>main</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// YSCOperation.h 文件</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface YSCOperation : NSOperation</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// YSCOperation.m 文件</span><br><span class="line">#import &quot;YSCOperation.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation YSCOperation</span><br><span class="line"></span><br><span class="line">- (void)main &#123;</span><br><span class="line">    if (!self.isCancelled) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>然后使用的时候导入头文件<code>YSCOperation.h</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用自定义继承自 NSOperation 的子类</span><br><span class="line"> */</span><br><span class="line">- (void)useCustomOperation &#123;</span><br><span class="line">    // 1.创建 YSCOperation 对象</span><br><span class="line">    YSCOperation *op = [[YSCOperation alloc] init];</span><br><span class="line">    // 2.调用 start 方法开始执行操作</span><br><span class="line">    [op start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result05.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result05.png" alt="img"></a></p>
</blockquote>
<ul>
<li>可以看出：在没有使用 NSOperationQueue、在主线程单独使用自定义继承自 NSOperation 的子类的情况下，是在主线程执行操作，并没有开启新线程。</li>
</ul>
<p>下边我们来讲讲 NSOperationQueue 的创建。</p>
<h2 id="4-2-创建队列"><a href="#4-2-创建队列" class="headerlink" title="4.2 创建队列"></a>4.2 创建队列</h2><p>NSOperationQueue 一共有两种队列：主队列、自定义队列。其中自定义队列同时包含了串行、并发功能。下边是主队列、自定义队列的基本创建方法和特点。</p>
<ul>
<li>主队列<ul>
<li>凡是添加到主队列中的操作，都会放到主线程中执行。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 主队列获取方法</span><br><span class="line">NSOperationQueue *queue = [NSOperationQueue mainQueue];</span><br></pre></td></tr></table></figure>
<ul>
<li>自定义队列（非主队列）<ul>
<li>添加到这种队列中的操作，就会自动放到子线程中执行。</li>
<li>同时包含了：串行、并发功能。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 自定义队列创建方法</span><br><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br></pre></td></tr></table></figure>
<h2 id="4-3-将操作加入到队列中"><a href="#4-3-将操作加入到队列中" class="headerlink" title="4.3 将操作加入到队列中"></a>4.3 将操作加入到队列中</h2><p>上边我们说到 NSOperation 需要配合 NSOperationQueue 来实现多线程。</p>
<p>那么我们需要将创建好的操作加入到队列中去。总共有两种方法：</p>
<ol>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)addOperation:(NSOperation *)op;</span><br></pre></td></tr></table></figure>
<ul>
<li>需要先创建操作，再将创建好的操作加入到创建好的队列中去。</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用 addOperation: 将操作加入到操作队列中</span><br><span class="line"> */</span><br><span class="line">- (void)addOperationToQueue &#123;</span><br><span class="line"></span><br><span class="line">    // 1.创建队列</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line"></span><br><span class="line">    // 2.创建操作</span><br><span class="line">    // 使用 NSInvocationOperation 创建操作1</span><br><span class="line">    NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task1) object:nil];</span><br><span class="line"></span><br><span class="line">    // 使用 NSInvocationOperation 创建操作2</span><br><span class="line">    NSInvocationOperation *op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task2) object:nil];</span><br><span class="line"></span><br><span class="line">    // 使用 NSBlockOperation 创建操作3</span><br><span class="line">    NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op3 addExecutionBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 3.使用 addOperation: 添加所有操作到队列中</span><br><span class="line">    [queue addOperation:op1]; // [op1 start]</span><br><span class="line">    [queue addOperation:op2]; // [op2 start]</span><br><span class="line">    [queue addOperation:op3]; // [op3 start]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result06.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result06.png" alt="img"></a></p>
</blockquote>
<ul>
<li>可以看出：使用 NSOperation 子类创建操作，并使用 <code>addOperation:</code> 将操作加入到操作队列后能够开启新线程，进行并发执行。</li>
</ul>
<ol>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)addOperationWithBlock:(void (^)(void))block;</span><br></pre></td></tr></table></figure>
<ul>
<li>无需先创建操作，在 block 中添加操作，直接将包含操作的 block 加入到队列中。</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用 addOperationWithBlock: 将操作加入到操作队列中</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">- (void)addOperationWithBlockToQueue &#123;</span><br><span class="line">    // 1.创建队列</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line"></span><br><span class="line">    // 2.使用 addOperationWithBlock: 添加操作到队列中</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result07.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result07.png" alt="img"></a></p>
</blockquote>
<ul>
<li>可以看出：使用 addOperationWithBlock: 将操作加入到操作队列后能够开启新线程，进行并发执行。</li>
</ul>
<h1 id="5-NSOperationQueue-控制串行执行、并发执行"><a href="#5-NSOperationQueue-控制串行执行、并发执行" class="headerlink" title="5. NSOperationQueue 控制串行执行、并发执行"></a>5. NSOperationQueue 控制串行执行、并发执行</h1><p>之前我们说过，NSOperationQueue 创建的自定义队列同时具有串行、并发功能，上边我们演示了并发功能，那么他的串行功能是如何实现的？</p>
<p>这里有个关键属性 <code>maxConcurrentOperationCount</code>，叫做<strong>最大并发操作数</strong>。用来控制一个特定队列中可以有多少个操作同时参与并发执行。</p>
<blockquote>
<p>注意：这里 <code>maxConcurrentOperationCount</code> 控制的不是并发线程的数量，而是一个队列中同时能并发执行的最大操作数。而且一个操作也并非只能在一个线程中运行。</p>
</blockquote>
<ul>
<li><p>最大并发操作数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxConcurrentOperationCount</span><br></pre></td></tr></table></figure>
<ul>
<li><code>maxConcurrentOperationCount</code> 默认情况下为-1，表示不进行限制，可进行并发执行。</li>
<li><code>maxConcurrentOperationCount</code> 为1时，队列为串行队列。只能串行执行。</li>
<li><code>maxConcurrentOperationCount</code> 大于1时，队列为并发队列。操作并发执行，当然这个值不应超过系统限制，即使自己设置一个很大的值，系统也会自动调整为 min{自己设定的值，系统设定的默认最大值}。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 设置 MaxConcurrentOperationCount（最大并发操作数）</span><br><span class="line"> */</span><br><span class="line">- (void)setMaxConcurrentOperationCount &#123;</span><br><span class="line"></span><br><span class="line">    // 1.创建队列</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line"></span><br><span class="line">    // 2.设置最大并发操作数</span><br><span class="line">    queue.maxConcurrentOperationCount = 1; // 串行队列</span><br><span class="line">// queue.maxConcurrentOperationCount = 2; // 并发队列</span><br><span class="line">// queue.maxConcurrentOperationCount = 8; // 并发队列</span><br><span class="line"></span><br><span class="line">    // 3.添加操作</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最大并发操作数为1 输出结果：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result08.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result08.png" alt="img"></a><br>最大并发操作数为2 输出结果：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result09.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result09.png" alt="img"></a></p>
</blockquote>
<ul>
<li>可以看出：当最大并发操作数为1时，操作是按顺序串行执行的，并且一个操作完成之后，下一个操作才开始执行。当最大操作并发数为2时，操作是并发执行的，可以同时执行两个操作。而开启线程数量是由系统决定的，不需要我们来管理。</li>
</ul>
<p>这样看来，是不是比 GCD 还要简单了许多？</p>
<h1 id="6-NSOperation-操作依赖"><a href="#6-NSOperation-操作依赖" class="headerlink" title="6. NSOperation 操作依赖"></a>6. NSOperation 操作依赖</h1><p>NSOperation、NSOperationQueue 最吸引人的地方是它能添加操作之间的依赖关系。通过操作依赖，我们可以很方便的控制操作之间的执行先后顺序。NSOperation 提供了3个接口供我们管理和查看依赖。</p>
<ul>
<li><code>- (void)addDependency:(NSOperation *)op;</code> 添加依赖，使当前操作依赖于操作 op 的完成。</li>
<li><code>- (void)removeDependency:(NSOperation *)op;</code> 移除依赖，取消当前操作对操作 op 的依赖。</li>
<li><code>@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies;</code> 在当前操作开始执行之前完成执行的所有操作对象数组。</li>
</ul>
<p>当然，我们经常用到的还是添加依赖操作。现在考虑这样的需求，比如说有 A、B 两个操作，其中 A 执行完操作，B 才能执行操作。</p>
<p>如果使用依赖来处理的话，那么就需要让操作 B 依赖于操作 A。具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 操作依赖</span><br><span class="line"> * 使用方法：addDependency:</span><br><span class="line"> */</span><br><span class="line">- (void)addDependency &#123;</span><br><span class="line"></span><br><span class="line">    // 1.创建队列</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line"></span><br><span class="line">    // 2.创建操作</span><br><span class="line">    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 3.添加依赖</span><br><span class="line">    [op2 addDependency:op1]; // 让op2 依赖于 op1，则先执行op1，在执行op2</span><br><span class="line"></span><br><span class="line">    // 4.添加操作到队列中</span><br><span class="line">    [queue addOperation:op1];</span><br><span class="line">    [queue addOperation:op2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result10.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result10.png" alt="img"></a></p>
</blockquote>
<ul>
<li>可以看到：通过添加操作依赖，无论运行几次，其结果都是 op1 先执行，op2 后执行。</li>
</ul>
<h1 id="7-NSOperation-优先级"><a href="#7-NSOperation-优先级" class="headerlink" title="7. NSOperation 优先级"></a>7. NSOperation 优先级</h1><p>NSOperation 提供了<code>queuePriority</code>（优先级）属性，<code>queuePriority</code>属性适用于同一操作队列中的操作，不适用于不同操作队列中的操作。默认情况下，所有新创建的操作对象优先级都是<code>NSOperationQueuePriorityNormal</code>。但是我们可以通过<code>setQueuePriority:</code>方法来改变当前操作在同一队列中的执行优先级。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 优先级的取值</span><br><span class="line">typedef NS_ENUM(NSInteger, NSOperationQueuePriority) &#123;</span><br><span class="line">    NSOperationQueuePriorityVeryLow = -8L,</span><br><span class="line">    NSOperationQueuePriorityLow = -4L,</span><br><span class="line">    NSOperationQueuePriorityNormal = 0,</span><br><span class="line">    NSOperationQueuePriorityHigh = 4,</span><br><span class="line">    NSOperationQueuePriorityVeryHigh = 8</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上边我们说过：对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的<strong>开始执行顺序</strong>（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。</p>
<p><strong>那么，什么样的操作才是进入就绪状态的操作呢？</strong></p>
<ul>
<li>当一个操作的所有依赖都已经完成时，操作对象通常会进入准备就绪状态，等待执行。</li>
</ul>
<p>举个例子，现在有4个优先级都是 <code>NSOperationQueuePriorityNormal</code>（默认级别）的操作：op1，op2，op3，op4。其中 op3 依赖于 op2，op2 依赖于 op1，即 op3 -&gt; op2 -&gt; op1。现在将这4个操作添加到队列中并发执行。</p>
<ul>
<li>因为 op1 和 op4 都没有需要依赖的操作，所以在 op1，op4 执行之前，就是出于准备就绪状态的操作。</li>
<li>而 op3 和 op2 都有依赖的操作（op3 依赖于 op2，op2 依赖于 op1），所以 op3 和 op2 都不是准备就绪状态下的操作。</li>
</ul>
<p>理解了进入就绪状态的操作，那么我们就理解了<code>queuePriority</code> 属性的作用对象。</p>
<ul>
<li><code>queuePriority</code> 属性决定了<strong>进入准备就绪状态下的操作</strong>之间的开始执行顺序。并且，优先级不能取代依赖关系。</li>
<li>如果一个队列中既包含高优先级操作，又包含低优先级操作，并且两个操作都已经准备就绪，那么队列先执行高优先级操作。比如上例中，如果 op1 和 op4 是不同优先级的操作，那么就会先执行优先级高的操作。</li>
<li>如果，一个队列中既包含了准备就绪状态的操作，又包含了未准备就绪的操作，未准备就绪的操作优先级比准备就绪的操作优先级高。那么，虽然准备就绪的操作优先级低，也会优先执行。优先级不能取代依赖关系。如果要控制操作间的启动顺序，则必须使用依赖关系。</li>
</ul>
<h1 id="8-NSOperation、NSOperationQueue-线程间的通信"><a href="#8-NSOperation、NSOperationQueue-线程间的通信" class="headerlink" title="8. NSOperation、NSOperationQueue 线程间的通信"></a>8. NSOperation、NSOperationQueue 线程间的通信</h1><p>在 iOS 开发过程中，我们一般在主线程里边进行 UI 刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线程间通信</span><br><span class="line"> */</span><br><span class="line">- (void)communication &#123;</span><br><span class="line"></span><br><span class="line">    // 1.创建队列</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc]init];</span><br><span class="line"></span><br><span class="line">    // 2.添加操作</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        // 异步进行耗时操作</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 回到主线程</span><br><span class="line">        [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">            // 进行一些 UI 刷新等操作</span><br><span class="line">            for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">                [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">                NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result11.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result11.png" alt="img"></a></p>
</blockquote>
<ul>
<li>可以看到：通过线程间的通信，先在其他线程中执行操作，等操作执行完了之后再回到主线程执行主线程的相应操作。</li>
</ul>
<h1 id="9-NSOperation、NSOperationQueue-线程同步和线程安全"><a href="#9-NSOperation、NSOperationQueue-线程同步和线程安全" class="headerlink" title="9. NSOperation、NSOperationQueue 线程同步和线程安全"></a>9. NSOperation、NSOperationQueue 线程同步和线程安全</h1><ul>
<li><strong>线程安全</strong>：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。<br>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。</li>
<li><strong>线程同步</strong>：可理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。</li>
</ul>
<p>举个简单例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清(操作冲突)。等一个人说完(一个线程结束操作)，另一个再说(另一个线程再开始操作)。</p>
<p>下面，我们模拟火车票售卖的方式，实现 NSOperation 线程安全和解决线程同步问题。<br>场景：总共有50张火车票，有两个售卖火车票的窗口，一个是北京火车票售卖窗口，另一个是上海火车票售卖窗口。两个窗口同时售卖火车票，卖完为止。</p>
<h2 id="9-1-NSOperation、NSOperationQueue-非线程安全"><a href="#9-1-NSOperation、NSOperationQueue-非线程安全" class="headerlink" title="9.1 NSOperation、NSOperationQueue 非线程安全"></a>9.1 NSOperation、NSOperationQueue 非线程安全</h2><p>先来看看不考虑线程安全的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 非线程安全：不使用 NSLock</span><br><span class="line"> * 初始化火车票数量、卖票窗口(非线程安全)、并开始卖票</span><br><span class="line"> */</span><br><span class="line">- (void)initTicketStatusNotSave &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程</span><br><span class="line"></span><br><span class="line">    self.ticketSurplusCount = 50;</span><br><span class="line"></span><br><span class="line">    // 1.创建 queue1,queue1 代表北京火车票售卖窗口</span><br><span class="line">    NSOperationQueue *queue1 = [[NSOperationQueue alloc] init];</span><br><span class="line">    queue1.maxConcurrentOperationCount = 1;</span><br><span class="line"></span><br><span class="line">    // 2.创建 queue2,queue2 代表上海火车票售卖窗口</span><br><span class="line">    NSOperationQueue *queue2 = [[NSOperationQueue alloc] init];</span><br><span class="line">    queue2.maxConcurrentOperationCount = 1;</span><br><span class="line"></span><br><span class="line">    // 3.创建卖票操作 op1</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        [weakSelf saleTicketNotSafe];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 4.创建卖票操作 op2</span><br><span class="line">    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        [weakSelf saleTicketNotSafe];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 5.添加操作，开始卖票</span><br><span class="line">    [queue1 addOperation:op1];</span><br><span class="line">    [queue2 addOperation:op2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 售卖火车票(非线程安全)</span><br><span class="line"> */</span><br><span class="line">- (void)saleTicketNotSafe &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line"></span><br><span class="line">        if (self.ticketSurplusCount &gt; 0) &#123;</span><br><span class="line">            //如果还有票，继续售卖</span><br><span class="line">            self.ticketSurplusCount--;</span><br><span class="line">            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数:%d 窗口:%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]);</span><br><span class="line">            [NSThread sleepForTimeInterval:0.2];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            NSLog(@&quot;所有火车票均已售完&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result13.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result13.png" alt="img"></a><br>……<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result14.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result14.png" alt="img"></a></p>
</blockquote>
<ul>
<li>可以看到：在不考虑线程安全，不使用 NSLock 情况下，得到票数是错乱的，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。</li>
</ul>
<h2 id="9-2-NSOperation、NSOperationQueue-非线程安全"><a href="#9-2-NSOperation、NSOperationQueue-非线程安全" class="headerlink" title="9.2 NSOperation、NSOperationQueue 非线程安全"></a>9.2 NSOperation、NSOperationQueue 非线程安全</h2><p>线程安全解决方案：可以给线程加锁，在一个线程执行该操作的时候，不允许其他线程进行操作。iOS 实现线程加锁有很多种方式。@synchronized、 NSLock、NSRecursiveLock、NSCondition、NSConditionLock、pthread_mutex、dispatch_semaphore、OSSpinLock、atomic(property) set/ge等等各种方式。这里我们使用 NSLock 对象来解决线程同步问题。NSLock 对象可以通过进入锁时调用 lock 方法，解锁时调用 unlock 方法来保证线程安全。</p>
<p>考虑线程安全的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线程安全：使用 NSLock 加锁</span><br><span class="line"> * 初始化火车票数量、卖票窗口(线程安全)、并开始卖票</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">- (void)initTicketStatusSave &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程</span><br><span class="line"></span><br><span class="line">    self.ticketSurplusCount = 50;</span><br><span class="line"></span><br><span class="line">    self.lock = [[NSLock alloc] init];  // 初始化 NSLock 对象</span><br><span class="line"></span><br><span class="line">    // 1.创建 queue1,queue1 代表北京火车票售卖窗口</span><br><span class="line">    NSOperationQueue *queue1 = [[NSOperationQueue alloc] init];</span><br><span class="line">    queue1.maxConcurrentOperationCount = 1;</span><br><span class="line"></span><br><span class="line">    // 2.创建 queue2,queue2 代表上海火车票售卖窗口</span><br><span class="line">    NSOperationQueue *queue2 = [[NSOperationQueue alloc] init];</span><br><span class="line">    queue2.maxConcurrentOperationCount = 1;</span><br><span class="line"></span><br><span class="line">    // 3.创建卖票操作 op1</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        [weakSelf saleTicketSafe];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 4.创建卖票操作 op2</span><br><span class="line">    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        [weakSelf saleTicketSafe];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 5.添加操作，开始卖票</span><br><span class="line">    [queue1 addOperation:op1];</span><br><span class="line">    [queue2 addOperation:op2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 售卖火车票(线程安全)</span><br><span class="line"> */</span><br><span class="line">- (void)saleTicketSafe &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line"></span><br><span class="line">        // 加锁</span><br><span class="line">        [self.lock lock];</span><br><span class="line"></span><br><span class="line">        if (self.ticketSurplusCount &gt; 0) &#123;</span><br><span class="line">            //如果还有票，继续售卖</span><br><span class="line">            self.ticketSurplusCount--;</span><br><span class="line">            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数:%d 窗口:%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]);</span><br><span class="line">            [NSThread sleepForTimeInterval:0.2];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 解锁</span><br><span class="line">        [self.lock unlock];</span><br><span class="line"></span><br><span class="line">        if (self.ticketSurplusCount &lt;= 0) &#123;</span><br><span class="line">            NSLog(@&quot;所有火车票均已售完&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result15.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result15.png" alt="img"></a><br>……<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result16.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result16.png" alt="img"></a></p>
</blockquote>
<ul>
<li>可以看出：在考虑了线程安全，使用 NSLock 加锁、解锁机制的情况下，得到的票数是正确的，没有出现混乱的情况。我们也就解决了多个线程同步的问题。</li>
</ul>
<h1 id="10-NSOperation、NSOperationQueue-常用属性和方法归纳"><a href="#10-NSOperation、NSOperationQueue-常用属性和方法归纳" class="headerlink" title="10. NSOperation、NSOperationQueue 常用属性和方法归纳"></a>10. NSOperation、NSOperationQueue 常用属性和方法归纳</h1><h2 id="10-1-NSOperation-常用属性和方法"><a href="#10-1-NSOperation-常用属性和方法" class="headerlink" title="10.1 NSOperation 常用属性和方法"></a>10.1 NSOperation 常用属性和方法</h2><ol>
<li>取消操作方法<ul>
<li><code>- (void)cancel;</code> 可取消操作，实质是标记 isCancelled 状态。</li>
</ul>
</li>
<li>判断操作状态方法<ul>
<li><code>- (BOOL)isFinished;</code> 判断操作是否已经结束。</li>
<li><code>- (BOOL)isCancelled;</code> 判断操作是否已经标记为取消。</li>
<li><code>- (BOOL)isExecuting;</code> 判断操作是否正在在运行。</li>
<li><code>- (BOOL)isReady;</code> 判断操作是否处于准备就绪状态，这个值和操作的依赖关系相关。</li>
</ul>
</li>
<li>操作同步<ul>
<li><code>- (void)waitUntilFinished;</code> 阻塞当前线程，直到该操作结束。可用于线程执行顺序的同步。</li>
<li><code>- (void)setCompletionBlock:(void (^)(void))block;</code> <code>completionBlock</code> 会在当前操作执行完毕时执行 completionBlock。</li>
<li><code>- (void)addDependency:(NSOperation *)op;</code> 添加依赖，使当前操作依赖于操作 op 的完成。</li>
<li><code>- (void)removeDependency:(NSOperation *)op;</code> 移除依赖，取消当前操作对操作 op 的依赖。</li>
<li><code>@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies;</code> 在当前操作开始执行之前完成执行的所有操作对象数组。</li>
</ul>
</li>
</ol>
<h2 id="10-2-NSOperationQueue-常用属性和方法"><a href="#10-2-NSOperationQueue-常用属性和方法" class="headerlink" title="10.2 NSOperationQueue 常用属性和方法"></a>10.2 NSOperationQueue 常用属性和方法</h2><ol>
<li>取消/暂停/恢复操作<ul>
<li><code>- (void)cancelAllOperations;</code> 可以取消队列的所有操作。</li>
<li><code>- (BOOL)isSuspended;</code> 判断队列是否处于暂停状态。 YES 为暂停状态，NO 为恢复状态。</li>
<li><code>- (void)setSuspended:(BOOL)b;</code> 可设置操作的暂停和恢复，YES 代表暂停队列，NO 代表恢复队列。</li>
</ul>
</li>
<li>操作同步<ul>
<li><code>- (void)waitUntilAllOperationsAreFinished;</code> 阻塞当前线程，直到队列中的操作全部执行完毕。</li>
</ul>
</li>
<li>添加/获取操作`<ul>
<li><code>- (void)addOperationWithBlock:(void (^)(void))block;</code> 向队列中添加一个 NSBlockOperation 类型操作对象。</li>
<li><code>- (void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait;</code> 向队列中添加操作数组，wait 标志是否阻塞当前线程直到所有操作结束</li>
<li><code>- (NSArray *)operations;</code> 当前在队列中的操作数组（某个操作执行结束后会自动从这个数组清除）。</li>
<li><code>- (NSUInteger)operationCount;</code> 当前队列中的操作数。</li>
</ul>
</li>
<li>获取队列<ul>
<li><code>+ (id)currentQueue;</code> 获取当前队列，如果当前线程不是在 NSOperationQueue 上运行则返回 nil。</li>
<li><code>+ (id)mainQueue;</code> 获取主队列。</li>
</ul>
</li>
</ol>
<blockquote>
<p>注意：</p>
<ol>
<li>这里的暂停和取消（包括操作的取消和队列的取消）并不代表可以将当前的操作立即取消，而是当当前的操作执行完毕之后不再执行新的操作。</li>
<li>暂停和取消的区别就在于：暂停操作之后还可以恢复操作，继续向下执行；而取消操作之后，所有的操作就清空了，无法再接着执行剩下的操作。</li>
</ol>
</blockquote>
<hr>
<p>参考资料：</p>
<ul>
<li><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html" target="_blank" rel="noopener">苹果官方——并发编程指南：Operation Queues</a> <strong>推荐看看</strong></li>
<li><a href="https://developer.apple.com/documentation/foundation/nsoperation?language=occ" target="_blank" rel="noopener">苹果官方文档：NSOperation</a></li>
<li><a href="https://objccn.io/issue-2-1/" target="_blank" rel="noopener">Objc 中国：并发编程：API 及挑战</a></li>
</ul>
<hr>
<p>iOS多线程详尽总结系列文章：</p>
<ul>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-pthread-and-NSThread.html" target="_blank" rel="noopener">iOS多线程：『pthread、NSThread』详尽总结</a></li>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-GCD.html" target="_blank" rel="noopener">iOS多线程：『GCD』详解总结</a></li>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-NSOperation.html" target="_blank" rel="noopener">iOS多线程：『NSOperation』详解总结</a></li>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-RunLoop.html" target="_blank" rel="noopener">iOS多线程：『RunLoop』详解总结</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/线程安全/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/线程安全/" itemprop="url">
                  线程安全
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 12:01:40 / 修改时间：12:07:13" itemprop="dateCreated datePublished" datetime="2018-09-17T12:01:40+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/多线程/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>前段时间看了几个开源项目，发现他们保持线程同步的方式各不相同，有@synchronized、NSLock、dispatch_semaphore、NSCondition、pthread_mutex、OSSpinLock。后来网上查了一下，发现他们的实现机制各不相同，性能也各不一样。不好意思，我们平常使用最多的@synchronized是性能最差的。下面我们先分别介绍每个加锁方式的使用，在使用一个案例来对他们进行性能对比。</p>
<h2 id="二、介绍与使用"><a href="#二、介绍与使用" class="headerlink" title="二、介绍与使用"></a>二、介绍与使用</h2><h3 id="2-1、-synchronized"><a href="#2-1、-synchronized" class="headerlink" title="2.1、@synchronized"></a>2.1、@synchronized</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">NSObject *obj = [[NSObject alloc] init];</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    @synchronized(obj) &#123;</span><br><span class="line">        NSLog(@&quot;需要线程同步的操作1 开始&quot;);</span><br><span class="line">        sleep(3);</span><br><span class="line">        NSLog(@&quot;需要线程同步的操作1 结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    sleep(1);</span><br><span class="line">    @synchronized(obj) &#123;</span><br><span class="line">        NSLog(@&quot;需要线程同步的操作2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>@synchronized(obj)指令使用的obj为该锁的唯一标识，只有当标识相同时，才为满足互斥，如果线程2中的@synchronized(obj)改为@synchronized(self),刚线程2就不会被阻塞，@synchronized指令实现锁的优点就是我们不需要在代码中显式的创建锁对象，便可以实现锁的机制，但作为一种预防措施，@synchronized块会隐式的添加一个异常处理例程来保护代码，该处理例程会在异常抛出的时候自动的释放互斥锁。所以如果不想让隐式的异常处理例程带来额外的开销，你可以考虑使用锁对象。</p>
<p>上面结果的执行结果为：</p>
<p>2016-06-29 20:48:35.747 SafeMultiThread[35945:580107] 需要线程同步的操作1 开始<br>2016-06-29 20:48:38.748 SafeMultiThread[35945:580107] 需要线程同步的操作1 结束<br>2016-06-29 20:48:38.749 SafeMultiThread[35945:580118] 需要线程同步的操作2</p>
<h3 id="2-2、dispatch-semaphore"><a href="#2-2、dispatch-semaphore" class="headerlink" title="2.2、dispatch_semaphore"></a>2.2、dispatch_semaphore</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t signal = dispatch_semaphore_create(1);</span><br><span class="line">dispatch_time_t overTime = dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    dispatch_semaphore_wait(signal, overTime);</span><br><span class="line">        NSLog(@&quot;需要线程同步的操作1 开始&quot;);</span><br><span class="line">        sleep(2);</span><br><span class="line">        NSLog(@&quot;需要线程同步的操作1 结束&quot;);</span><br><span class="line">    dispatch_semaphore_signal(signal);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    sleep(1);</span><br><span class="line">    dispatch_semaphore_wait(signal, overTime);</span><br><span class="line">        NSLog(@&quot;需要线程同步的操作2&quot;);</span><br><span class="line">    dispatch_semaphore_signal(signal);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是dispatch_semaphore_create，dispatch_semaphore_signal，dispatch_semaphore_wait。</p>
<p>（1）dispatch_semaphore_create的声明为：</p>
<p>dispatch_semaphore_t dispatch_semaphore_create(long value);</p>
<p>传入的参数为long，输出一个dispatch_semaphore_t类型且值为value的信号量。</p>
<p>值得注意的是，这里的传入的参数value必须大于或等于0，否则dispatch_semaphore_create会返回NULL。</p>
<p>（2）dispatch_semaphore_signal的声明为：</p>
<p>long dispatch_semaphore_signal(dispatch_semaphore_t dsema)</p>
<p>这个函数会使传入的信号量dsema的值加1；</p>
<p>(3) dispatch_semaphore_wait的声明为：</p>
<p>long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)；</p>
<p>这个函数会使传入的信号量dsema的值减1；这个函数的作用是这样的，如果dsema信号量的值大于0，该函数所处线程就继续执行下面的语句，并且将信号量的值减1；如果desema的值为0，那么这个函数就阻塞当前线程等待timeout（注意timeout的类型为dispatch_time_t，不能直接传入整形或float型数），如果等待的期间desema的值被dispatch_semaphore_signal函数加1了，且该函数（即dispatch_semaphore_wait）所处线程获得了信号量，那么就继续向下执行并将信号量减1。如果等待期间没有获取到信号量或者信号量的值一直为0，那么等到timeout时，其所处线程自动执行其后语句。</p>
<p>dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。</p>
<p>如上的代码，如果超时时间overTime设置成&gt;2，可完成同步操作。如果overTime&lt;2的话，在线程1还没有执行完成的情况下，此时超时了，将自动执行下面的代码。</p>
<p>上面代码的执行结果为：</p>
<p>2016-06-29 20:47:52.324 SafeMultiThread[35945:579032] 需要线程同步的操作1 开始<br>2016-06-29 20:47:55.325 SafeMultiThread[35945:579032] 需要线程同步的操作1 结束<br>2016-06-29 20:47:55.326 SafeMultiThread[35945:579033] 需要线程同步的操作2</p>
<p>如果把超时时间设置为&lt;2s的时候，执行的结果就是：</p>
<p>2016-06-30 18:53:24.049 SafeMultiThread[30834:434334] 需要线程同步的操作1 开始<br>2016-06-30 18:53:25.554 SafeMultiThread[30834:434332] 需要线程同步的操作2<br>2016-06-30 18:53:26.054 SafeMultiThread[30834:434334] 需要线程同步的操作1 结束</p>
<h3 id="2-3、NSLock"><a href="#2-3、NSLock" class="headerlink" title="2.3、NSLock"></a>2.3、NSLock</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">NSLock *lock = [[NSLock alloc] init];</span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    //[lock lock];</span><br><span class="line">    [lock lockBeforeDate:[NSDate date]];</span><br><span class="line">        NSLog(@&quot;需要线程同步的操作1 开始&quot;);</span><br><span class="line">        sleep(2);</span><br><span class="line">        NSLog(@&quot;需要线程同步的操作1 结束&quot;);</span><br><span class="line">    [lock unlock];</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    sleep(1);</span><br><span class="line">    if ([lock tryLock]) &#123;//尝试获取锁，如果获取不到返回NO，不会阻塞该线程</span><br><span class="line">        NSLog(@&quot;锁可用的操作&quot;);</span><br><span class="line">        [lock unlock];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;锁不可用的操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSDate *date = [[NSDate alloc] initWithTimeIntervalSinceNow:3];</span><br><span class="line">    if ([lock lockBeforeDate:date]) &#123;//尝试在未来的3s内获取锁，并阻塞该线程，如果3s内获取不到恢复线程, 返回NO,不会阻塞该线程</span><br><span class="line">        NSLog(@&quot;没有超时，获得锁&quot;);</span><br><span class="line">        [lock unlock];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;超时，没有获得锁&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>NSLock是Cocoa提供给我们最基本的锁对象，这也是我们经常所使用的，除lock和unlock方法外，NSLock还提供了tryLock和lockBeforeDate:两个方法，前一个方法会尝试加锁，如果锁不可用(已经被锁住)，刚并不会阻塞线程，并返回NO。lockBeforeDate:方法会在所指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。</p>
<p>上面代码的执行结果为：</p>
<p>2016-06-29 20:45:08.864 SafeMultiThread[35911:575795] 需要线程同步的操作1 开始<br>2016-06-29 20:45:09.869 SafeMultiThread[35911:575781] 锁不可用的操作<br>2016-06-29 20:45:10.869 SafeMultiThread[35911:575795] 需要线程同步的操作1 结束<br>2016-06-29 20:45:10.870 SafeMultiThread[35911:575781] 没有超时，获得锁</p>
<p>源码定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@protocol NSLocking</span><br><span class="line"></span><br><span class="line">- (void)lock;</span><br><span class="line">- (void)unlock;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface NSLock : NSObject &lt;NSLocking&gt; &#123;</span><br><span class="line">@private</span><br><span class="line">    void *_priv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)tryLock;</span><br><span class="line">- (BOOL)lockBeforeDate:(NSDate *)limit;</span><br><span class="line"></span><br><span class="line">@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="2-4、NSRecursiveLock递归锁"><a href="#2-4、NSRecursiveLock递归锁" class="headerlink" title="2.4、NSRecursiveLock递归锁"></a>2.4、NSRecursiveLock递归锁</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//NSLock *lock = [[NSLock alloc] init];</span><br><span class="line">NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    </span><br><span class="line">    static void (^RecursiveMethod)(int);</span><br><span class="line">    </span><br><span class="line">    RecursiveMethod = ^(int value) &#123;</span><br><span class="line">        </span><br><span class="line">        [lock lock];</span><br><span class="line">        if (value &gt; 0) &#123;</span><br><span class="line">            </span><br><span class="line">            NSLog(@&quot;value = %d&quot;, value);</span><br><span class="line">            sleep(1);</span><br><span class="line">            RecursiveMethod(value - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        [lock unlock];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    RecursiveMethod(5);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>NSRecursiveLock实际上定义的是一个递归锁，这个锁可以被同一线程多次请求，而不会引起死锁。这主要是用在循环或递归操作中。</p>
<p>这段代码是一个典型的死锁情况。在我们的线程中，RecursiveMethod是递归调用的。所以每次进入这个block时，都会去加一次锁，而从第二次开始，由于锁已经被使用了且没有解锁，所以它需要等待锁被解除，这样就导致了死锁，线程被阻塞住了。调试器中会输出如下信息：</p>
<p>2016-06-30 19:08:06.393 SafeMultiThread[30928:449008] value = 5<br>2016-06-30 19:08:07.399 SafeMultiThread[30928:449008] <strong><em> -[NSLock lock]: deadlock (<nslock: 0x7fd811d28810=""> ‘(null)’)<br>2016-06-30 19:08:07.399 SafeMultiThread[30928:449008] </nslock:></em></strong> Break on _NSLockError() to debug.</p>
<p>在这种情况下，我们就可以使用NSRecursiveLock。它可以允许同一线程多次加锁，而不会造成死锁。递归锁会跟踪它被lock的次数。每次成功的lock都必须平衡调用unlock操作。只有所有达到这种平衡，锁最后才能被释放，以供其它线程使用。</p>
<p>如果我们将NSLock代替为NSRecursiveLock，上面代码则会正确执行。</p>
<p>2016-06-30 19:09:41.414 SafeMultiThread[30949:450684] value = 5<br>2016-06-30 19:09:42.418 SafeMultiThread[30949:450684] value = 4<br>2016-06-30 19:09:43.419 SafeMultiThread[30949:450684] value = 3<br>2016-06-30 19:09:44.424 SafeMultiThread[30949:450684] value = 2<br>2016-06-30 19:09:45.426 SafeMultiThread[30949:450684] value = 1</p>
<p>如果需要其他功能，源码定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@interface NSRecursiveLock : NSObject &lt;NSLocking&gt; &#123;</span><br><span class="line">@private</span><br><span class="line">    void *_priv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)tryLock;</span><br><span class="line">- (BOOL)lockBeforeDate:(NSDate *)limit;</span><br><span class="line"></span><br><span class="line">@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="2-5、NSConditionLock条件锁"><a href="#2-5、NSConditionLock条件锁" class="headerlink" title="2.5、NSConditionLock条件锁"></a>2.5、NSConditionLock条件锁</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *products = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">NSInteger HAS_DATA = 1;</span><br><span class="line">NSInteger NO_DATA = 0;</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        [lock lockWhenCondition:NO_DATA];</span><br><span class="line">        [products addObject:[[NSObject alloc] init]];</span><br><span class="line">        NSLog(@&quot;produce a product,总量:%zi&quot;,products.count);</span><br><span class="line">        [lock unlockWithCondition:HAS_DATA];</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        NSLog(@&quot;wait for product&quot;);</span><br><span class="line">        [lock lockWhenCondition:HAS_DATA];</span><br><span class="line">        [products removeObjectAtIndex:0];</span><br><span class="line">        NSLog(@&quot;custome a product&quot;);</span><br><span class="line">        [lock unlockWithCondition:NO_DATA];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当我们在使用多线程的时候，有时一把只会lock和unlock的锁未必就能完全满足我们的使用。因为普通的锁只能关心锁与不锁，而不在乎用什么钥匙才能开锁，而我们在处理资源共享的时候，多数情况是只有满足一定条件的情况下才能打开这把锁：</p>
<p>在线程1中的加锁使用了lock，所以是不需要条件的，所以顺利的就锁住了，但在unlock的使用了一个整型的条件，它可以开启其它线程中正在等待这把钥匙的临界地，而线程2则需要一把被标识为2的钥匙，所以当线程1循环到最后一次的时候，才最终打开了线程2中的阻塞。但即便如此，NSConditionLock也跟其它的锁一样，是需要lock与unlock对应的，只是lock,lockWhenCondition:与unlock，unlockWithCondition:是可以随意组合的，当然这是与你的需求相关的。</p>
<p>上面代码执行结果如下：</p>
<p>2016-06-30 20:31:58.699 SafeMultiThread[31282:521698] wait for product<br>2016-06-30 20:31:58.699 SafeMultiThread[31282:521708] produce a product,总量:1<br>2016-06-30 20:31:58.700 SafeMultiThread[31282:521698] custome a product<br>2016-06-30 20:31:58.700 SafeMultiThread[31282:521698] wait for product<br>2016-06-30 20:31:59.705 SafeMultiThread[31282:521708] produce a product,总量:1<br>2016-06-30 20:31:59.706 SafeMultiThread[31282:521698] custome a product<br>2016-06-30 20:31:59.706 SafeMultiThread[31282:521698] wait for product<br>2016-06-30 20:32:00.707 SafeMultiThread[31282:521708] produce a product,总量:1<br>2016-06-30 20:32:00.708 SafeMultiThread[31282:521698] custome a product</p>
<p>如果你需要其他功能，源码定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@interface NSConditionLock : NSObject &lt;NSLocking&gt; &#123;</span><br><span class="line">@private</span><br><span class="line">    void *_priv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER;</span><br><span class="line"></span><br><span class="line">@property (readonly) NSInteger condition;</span><br><span class="line">- (void)lockWhenCondition:(NSInteger)condition;</span><br><span class="line">- (BOOL)tryLock;</span><br><span class="line">- (BOOL)tryLockWhenCondition:(NSInteger)condition;</span><br><span class="line">- (void)unlockWithCondition:(NSInteger)condition;</span><br><span class="line">- (BOOL)lockBeforeDate:(NSDate *)limit;</span><br><span class="line">- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;</span><br><span class="line"></span><br><span class="line">@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="2-6、NSCondition"><a href="#2-6、NSCondition" class="headerlink" title="2.6、NSCondition"></a>2.6、NSCondition</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">NSCondition *condition = [[NSCondition alloc] init];</span><br><span class="line"></span><br><span class="line">NSMutableArray *products = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        [condition lock];</span><br><span class="line">        if ([products count] == 0) &#123;</span><br><span class="line">            NSLog(@&quot;wait for product&quot;);</span><br><span class="line">            [condition wait];</span><br><span class="line">        &#125;</span><br><span class="line">        [products removeObjectAtIndex:0];</span><br><span class="line">        NSLog(@&quot;custome a product&quot;);</span><br><span class="line">        [condition unlock];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        [condition lock];</span><br><span class="line">        [products addObject:[[NSObject alloc] init]];</span><br><span class="line">        NSLog(@&quot;produce a product,总量:%zi&quot;,products.count);</span><br><span class="line">        [condition signal];</span><br><span class="line">        [condition unlock];</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>一种最基本的条件锁。手动控制线程wait和signal。</p>
<p>[condition lock];一般用于多线程同时访问、修改同一个数据源，保证在同一时间内数据源只被访问、修改一次，其他线程的命令需要在lock 外等待，只到unlock ，才可访问</p>
<p>[condition unlock];与lock 同时使用</p>
<p>[condition wait];让当前线程处于等待状态</p>
<p>[condition signal];CPU发信号告诉线程不用在等待，可以继续执行</p>
<p>上面代码执行结果如下：</p>
<p>2016-06-30 20:21:25.295 SafeMultiThread[31256:513991] wait for product<br>2016-06-30 20:21:25.296 SafeMultiThread[31256:513994] produce a product,总量:1<br>2016-06-30 20:21:25.296 SafeMultiThread[31256:513991] custome a product<br>2016-06-30 20:21:25.297 SafeMultiThread[31256:513991] wait for product<br>2016-06-30 20:21:26.302 SafeMultiThread[31256:513994] produce a product,总量:1<br>2016-06-30 20:21:26.302 SafeMultiThread[31256:513991] custome a product<br>2016-06-30 20:21:26.302 SafeMultiThread[31256:513991] wait for product<br>2016-06-30 20:21:27.307 SafeMultiThread[31256:513994] produce a product,总量:1<br>2016-06-30 20:21:27.308 SafeMultiThread[31256:513991] custome a product</p>
<h3 id="2-7、pthread-mutex"><a href="#2-7、pthread-mutex" class="headerlink" title="2.7、pthread_mutex"></a>2.7、pthread_mutex</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__block pthread_mutex_t theLock;</span><br><span class="line">pthread_mutex_init(&amp;theLock, NULL);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;theLock);</span><br><span class="line">        NSLog(@&quot;需要线程同步的操作1 开始&quot;);</span><br><span class="line">        sleep(3);</span><br><span class="line">        NSLog(@&quot;需要线程同步的操作1 结束&quot;);</span><br><span class="line">        pthread_mutex_unlock(&amp;theLock);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        pthread_mutex_lock(&amp;theLock);</span><br><span class="line">        NSLog(@&quot;需要线程同步的操作2&quot;);</span><br><span class="line">        pthread_mutex_unlock(&amp;theLock);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>c语言定义下多线程加锁方式。</p>
<p>1：pthread_mutex_init(<strong>pthread_mutex_t*</strong> mutex,const pthread_mutexattr_t <em>attr);初始化锁变量mutex。attr为锁属性，NULL值为默认属性。2：pthread_mutex_lock(<strong>pthread_mutex_t</strong> </em>mutex);加锁3：pthread_mutex_tylock(<strong>pthread_mutex_t</strong> <em>mutex);加锁，但是与2不一样的是当锁已经在使用的时候，返回为EBUSY，而不是挂起等待。4：pthread_mutex_unlock(<strong>pthread_mutex_t</strong> </em>mutex);释放锁5：pthread_mutex_destroy(<strong>pthread_mutex_t</strong> *mutex);使用完后释放</p>
<p>代码执行操作结果如下：</p>
<p>2016-06-30 21:13:32.440 SafeMultiThread[31429:548869] 需要线程同步的操作1 开始<br>2016-06-30 21:13:35.445 SafeMultiThread[31429:548869] 需要线程同步的操作1 结束<br>2016-06-30 21:13:35.446 SafeMultiThread[31429:548866] 需要线程同步的操作2</p>
<h3 id="2-8、pthread-mutex-recursive"><a href="#2-8、pthread-mutex-recursive" class="headerlink" title="2.8、pthread_mutex(recursive)"></a>2.8、pthread_mutex(recursive)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">__block pthread_mutex_t theLock;</span><br><span class="line">//pthread_mutex_init(&amp;theLock, NULL);</span><br><span class="line"></span><br><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init(&amp;attr);</span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">pthread_mutex_init(&amp;lock, &amp;attr);</span><br><span class="line">pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    </span><br><span class="line">    static void (^RecursiveMethod)(int);</span><br><span class="line">    </span><br><span class="line">    RecursiveMethod = ^(int value) &#123;</span><br><span class="line">        </span><br><span class="line">        pthread_mutex_lock(&amp;theLock);</span><br><span class="line">        if (value &gt; 0) &#123;</span><br><span class="line">            </span><br><span class="line">            NSLog(@&quot;value = %d&quot;, value);</span><br><span class="line">            sleep(1);</span><br><span class="line">            RecursiveMethod(value - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;theLock);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    RecursiveMethod(5);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这是pthread_mutex为了防止在递归的情况下出现死锁而出现的递归锁。作用和NSRecursiveLock递归锁类似。</p>
<p>如果使用pthread_mutex_init(&amp;theLock, NULL);初始化锁的话，上面的代码会出现死锁现象。如果使用递归锁的形式，则没有问题。</p>
<h3 id="2-9、OSSpinLock"><a href="#2-9、OSSpinLock" class="headerlink" title="2.9、OSSpinLock"></a>2.9、OSSpinLock</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">__block OSSpinLock theLock = OS_SPINLOCK_INIT;</span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    OSSpinLockLock(&amp;theLock);</span><br><span class="line">    NSLog(@&quot;需要线程同步的操作1 开始&quot;);</span><br><span class="line">    sleep(3);</span><br><span class="line">    NSLog(@&quot;需要线程同步的操作1 结束&quot;);</span><br><span class="line">    OSSpinLockUnlock(&amp;theLock);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    OSSpinLockLock(&amp;theLock);</span><br><span class="line">    sleep(1);</span><br><span class="line">    NSLog(@&quot;需要线程同步的操作2&quot;);</span><br><span class="line">    OSSpinLockUnlock(&amp;theLock);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>OSSpinLock 自旋锁，性能最高的锁。原理很简单，就是一直 do while 忙等。它的缺点是当等待时会消耗大量 CPU 资源，所以它不适用于较长时间的任务。 不过最近YY大神在自己的博客<a href="https://link.jianshu.com/?t=http://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的 OSSpinLock</a>中说明了OSSpinLock已经不再安全，请大家谨慎使用。</p>
<h2 id="三、性能对比"><a href="#三、性能对比" class="headerlink" title="三、性能对比"></a>三、性能对比</h2><p>对以上各个锁进行1000000此的加锁解锁的空操作时间如下：</p>
<p>OSSpinLock: 46.15 ms<br>dispatch_semaphore: 56.50 ms<br>pthread_mutex: 178.28 ms<br>NSCondition: 193.38 ms<br>NSLock: 175.02 ms<br>pthread_mutex(recursive): 172.56 ms<br>NSRecursiveLock: 157.44 ms<br>NSConditionLock: 490.04 ms<br>@synchronized: 371.17 ms</p>
<p>总的来说：</p>
<p>OSSpinLock和dispatch_semaphore的效率远远高于其他。</p>
<p>@synchronized和NSConditionLock效率较差。</p>
<p>鉴于OSSpinLock的不安全，所以我们在开发中如果考虑性能的话，建议使用dispatch_semaphore。</p>
<p>如果不考虑性能，只是图个方便的话，那就使用@synchronized。</p>
<h2 id="四、联系方式"><a href="#四、联系方式" class="headerlink" title="四、联系方式"></a>四、联系方式</h2><p><a href="https://link.jianshu.com/?t=http://weibo.com/5612984599/info" target="_blank" rel="noopener">新浪微博</a><br><a href="https://link.jianshu.com/?t=https://github.com/yixiangboy" target="_blank" rel="noopener">github</a><br><a href="https://www.jianshu.com/users/c3c893a27097/timeline" target="_blank" rel="noopener">简书首页</a><br>欢迎加好友、一起交流。</p>
<p><a href="https://www.jianshu.com/p/938d68ed832c" target="_blank" rel="noopener">转自 <a href="https://www.jianshu.com/u/c3c893a27097" target="_blank" rel="noopener">景铭巴巴</a></a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/GCD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/GCD/" itemprop="url">
                  GCD
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 12:01:23 / 修改时间：14:28:49" itemprop="dateCreated datePublished" datetime="2018-09-17T12:01:23+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/多线程/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://juejin.im/post/5a90de68f265da4e9b592b40" target="_blank" rel="noopener">转自 <a href="https://juejin.im/user/5a43aed3f265da4318770885" target="_blank" rel="noopener">行走的少年郎</a></a></p>
<p><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-background.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-background.png" alt="img"></a></p>
<blockquote>
<p>本文用来介绍 iOS 多线程中 GCD 的相关知识以及使用方法。这大概是史上最详细、清晰的关于 GCD 的详细讲解+总结的文章了。通过本文，您将了解到：<br><strong>1. GCD 简介</strong><br><strong>2. GCD 任务和队列</strong><br><strong>3. GCD 的使用步骤</strong><br><strong>4. GCD 的基本使用</strong>（6种不同组合区别）<br><strong>5. GCD 线程间的通信</strong><br><strong>6. GCD 的其他方法</strong>（栅栏方法：dispatch_barrier_async、延时执行方法：dispatch_after、一次性代码（只执行一次）：dispatch_once、快速迭代方法：dispatch_apply、队列组：dispatch_group、信号量：dispatch_semaphore）</p>
<p>文中 Demo 我已放在了 Github 上，Demo 链接：<a href="https://github.com/bujige/YSC-GCD-demo" target="_blank" rel="noopener">传送门</a></p>
</blockquote>
<h1 id="1-GCD-简介"><a href="#1-GCD-简介" class="headerlink" title="1. GCD 简介"></a>1. GCD 简介</h1><p>什么是 GCD 呢？我们先来看看百度百科的解释简单了解下概念</p>
<blockquote>
<p>引自<a href="https://baike.baidu.com/item/GCD" target="_blank" rel="noopener">百度百科</a><br><strong>Grand Central Dispatch(GCD)</strong> 是 Apple 开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并发任务。在 Mac OS X 10.6 雪豹中首次推出，也可在 iOS 4 及以上版本使用。</p>
</blockquote>
<p><strong>为什么要用 GCD 呢？</strong></p>
<p>因为 GCD 有很多好处啊，具体如下：</p>
<ul>
<li>GCD 可用于多核的并行运算</li>
<li>GCD 会自动利用更多的 CPU 内核（比如双核、四核）</li>
<li>GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li>
<li>程序员只需要告诉 GCD 想要执行什么任务，不需要编写任何线程管理代码</li>
</ul>
<p>既然 GCD 有这么多的好处，那么下面我们就来系统的学习一下 GCD 的使用方法。</p>
<h1 id="2-GCD-任务和队列"><a href="#2-GCD-任务和队列" class="headerlink" title="2. GCD 任务和队列"></a>2. GCD 任务和队列</h1><p>学习 GCD 之前，先来了解 GCD 中两个核心概念：<strong>任务</strong>和<strong>队列</strong>。</p>
<p><strong>任务</strong>：就是执行操作的意思，换句话说就是你在线程中执行的那段代码。在 GCD 中是放在 block 中的。执行任务有两种方式：<strong>同步执行（sync）</strong>和<strong>异步执行（async）</strong>。两者的主要区别是：<strong>是否等待队列的任务执行结束，以及是否具备开启新线程的能力。</strong></p>
<ul>
<li><p>同步执行（sync）</p>
<p>：</p>
<ul>
<li>同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。</li>
<li>只能在当前线程中执行任务，不具备开启新线程的能力。</li>
</ul>
</li>
<li><p>异步执行（async）</p>
<p>：</p>
<ul>
<li>异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。</li>
<li>可以在新的线程中执行任务，具备开启新线程的能力。</li>
</ul>
</li>
</ul>
<p>举个简单例子：你要打电话给小明和小白。<br>同步执行就是，你打电话给小明的时候，不能同时打给小白，等到给小明打完了，才能打给小白（等待任务执行结束）。而且只能用当前的电话（不具备开启新线程的能力）。<br>而异步执行就是，你打电话给小明的时候，不等和小明通话结束，还能直接给小白打电话，不用等着和小明通话结束再打（不用等待任务执行结束）。除了当前电话，你还可以使用其他所能使用的电话（具备开启新线程的能力）。</p>
<blockquote>
<p>注意：<strong>异步执行（async）</strong>虽然具有开启新线程的能力，但是并不一定开启新线程。这跟任务所指定的队列类型有关（下面会讲）。</p>
</blockquote>
<p><strong>队列（Dispatch Queue）</strong>：这里的队列指执行任务的等待队列，即用来存放任务的队列。队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。队列的结构可参考下图：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-DispatchQueue.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-DispatchQueue.png" alt="DispatchQueue.png"></a></p>
<p>在 GCD 中有两种队列：<strong>串行队列</strong>和<strong>并发队列</strong>。两者都符合 FIFO（先进先出）的原则。两者的主要区别是：<strong>执行顺序不同，以及开启线程数不同。</strong></p>
<ul>
<li><p>串行队列（Serial Dispatch Queue）</p>
<p>：</p>
<ul>
<li>每次只有一个任务被执行。让任务一个接着一个地执行。一个任务执行完毕后，再执行下一个任务。</li>
<li>只开启一个新线程（或者不开启新线程，在当前线程执行任务）。</li>
</ul>
</li>
<li><p>并发队列（Concurrent Dispatch Queue）</p>
<p>：</p>
<ul>
<li>可以让多个任务并发（同时）执行。</li>
<li>可以开启多个线程，并且同时执行任务。</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：<strong>并发队列</strong>的并发功能只有在异步（dispatch_async）函数下才有效。</p>
</blockquote>
<p>两者具体区别如下两图所示。</p>
<p><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-SerialDispatchQueue.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-SerialDispatchQueue.png" alt="SerialDispatchQueue.png"></a></p>
<p><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-ConcurrentDispatchQueue.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-ConcurrentDispatchQueue.png" alt="ConcurrentDispatchQueue.png"></a></p>
<h1 id="3-GCD-的使用步骤"><a href="#3-GCD-的使用步骤" class="headerlink" title="3. GCD 的使用步骤"></a>3. GCD 的使用步骤</h1><p>GCD 的使用步骤其实很简单，只有两步。</p>
<ol>
<li>创建一个队列（串行队列或并发队列）</li>
<li>将任务追加到任务的等待队列中，然后系统就会根据任务类型执行任务（同步执行或异步执行）</li>
</ol>
<p>下边来看看队列的创建方法/获取方法，以及任务的创建方法。</p>
<h2 id="3-1-队列的创建方法-获取方法"><a href="#3-1-队列的创建方法-获取方法" class="headerlink" title="3.1 队列的创建方法/获取方法"></a>3.1 队列的创建方法/获取方法</h2><ul>
<li>可以使用<code>dispatch_queue_create</code>来创建队列，需要传入两个参数，第一个参数表示队列的唯一标识符，用于 DEBUG，可为空，Dispatch Queue 的名称推荐使用应用程序 ID 这种逆序全程域名；第二个参数用来识别是串行队列还是并发队列。<code>DISPATCH_QUEUE_SERIAL</code> 表示串行队列，<code>DISPATCH_QUEUE_CONCURRENT</code> 表示并发队列。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 串行队列的创建方法</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">// 并发队列的创建方法</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>对于串行队列，GCD 提供了的一种特殊的串行队列：</p>
<p>主队列（Main Dispatch Queue）</p>
<p>。</p>
<ul>
<li>所有放在主队列中的任务，都会放到主线程中执行。</li>
<li>可使用<code>dispatch_get_main_queue()</code>获得主队列。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 主队列的获取方法</span><br><span class="line">dispatch_queue_t queue = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure>
<ul>
<li><p>对于并发队列，GCD 默认提供了</p>
<p>全局并发队列（Global Dispatch Queue）</p>
<p>。</p>
<ul>
<li>可以使用<code>dispatch_get_global_queue</code>来获取。需要传入两个参数。第一个参数表示队列优先级，一般用<code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code>。第二个参数暂时没用，用<code>0</code>即可。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 全局并发队列的获取方法</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br></pre></td></tr></table></figure>
<h2 id="3-2-任务的创建方法"><a href="#3-2-任务的创建方法" class="headerlink" title="3.2 任务的创建方法"></a>3.2 任务的创建方法</h2><p>GCD 提供了同步执行任务的创建方法<code>dispatch_sync</code>和异步执行任务创建方法<code>dispatch_async</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 同步执行任务创建方法</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">    // 这里放同步执行任务代码</span><br><span class="line">&#125;);</span><br><span class="line">// 异步执行任务创建方法</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    // 这里放异步执行任务代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>虽然使用 GCD 只需两步，但是既然我们有两种队列（串行队列/并发队列），两种任务执行方式（同步执行/异步执行），那么我们就有了四种不同的组合方式。这四种不同的组合方式是：</p>
<blockquote>
<ol>
<li>同步执行 + 并发队列</li>
<li>异步执行 + 并发队列</li>
<li>同步执行 + 串行队列</li>
<li>异步执行 + 串行队列</li>
</ol>
</blockquote>
<p>实际上，刚才还说了两种特殊队列：全局并发队列、主队列。全局并发队列可以作为普通并发队列来使用。但是主队列因为有点特殊，所以我们就又多了两种组合方式。这样就有六种不同的组合方式了。</p>
<blockquote>
<ol>
<li>同步执行 + 主队列</li>
<li>异步执行 + 主队列</li>
</ol>
</blockquote>
<p>那么这几种不同组合方式各有什么区别呢，这里为了方便，先上结果，再来讲解。你可以直接查看表格结果，然后跳过 <strong>4. GCD的基本使用</strong> 。</p>
<table>
<thead>
<tr>
<th>区别</th>
<th>并发队列</th>
<th>串行队列</th>
<th>主队列</th>
</tr>
</thead>
<tbody>
<tr>
<td>同步(sync)</td>
<td>没有开启新线程，串行执行任务</td>
<td>没有开启新线程，串行执行任务</td>
<td>主线程调用：死锁卡住不执行其他线程调用：没有开启新线程，串行执行任务</td>
</tr>
<tr>
<td>异步(async)</td>
<td>有开启新线程，并发执行任务</td>
<td>有开启新线程(1条)，串行执行任务</td>
<td>没有开启新线程，串行执行任务</td>
</tr>
</tbody>
</table>
<p>下边我们来分别讲讲这几种不同的组合方式的使用方法。</p>
<h1 id="4-GCD-的基本使用"><a href="#4-GCD-的基本使用" class="headerlink" title="4. GCD 的基本使用"></a>4. GCD 的基本使用</h1><p><strong>先来讲讲并发队列的两种执行方式。</strong></p>
<h2 id="4-1-同步执行-并发队列"><a href="#4-1-同步执行-并发队列" class="headerlink" title="4.1 同步执行 + 并发队列"></a>4.1 同步执行 + 并发队列</h2><ul>
<li>在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 同步执行 + 并发队列</span><br><span class="line"> * 特点：在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。</span><br><span class="line"> */</span><br><span class="line">- (void)syncConcurrent &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    NSLog(@&quot;syncConcurrent---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;syncConcurrent---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2018-02-23 20:34:55.095932+0800 YSC-GCD-demo[19892:4996930] currentThread—{number = 1, name = main}<br>2018-02-23 20:34:55.096086+0800 YSC-GCD-demo[19892:4996930] syncConcurrent—begin<br>2018-02-23 20:34:57.097589+0800 YSC-GCD-demo[19892:4996930] 1—{number = 1, name = main}<br>2018-02-23 20:34:59.099100+0800 YSC-GCD-demo[19892:4996930] 1—{number = 1, name = main}<br>2018-02-23 20:35:01.099843+0800 YSC-GCD-demo[19892:4996930] 2—{number = 1, name = main}<br>2018-02-23 20:35:03.101171+0800 YSC-GCD-demo[19892:4996930] 2—{number = 1, name = main}<br>2018-02-23 20:35:05.101750+0800 YSC-GCD-demo[19892:4996930] 3—{number = 1, name = main}<br>2018-02-23 20:35:07.102414+0800 YSC-GCD-demo[19892:4996930] 3—{number = 1, name = main}<br>2018-02-23 20:35:07.102575+0800 YSC-GCD-demo[19892:4996930] syncConcurrent—end</p>
</blockquote>
<p>从<code>同步执行 + 并发队列</code>中可看到：</p>
<ul>
<li>所有任务都是在当前线程（主线程）中执行的，没有开启新的线程（<code>同步执行</code>不具备开启新线程的能力）。</li>
<li>所有任务都在打印的<code>syncConcurrent---begin</code>和<code>syncConcurrent---end</code>之间执行的（<code>同步任务</code>需要等待队列的任务执行结束）。</li>
<li>任务按顺序执行的。按顺序执行的原因：虽然<code>并发队列</code>可以开启多个线程，并且同时执行多个任务。但是因为本身不能创建新线程，只有当前线程这一个线程（<code>同步任务</code>不具备开启新线程的能力），所以也就不存在并发。而且当前线程只有等待当前队列中正在执行的任务执行完毕之后，才能继续接着执行下面的操作（<code>同步任务</code>需要等待队列的任务执行结束）。所以任务只能一个接一个按顺序执行，不能同时被执行。</li>
</ul>
<h2 id="4-2-异步执行-并发队列"><a href="#4-2-异步执行-并发队列" class="headerlink" title="4.2 异步执行 + 并发队列"></a>4.2 异步执行 + 并发队列</h2><ul>
<li>可以开启多个线程，任务交替（同时）执行。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 异步执行 + 并发队列</span><br><span class="line"> * 特点：可以开启多个线程，任务交替（同时）执行。</span><br><span class="line"> */</span><br><span class="line">- (void)asyncConcurrent &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    NSLog(@&quot;asyncConcurrent---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;asyncConcurrent---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2018-02-23 20:36:41.769269+0800 YSC-GCD-demo[19929:5005237] currentThread—{number = 1, name = main}<br>2018-02-23 20:36:41.769496+0800 YSC-GCD-demo[19929:5005237] asyncConcurrent—begin<br>2018-02-23 20:36:41.769725+0800 YSC-GCD-demo[19929:5005237] asyncConcurrent—end<br>2018-02-23 20:36:43.774442+0800 YSC-GCD-demo[19929:5005566] 2—{number = 5, name = (null)}<br>2018-02-23 20:36:43.774440+0800 YSC-GCD-demo[19929:5005567] 3—{number = 4, name = (null)}<br>2018-02-23 20:36:43.774440+0800 YSC-GCD-demo[19929:5005565] 1—{number = 3, name = (null)}<br>2018-02-23 20:36:45.779286+0800 YSC-GCD-demo[19929:5005567] 3—{number = 4, name = (null)}<br>2018-02-23 20:36:45.779302+0800 YSC-GCD-demo[19929:5005565] 1—{number = 3, name = (null)}<br>2018-02-23 20:36:45.779286+0800 YSC-GCD-demo[19929:5005566] 2—{number = 5, name = (null)}</p>
</blockquote>
<p>在<code>异步执行 + 并发队列</code>中可以看出：</p>
<ul>
<li>除了当前线程（主线程），系统又开启了3个线程，并且任务是交替/同时执行的。（<code>异步执行</code>具备开启新线程的能力。且<code>并发队列</code>可开启多个线程，同时执行多个任务）。</li>
<li>所有任务是在打印的<code>syncConcurrent---begin</code>和<code>syncConcurrent---end</code>之后才执行的。说明当前线程没有等待，而是直接开启了新线程，在新线程中执行任务（<code>异步执行</code>不做等待，可以继续执行任务）。</li>
</ul>
<p><strong>接下来再来讲讲串行队列的两种执行方式。</strong></p>
<h2 id="4-3-同步执行-串行队列"><a href="#4-3-同步执行-串行队列" class="headerlink" title="4.3 同步执行 + 串行队列"></a>4.3 同步执行 + 串行队列</h2><ul>
<li>不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 同步执行 + 串行队列</span><br><span class="line"> * 特点：不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。</span><br><span class="line"> */</span><br><span class="line">- (void)syncSerial &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    NSLog(@&quot;syncSerial---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;syncSerial---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果为：<br>2018-02-23 20:39:37.876811+0800 YSC-GCD-demo[19975:5017162] currentThread—{number = 1, name = main}<br>2018-02-23 20:39:37.876998+0800 YSC-GCD-demo[19975:5017162] syncSerial—begin<br>2018-02-23 20:39:39.878316+0800 YSC-GCD-demo[19975:5017162] 1—{number = 1, name = main}<br>2018-02-23 20:39:41.879829+0800 YSC-GCD-demo[19975:5017162] 1—{number = 1, name = main}<br>2018-02-23 20:39:43.880660+0800 YSC-GCD-demo[19975:5017162] 2—{number = 1, name = main}<br>2018-02-23 20:39:45.881265+0800 YSC-GCD-demo[19975:5017162] 2—{number = 1, name = main}<br>2018-02-23 20:39:47.882257+0800 YSC-GCD-demo[19975:5017162] 3—{number = 1, name = main}<br>2018-02-23 20:39:49.883008+0800 YSC-GCD-demo[19975:5017162] 3—{number = 1, name = main}<br>2018-02-23 20:39:49.883253+0800 YSC-GCD-demo[19975:5017162] syncSerial—end</p>
</blockquote>
<p>在<code>同步执行 + 串行队列</code>可以看到：</p>
<ul>
<li>所有任务都是在当前线程（主线程）中执行的，并没有开启新的线程（<code>同步执行</code>不具备开启新线程的能力）。</li>
<li>所有任务都在打印的<code>syncConcurrent---begin</code>和<code>syncConcurrent---end</code>之间执行（<code>同步任务</code>需要等待队列的任务执行结束）。</li>
<li>任务是按顺序执行的（<code>串行队列</code>每次只有一个任务被执行，任务一个接一个按顺序执行）。</li>
</ul>
<h2 id="4-4-异步执行-串行队列"><a href="#4-4-异步执行-串行队列" class="headerlink" title="4.4 异步执行 + 串行队列"></a>4.4 异步执行 + 串行队列</h2><ul>
<li>会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 异步执行 + 串行队列</span><br><span class="line"> * 特点：会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务。</span><br><span class="line"> */</span><br><span class="line">- (void)asyncSerial &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    NSLog(@&quot;asyncSerial---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;asyncSerial---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果为：<br>2018-02-23 20:41:17.029999+0800 YSC-GCD-demo[20008:5024757] currentThread—{number = 1, name = main}<br>2018-02-23 20:41:17.030212+0800 YSC-GCD-demo[20008:5024757] asyncSerial—begin<br>2018-02-23 20:41:17.030364+0800 YSC-GCD-demo[20008:5024757] asyncSerial—end<br>2018-02-23 20:41:19.035379+0800 YSC-GCD-demo[20008:5024950] 1—{number = 3, name = (null)}<br>2018-02-23 20:41:21.037140+0800 YSC-GCD-demo[20008:5024950] 1—{number = 3, name = (null)}<br>2018-02-23 20:41:23.042220+0800 YSC-GCD-demo[20008:5024950] 2—{number = 3, name = (null)}<br>2018-02-23 20:41:25.042971+0800 YSC-GCD-demo[20008:5024950] 2—{number = 3, name = (null)}<br>2018-02-23 20:41:27.047690+0800 YSC-GCD-demo[20008:5024950] 3—{number = 3, name = (null)}<br>2018-02-23 20:41:29.052327+0800 YSC-GCD-demo[20008:5024950] 3—{number = 3, name = (null)}</p>
</blockquote>
<p>在<code>异步执行 + 串行队列</code>可以看到：</p>
<ul>
<li>开启了一条新线程（<code>异步执行</code>具备开启新线程的能力，<code>串行队列</code>只开启一个线程）。</li>
<li>所有任务是在打印的<code>syncConcurrent---begin</code>和<code>syncConcurrent---end</code>之后才开始执行的（<code>异步执行</code>不会做任何等待，可以继续执行任务）。</li>
<li>任务是按顺序执行的（<code>串行队列</code>每次只有一个任务被执行，任务一个接一个按顺序执行）。</li>
</ul>
<p>下边讲讲刚才我们提到过的特殊队列：<strong>主队列</strong>。</p>
<ul>
<li><p>主队列：GCD自带的一种特殊的</p>
<p>串行队列</p>
<ul>
<li>所有放在主队列中的任务，都会放到主线程中执行</li>
<li>可使用<code>dispatch_get_main_queue()</code>获得主队列</li>
</ul>
</li>
</ul>
<p><strong>我们再来看看主队列的两种组合方式。</strong></p>
<h2 id="4-5-同步执行-主队列"><a href="#4-5-同步执行-主队列" class="headerlink" title="4.5 同步执行 + 主队列"></a>4.5 同步执行 + 主队列</h2><p><code>同步执行 + 主队列</code>在不同线程中调用结果也是不一样，在主线程中调用会出现死锁，而在其他线程中则不会。</p>
<h3 id="4-5-1-在主线程中调用同步执行-主队列"><a href="#4-5-1-在主线程中调用同步执行-主队列" class="headerlink" title="4.5.1 在主线程中调用同步执行 + 主队列"></a>4.5.1 在主线程中调用<code>同步执行 + 主队列</code></h3><ul>
<li>互相等待卡住不可行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 同步执行 + 主队列</span><br><span class="line"> * 特点(主线程调用)：互等卡主不执行。</span><br><span class="line"> * 特点(其他线程调用)：不会开启新线程，执行完一个任务，再执行下一个任务。</span><br><span class="line"> */</span><br><span class="line">- (void)syncMain &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    NSLog(@&quot;syncMain---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;syncMain---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果<br>2018-02-23 20:42:36.842892+0800 YSC-GCD-demo[20041:5030982] currentThread—{number = 1, name = main}<br>2018-02-23 20:42:36.843050+0800 YSC-GCD-demo[20041:5030982] syncMain—begin<br>(lldb)</p>
</blockquote>
<p>在<code>同步执行 + 主队列</code>可以惊奇的发现：</p>
<ul>
<li>在主线程中使用<code>同步执行 + 主队列</code>，追加到主线程的任务1、任务2、任务3都不再执行了，而且<code>syncMain---end</code>也没有打印，在XCode 9上还会报崩溃。这是为什么呢？</li>
</ul>
<p>这是因为我们在主线程中执行<code>syncMain</code>方法，相当于把<code>syncMain</code>任务放到了主线程的队列中。而<code>同步执行</code>会等待当前队列中的任务执行完毕，才会接着执行。那么当我们把<code>任务1</code>追加到主队列中，<code>任务1</code>就在等待主线程处理完<code>syncMain</code>任务。而<code>syncMain</code>任务需要等待<code>任务1</code>执行完毕，才能接着执行。</p>
<p>那么，现在的情况就是<code>syncMain</code>任务和<code>任务1</code>都在等对方执行完毕。这样大家互相等待，所以就卡住了，所以我们的任务执行不了，而且<code>syncMain---end</code>也没有打印。</p>
<p><strong>要是如果不在主线程中调用，而在其他线程中调用会如何呢？</strong></p>
<h3 id="4-5-2-在其他线程中调用同步执行-主队列"><a href="#4-5-2-在其他线程中调用同步执行-主队列" class="headerlink" title="4.5.2 在其他线程中调用同步执行 + 主队列"></a>4.5.2 在其他线程中调用<code>同步执行 + 主队列</code></h3><ul>
<li>不会开启新线程，执行完一个任务，再执行下一个任务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 使用 NSThread 的 detachNewThreadSelector 方法会创建线程，并自动启动线程执行</span><br><span class="line"> selector 任务</span><br><span class="line">[NSThread detachNewThreadSelector:@selector(syncMain) toTarget:self withObject:nil];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2018-02-23 20:44:19.377321+0800 YSC-GCD-demo[20083:5040347] currentThread—{number = 3, name = (null)}<br>2018-02-23 20:44:19.377494+0800 YSC-GCD-demo[20083:5040347] syncMain—begin<br>2018-02-23 20:44:21.384716+0800 YSC-GCD-demo[20083:5040132] 1—{number = 1, name = main}<br>2018-02-23 20:44:23.386091+0800 YSC-GCD-demo[20083:5040132] 1—{number = 1, name = main}<br>2018-02-23 20:44:25.387687+0800 YSC-GCD-demo[20083:5040132] 2—{number = 1, name = main}<br>2018-02-23 20:44:27.388648+0800 YSC-GCD-demo[20083:5040132] 2—{number = 1, name = main}<br>2018-02-23 20:44:29.390459+0800 YSC-GCD-demo[20083:5040132] 3—{number = 1, name = main}<br>2018-02-23 20:44:31.391965+0800 YSC-GCD-demo[20083:5040132] 3—{number = 1, name = main}<br>2018-02-23 20:44:31.392513+0800 YSC-GCD-demo[20083:5040347] syncMain—end</p>
</blockquote>
<p>在其他线程中使用<code>同步执行 + 主队列</code>可看到：</p>
<ul>
<li>所有任务都是在主线程（非当前线程）中执行的，没有开启新的线程（所有放在<code>主队列</code>中的任务，都会放到主线程中执行）。</li>
<li>所有任务都在打印的<code>syncConcurrent---begin</code>和<code>syncConcurrent---end</code>之间执行（<code>同步任务</code>需要等待队列的任务执行结束）。</li>
<li>任务是按顺序执行的（主队列是<code>串行队列</code>，每次只有一个任务被执行，任务一个接一个按顺序执行）。</li>
</ul>
<p>为什么现在就不会卡住了呢？<br>因为<code>syncMain 任务</code>放到了其他线程里，而<code>任务1</code>、<code>任务2</code>、<code>任务3</code>都在追加到主队列中，这三个任务都会在主线程中执行。<code>syncMain 任务</code>在其他线程中执行到追加<code>任务1</code>到主队列中，因为主队列现在没有正在执行的任务，所以，会直接执行主队列的<code>任务1</code>，等<code>任务1</code>执行完毕，再接着执行<code>任务2</code>、<code>任务3</code>。所以这里不会卡住线程。</p>
<h2 id="4-6-异步执行-主队列"><a href="#4-6-异步执行-主队列" class="headerlink" title="4.6 异步执行 + 主队列"></a>4.6 异步执行 + 主队列</h2><ul>
<li>只在主线程中执行任务，执行完一个任务，再执行下一个任务。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 异步执行 + 主队列</span><br><span class="line"> * 特点：只在主线程中执行任务，执行完一个任务，再执行下一个任务</span><br><span class="line"> */</span><br><span class="line">- (void)asyncMain &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    NSLog(@&quot;asyncMain---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;asyncMain---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2018-02-23 20:45:49.981505+0800 YSC-GCD-demo[20111:5046708] currentThread—{number = 1, name = main}<br>2018-02-23 20:45:49.981935+0800 YSC-GCD-demo[20111:5046708] asyncMain—begin<br>2018-02-23 20:45:49.982352+0800 YSC-GCD-demo[20111:5046708] asyncMain—end<br>2018-02-23 20:45:51.991096+0800 YSC-GCD-demo[20111:5046708] 1—{number = 1, name = main}<br>2018-02-23 20:45:53.991959+0800 YSC-GCD-demo[20111:5046708] 1—{number = 1, name = main}<br>2018-02-23 20:45:55.992937+0800 YSC-GCD-demo[20111:5046708] 2—{number = 1, name = main}<br>2018-02-23 20:45:57.993649+0800 YSC-GCD-demo[20111:5046708] 2—{number = 1, name = main}<br>2018-02-23 20:45:59.994928+0800 YSC-GCD-demo[20111:5046708] 3—{number = 1, name = main}<br>2018-02-23 20:46:01.995589+0800 YSC-GCD-demo[20111:5046708] 3—{number = 1, name = main}</p>
</blockquote>
<p>在<code>异步执行 + 主队列</code>可以看到：</p>
<ul>
<li>所有任务都是在当前线程（主线程）中执行的，并没有开启新的线程（虽然<code>异步执行</code>具备开启线程的能力，但因为是主队列，所以所有任务都在主线程中）。</li>
<li>所有任务是在打印的syncConcurrent—begin和syncConcurrent—end之后才开始执行的（异步执行不会做任何等待，可以继续执行任务）。</li>
<li>任务是按顺序执行的（因为主队列是<code>串行队列</code>，每次只有一个任务被执行，任务一个接一个按顺序执行）。</li>
</ul>
<p>弄懂了难理解、绕来绕去的<strong>队列+任务</strong>之后，我们来学习一个简单的东西：<strong>5. GCD 线程间的通信</strong>。</p>
<h1 id="5-GCD-线程间的通信"><a href="#5-GCD-线程间的通信" class="headerlink" title="5. GCD 线程间的通信"></a>5. GCD 线程间的通信</h1><p>在iOS开发过程中，我们一般在主线程里边进行UI刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线程间通信</span><br><span class="line"> */</span><br><span class="line">- (void)communication &#123;</span><br><span class="line">    // 获取全局并发队列</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); </span><br><span class="line">    // 获取主队列</span><br><span class="line">    dispatch_queue_t mainQueue = dispatch_get_main_queue(); </span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 异步追加任务</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 回到主线程</span><br><span class="line">        dispatch_async(mainQueue, ^&#123;</span><br><span class="line">            // 追加在主线程中执行的任务</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2018-02-23 20:47:03.462394+0800 YSC-GCD-demo[20154:5053282] 1—{number = 3, name = (null)}<br>2018-02-23 20:47:05.465912+0800 YSC-GCD-demo[20154:5053282] 1—{number = 3, name = (null)}<br>2018-02-23 20:47:07.466657+0800 YSC-GCD-demo[20154:5052953] 2—{number = 1, name = main}</p>
</blockquote>
<ul>
<li>可以看到在其他线程中先执行任务，执行完了之后回到主线程执行主线程的相应操作。</li>
</ul>
<h1 id="6-GCD-的其他方法"><a href="#6-GCD-的其他方法" class="headerlink" title="6. GCD 的其他方法"></a>6. GCD 的其他方法</h1><h2 id="6-1-GCD-栅栏方法：dispatch-barrier-async"><a href="#6-1-GCD-栅栏方法：dispatch-barrier-async" class="headerlink" title="6.1 GCD 栅栏方法：dispatch_barrier_async"></a>6.1 GCD 栅栏方法：dispatch_barrier_async</h2><ul>
<li>我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于<code>栅栏</code>一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到<code>dispatch_barrier_async</code>方法在两个操作组间形成栅栏。<br><code>dispatch_barrier_async</code>函数会等待前边追加到并发队列中的任务全部执行完毕之后，再将指定的任务追加到该异步队列中。然后在<code>dispatch_barrier_async</code>函数追加的任务执行完毕之后，异步队列才恢复为一般动作，接着追加任务到该异步队列并开始执行。具体如下图所示：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-barrier.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-barrier.png" alt="dispatch_barrier_async.png"></a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 栅栏方法 dispatch_barrier_async</span><br><span class="line"> */</span><br><span class="line">- (void)barrier &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        // 追加任务 barrier</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;barrier---%@&quot;,[NSThread currentThread]);// 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务4</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;4---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2018-02-23 20:48:18.297745+0800 YSC-GCD-demo[20188:5059274] 1—{number = 4, name = (null)}<br>2018-02-23 20:48:18.297745+0800 YSC-GCD-demo[20188:5059273] 2—{number = 3, name = (null)}<br>2018-02-23 20:48:20.301139+0800 YSC-GCD-demo[20188:5059274] 1—{number = 4, name = (null)}<br>2018-02-23 20:48:20.301139+0800 YSC-GCD-demo[20188:5059273] 2—{number = 3, name = (null)}<br>2018-02-23 20:48:22.306290+0800 YSC-GCD-demo[20188:5059274] barrier—{number = 4, name = (null)}<br>2018-02-23 20:48:24.311655+0800 YSC-GCD-demo[20188:5059274] barrier—{number = 4, name = (null)}<br>2018-02-23 20:48:26.316943+0800 YSC-GCD-demo[20188:5059273] 4—{number = 3, name = (null)}<br>2018-02-23 20:48:26.316956+0800 YSC-GCD-demo[20188:5059274] 3—{number = 4, name = (null)}<br>2018-02-23 20:48:28.320660+0800 YSC-GCD-demo[20188:5059273] 4—{number = 3, name = (null)}<br>2018-02-23 20:48:28.320649+0800 YSC-GCD-demo[20188:5059274] 3—{number = 4, name = (null)}</p>
</blockquote>
<p>在<code>dispatch_barrier_async</code>执行结果中可以看出：</p>
<ul>
<li>在执行完栅栏前面的操作之后，才执行栅栏操作，最后再执行栅栏后边的操作。</li>
</ul>
<h2 id="6-2-GCD-延时执行方法：dispatch-after"><a href="#6-2-GCD-延时执行方法：dispatch-after" class="headerlink" title="6.2 GCD 延时执行方法：dispatch_after"></a>6.2 GCD 延时执行方法：dispatch_after</h2><p>我们经常会遇到这样的需求：在指定时间（例如3秒）之后执行某个任务。可以用 GCD 的<code>dispatch_after</code>函数来实现。<br>需要注意的是：<code>dispatch_after</code>函数并不是在指定时间之后才开始执行处理，而是在指定时间之后将任务追加到主队列中。严格来说，这个时间并不是绝对准确的，但想要大致延迟执行任务，<code>dispatch_after</code>函数是很有效的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 延时执行方法 dispatch_after</span><br><span class="line"> */</span><br><span class="line">- (void)after &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    NSLog(@&quot;asyncMain---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        // 2.0秒后异步追加任务代码到主队列，并开始执行</span><br><span class="line">        NSLog(@&quot;after---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2018-02-23 20:53:08.713784+0800 YSC-GCD-demo[20282:5080295] currentThread—{number = 1, name = main}<br>2018-02-23 20:53:08.713962+0800 YSC-GCD-demo[20282:5080295] asyncMain—begin<br>2018-02-23 20:53:10.714283+0800 YSC-GCD-demo[20282:5080295] after—{number = 1, name = main}</p>
</blockquote>
<p>可以看出：在打印 <code>asyncMain---begin</code> 之后大约 2.0 秒的时间，打印了 <code>after---&lt;NSThread: 0x60000006ee00&gt;{number = 1, name = main}</code></p>
<h2 id="6-3-GCD-一次性代码（只执行一次）：dispatch-once"><a href="#6-3-GCD-一次性代码（只执行一次）：dispatch-once" class="headerlink" title="6.3 GCD 一次性代码（只执行一次）：dispatch_once"></a>6.3 GCD 一次性代码（只执行一次）：dispatch_once</h2><ul>
<li>我们在创建单例、或者有整个程序运行过程中只执行一次的代码时，我们就用到了 GCD 的 <code>dispatch_once</code> 函数。使用<br><code>dispatch_once</code> 函数能保证某段代码在程序运行过程中只被执行1次，并且即使在多线程的环境下，<code>dispatch_once</code>也可以保证线程安全。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 一次性代码（只执行一次）dispatch_once</span><br><span class="line"> */</span><br><span class="line">- (void)once &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        // 只执行1次的代码(这里面默认是线程安全的)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-4-GCD-快速迭代方法：dispatch-apply"><a href="#6-4-GCD-快速迭代方法：dispatch-apply" class="headerlink" title="6.4 GCD 快速迭代方法：dispatch_apply"></a>6.4 GCD 快速迭代方法：dispatch_apply</h2><ul>
<li>通常我们会用 for 循环遍历，但是 GCD 给我们提供了快速迭代的函数 <code>dispatch_apply</code>。<code>dispatch_apply</code> 按照指定的次数将指定的任务追加到指定的队列中，并等待全部队列执行结束。</li>
</ul>
<p>如果是在串行队列中使用 <code>dispatch_apply</code>，那么就和 for 循环一样，按顺序同步执行。可这样就体现不出快速迭代的意义了。<br>我们可以利用并发队列进行异步执行。比如说遍历 0~5 这6个数字，for 循环的做法是每次取出一个元素，逐个遍历。<code>dispatch_apply</code> 可以 在多个线程中同时（异步）遍历多个数字。<br>还有一点，无论是在串行队列，还是异步队列中，dispatch_apply 都会等待全部任务执行完毕，这点就像是同步操作，也像是队列组中的 <code>dispatch_group_wait</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 快速迭代方法 dispatch_apply</span><br><span class="line"> */</span><br><span class="line">- (void)apply &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;apply---begin&quot;);</span><br><span class="line">    dispatch_apply(6, queue, ^(size_t index) &#123;</span><br><span class="line">        NSLog(@&quot;%zd---%@&quot;,index, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;apply---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2018-02-23 22:03:18.475499+0800 YSC-GCD-demo[20470:5176805] apply—begin<br>2018-02-23 22:03:18.476672+0800 YSC-GCD-demo[20470:5177035] 1—{number = 3, name = (null)}<br>2018-02-23 22:03:18.476693+0800 YSC-GCD-demo[20470:5176805] 0—{number = 1, name = main}<br>2018-02-23 22:03:18.476704+0800 YSC-GCD-demo[20470:5177037] 2—{number = 4, name = (null)}<br>2018-02-23 22:03:18.476735+0800 YSC-GCD-demo[20470:5177036] 3—{number = 5, name = (null)}<br>2018-02-23 22:03:18.476867+0800 YSC-GCD-demo[20470:5177035] 4—{number = 3, name = (null)}<br>2018-02-23 22:03:18.476867+0800 YSC-GCD-demo[20470:5176805] 5—{number = 1, name = main}<br>2018-02-23 22:03:18.477038+0800 YSC-GCD-demo[20470:5176805] apply—end</p>
</blockquote>
<p>因为是在并发队列中异步队执行任务，所以各个任务的执行时间长短不定，最后结束顺序也不定。但是<code>apply---end</code>一定在最后执行。这是因为<code>dispatch_apply</code>函数会等待全部任务执行完毕。</p>
<h2 id="6-5-GCD-的队列组：dispatch-group"><a href="#6-5-GCD-的队列组：dispatch-group" class="headerlink" title="6.5 GCD 的队列组：dispatch_group"></a>6.5 GCD 的队列组：dispatch_group</h2><p>有时候我们会有这样的需求：分别异步执行2个耗时任务，然后当2个耗时任务都执行完毕后再回到主线程执行任务。这时候我们可以用到 GCD 的队列组。</p>
<ul>
<li>调用队列组的 <code>dispatch_group_async</code> 先把任务放到队列中，然后将队列放入队列组中。或者使用队列组的 <code>dispatch_group_enter、dispatch_group_leave</code> 组合 来实现<br><code>dispatch_group_async</code>。</li>
<li>调用队列组的 <code>dispatch_group_notify</code> 回到指定线程执行任务。或者使用 <code>dispatch_group_wait</code>回到当前线程继续向下执行（会阻塞当前线程）。</li>
</ul>
<h3 id="6-5-1-dispatch-group-notify"><a href="#6-5-1-dispatch-group-notify" class="headerlink" title="6.5.1 dispatch_group_notify"></a>6.5.1 dispatch_group_notify</h3><ul>
<li>监听 group 中任务的完成状态，当所有的任务都执行完成后，追加任务到 group 中，并执行任务。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 队列组 dispatch_group_notify</span><br><span class="line"> */</span><br><span class="line">- (void)groupNotify &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    NSLog(@&quot;group---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_t group =  dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        // 等前面的异步任务1、任务2都执行完毕后，回到主线程执行下边任务</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;group---end&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2018-02-23 22:05:03.790035+0800 YSC-GCD-demo[20494:5183349] currentThread—{number = 1, name = main}<br>2018-02-23 22:05:03.790237+0800 YSC-GCD-demo[20494:5183349] group—begin<br>2018-02-23 22:05:05.792721+0800 YSC-GCD-demo[20494:5183654] 1—{number = 4, name = (null)}<br>2018-02-23 22:05:05.792725+0800 YSC-GCD-demo[20494:5183656] 2—{number = 3, name = (null)}<br>2018-02-23 22:05:07.797408+0800 YSC-GCD-demo[20494:5183656] 2—{number = 3, name = (null)}<br>2018-02-23 22:05:07.797408+0800 YSC-GCD-demo[20494:5183654] 1—{number = 4, name = (null)}<br>2018-02-23 22:05:09.798717+0800 YSC-GCD-demo[20494:5183349] 3—{number = 1, name = main}<br>2018-02-23 22:05:11.799827+0800 YSC-GCD-demo[20494:5183349] 3—{number = 1, name = main}<br>2018-02-23 22:05:11.799977+0800 YSC-GCD-demo[20494:5183349] group—end</p>
</blockquote>
<p>从<code>dispatch_group_notify</code>相关代码运行输出结果可以看出：<br>当所有任务都执行完成之后，才执行<code>dispatch_group_notify</code> block 中的任务。</p>
<h3 id="6-5-2-dispatch-group-wait"><a href="#6-5-2-dispatch-group-wait" class="headerlink" title="6.5.2 dispatch_group_wait"></a>6.5.2 dispatch_group_wait</h3><ul>
<li>暂停当前线程（阻塞当前线程），等待指定的 group 中的任务执行完成后，才会往下继续执行。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 队列组 dispatch_group_wait</span><br><span class="line"> */</span><br><span class="line">- (void)groupWait &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    NSLog(@&quot;group---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_t group =  dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    // 等待上面的任务全部完成后，会往下继续执行（会阻塞当前线程）</span><br><span class="line">    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;group---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2018-02-23 22:10:16.939258+0800 YSC-GCD-demo[20538:5198871] currentThread—{number = 1, name = main}<br>2018-02-23 22:10:16.939455+0800 YSC-GCD-demo[20538:5198871] group—begin<br>2018-02-23 22:10:18.943862+0800 YSC-GCD-demo[20538:5199137] 2—{number = 4, name = (null)}<br>2018-02-23 22:10:18.943861+0800 YSC-GCD-demo[20538:5199138] 1—{number = 3, name = (null)}<br>2018-02-23 22:10:20.947787+0800 YSC-GCD-demo[20538:5199137] 2—{number = 4, name = (null)}<br>2018-02-23 22:10:20.947790+0800 YSC-GCD-demo[20538:5199138] 1—{number = 3, name = (null)}<br>2018-02-23 22:10:20.948134+0800 YSC-GCD-demo[20538:5198871] group—end</p>
</blockquote>
<p>从<code>dispatch_group_wait</code>相关代码运行输出结果可以看出：<br>当所有任务执行完成之后，才执行 <code>dispatch_group_wait</code> 之后的操作。但是，使用<code>dispatch_group_wait</code> 会阻塞当前线程。</p>
<h3 id="6-5-3-dispatch-group-enter、dispatch-group-leave"><a href="#6-5-3-dispatch-group-enter、dispatch-group-leave" class="headerlink" title="6.5.3 dispatch_group_enter、dispatch_group_leave"></a>6.5.3 dispatch_group_enter、dispatch_group_leave</h3><ul>
<li><code>dispatch_group_enter</code> 标志着一个任务追加到 group，执行一次，相当于 group 中未执行完毕任务数+1</li>
<li><code>dispatch_group_leave</code> 标志着一个任务离开了 group，执行一次，相当于 group 中未执行完毕任务数-1。</li>
<li>当 group 中未执行完毕任务数为0的时候，才会使<code>dispatch_group_wait</code>解除阻塞，以及执行追加到<code>dispatch_group_notify</code>中的任务。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 队列组 dispatch_group_enter、dispatch_group_leave</span><br><span class="line"> */</span><br><span class="line">- (void)groupEnterAndLeave</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    NSLog(@&quot;group---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        // 等前面的异步操作都执行完毕后，回到主线程.</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;group---end&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">//    // 等待上面的任务全部完成后，会往下继续执行（会阻塞当前线程）</span><br><span class="line">//    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">//</span><br><span class="line">//    NSLog(@&quot;group---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2018-02-23 22:14:17.997667+0800 YSC-GCD-demo[20592:5214830] currentThread—{number = 1, name = main}<br>2018-02-23 22:14:17.997839+0800 YSC-GCD-demo[20592:5214830] group—begin<br>2018-02-23 22:14:20.000298+0800 YSC-GCD-demo[20592:5215094] 1—{number = 4, name = (null)}<br>2018-02-23 22:14:20.000305+0800 YSC-GCD-demo[20592:5215095] 2—{number = 3, name = (null)}<br>2018-02-23 22:14:22.001323+0800 YSC-GCD-demo[20592:5215094] 1—{number = 4, name = (null)}<br>2018-02-23 22:14:22.001339+0800 YSC-GCD-demo[20592:5215095] 2—{number = 3, name = (null)}<br>2018-02-23 22:14:24.002321+0800 YSC-GCD-demo[20592:5214830] 3—{number = 1, name = main}<br>2018-02-23 22:14:26.002852+0800 YSC-GCD-demo[20592:5214830] 3—{number = 1, name = main}<br>2018-02-23 22:14:26.003116+0800 YSC-GCD-demo[20592:5214830] group—end</p>
</blockquote>
<p>从<code>dispatch_group_enter、dispatch_group_leave</code>相关代码运行结果中可以看出：当所有任务执行完成之后，才执行 dispatch_group_notify 中的任务。这里的<code>dispatch_group_enter、dispatch_group_leave</code>组合，其实等同于<code>dispatch_group_async</code>。</p>
<h2 id="6-6-GCD-信号量：dispatch-semaphore"><a href="#6-6-GCD-信号量：dispatch-semaphore" class="headerlink" title="6.6 GCD 信号量：dispatch_semaphore"></a>6.6 GCD 信号量：dispatch_semaphore</h2><p>GCD 中的信号量是指 <strong>Dispatch Semaphore</strong>，是持有计数的信号。类似于过高速路收费站的栏杆。可以通过时，打开栏杆，不可以通过时，关闭栏杆。在 <strong>Dispatch Semaphore</strong> 中，使用计数来完成这个功能，计数为0时等待，不可通过。计数为1或大于1时，计数减1且不等待，可通过。<br><strong>Dispatch Semaphore</strong> 提供了三个函数。</p>
<ul>
<li><code>dispatch_semaphore_create</code>：创建一个Semaphore并初始化信号的总量</li>
<li><code>dispatch_semaphore_signal</code>：发送一个信号，让信号总量加1</li>
<li><code>dispatch_semaphore_wait</code>：可以使总信号量减1，当信号总量为0时就会一直等待（阻塞所在线程），否则就可以正常执行。</li>
</ul>
<blockquote>
<p>注意：信号量的使用前提是：想清楚你需要处理哪个线程等待（阻塞），又要哪个线程继续执行，然后使用信号量。</p>
</blockquote>
<p>Dispatch Semaphore 在实际开发中主要用于：</p>
<ul>
<li>保持线程同步，将异步执行任务转换为同步执行任务</li>
<li>保证线程安全，为线程加锁</li>
</ul>
<h3 id="6-6-1-Dispatch-Semaphore-线程同步"><a href="#6-6-1-Dispatch-Semaphore-线程同步" class="headerlink" title="6.6.1 Dispatch Semaphore 线程同步"></a>6.6.1 Dispatch Semaphore 线程同步</h3><p>我们在开发中，会遇到这样的需求：异步执行耗时任务，并使用异步执行的结果进行一些额外的操作。换句话说，相当于，将将异步执行任务转换为同步执行任务。比如说：AFNetworking 中 AFURLSessionManager.m 里面的 <code>tasksForKeyPath:</code> 方法。通过引入信号量的方式，等待异步执行任务结果，获取到 tasks，然后再返回该 tasks。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (NSArray *)tasksForKeyPath:(NSString *)keyPath &#123;</span><br><span class="line">    __block NSArray *tasks = nil;</span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line">    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123;</span><br><span class="line">        if ([keyPath isEqualToString:NSStringFromSelector(@selector(dataTasks))]) &#123;</span><br><span class="line">            tasks = dataTasks;</span><br><span class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(uploadTasks))]) &#123;</span><br><span class="line">            tasks = uploadTasks;</span><br><span class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(downloadTasks))]) &#123;</span><br><span class="line">            tasks = downloadTasks;</span><br><span class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(tasks))]) &#123;</span><br><span class="line">            tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:@&quot;@unionOfArrays.self&quot;];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">    return tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面，我们来利用 Dispatch Semaphore 实现线程同步，将异步执行任务转换为同步执行任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * semaphore 线程同步</span><br><span class="line"> */</span><br><span class="line">- (void)semaphoreSync &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    NSLog(@&quot;semaphore---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line">    </span><br><span class="line">    __block int number = 0;</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        </span><br><span class="line">        number = 100;</span><br><span class="line">        </span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    NSLog(@&quot;semaphore---end,number = %zd&quot;,number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2018-02-23 22:22:26.521665+0800 YSC-GCD-demo[20642:5246341] currentThread—{number = 1, name = main}<br>2018-02-23 22:22:26.521869+0800 YSC-GCD-demo[20642:5246341] semaphore—begin<br>2018-02-23 22:22:28.526841+0800 YSC-GCD-demo[20642:5246638] 1—{number = 3, name = (null)}<br>2018-02-23 22:22:28.527030+0800 YSC-GCD-demo[20642:5246341] semaphore—end,number = 100</p>
</blockquote>
<p>从 Dispatch Semaphore 实现线程同步的代码可以看到：</p>
<ul>
<li><code>semaphore---end</code> 是在执行完 <code>number = 100;</code> 之后才打印的。而且输出结果 number 为 100。<br>这是因为<code>异步执行</code>不会做任何等待，可以继续执行任务。<code>异步执行</code>将任务1追加到队列之后，不做等待，接着执行<code>dispatch_semaphore_wait</code>方法。此时 semaphore == 0，当前线程进入等待状态。然后，异步任务1开始执行。任务1执行到<code>dispatch_semaphore_signal</code>之后，总信号量，此时 semaphore == 1，<code>dispatch_semaphore_wait</code>方法使总信号量减1，正在被阻塞的线程（主线程）恢复继续执行。最后打印<code>semaphore---end,number = 100</code>。这样就实现了线程同步，将异步执行任务转换为同步执行任务。</li>
</ul>
<h3 id="6-6-2-Dispatch-Semaphore-线程安全和线程同步（为线程加锁）"><a href="#6-6-2-Dispatch-Semaphore-线程安全和线程同步（为线程加锁）" class="headerlink" title="6.6.2 Dispatch Semaphore 线程安全和线程同步（为线程加锁）"></a>6.6.2 Dispatch Semaphore 线程安全和线程同步（为线程加锁）</h3><p><strong>线程安全</strong>：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<p>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。</p>
<p><strong>线程同步</strong>：可理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。</p>
<p>举个简单例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清(操作冲突)。等一个人说完(一个线程结束操作)，另一个再说(另一个线程再开始操作)。</p>
<p>下面，我们模拟火车票售卖的方式，实现 NSThread 线程安全和解决线程同步问题。</p>
<p>场景：总共有50张火车票，有两个售卖火车票的窗口，一个是北京火车票售卖窗口，另一个是上海火车票售卖窗口。两个窗口同时售卖火车票，卖完为止。</p>
<h4 id="6-6-2-1-非线程安全（不使用-semaphore）"><a href="#6-6-2-1-非线程安全（不使用-semaphore）" class="headerlink" title="6.6.2.1 非线程安全（不使用 semaphore）"></a>6.6.2.1 非线程安全（不使用 semaphore）</h4><p>先来看看不考虑线程安全的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 非线程安全：不使用 semaphore</span><br><span class="line"> * 初始化火车票数量、卖票窗口(非线程安全)、并开始卖票</span><br><span class="line"> */</span><br><span class="line">- (void)initTicketStatusNotSave &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    NSLog(@&quot;semaphore---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    self.ticketSurplusCount = 50;</span><br><span class="line">    </span><br><span class="line">    // queue1 代表北京火车票售卖窗口</span><br><span class="line">    dispatch_queue_t queue1 = dispatch_queue_create(&quot;net.bujige.testQueue1&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    // queue2 代表上海火车票售卖窗口</span><br><span class="line">    dispatch_queue_t queue2 = dispatch_queue_create(&quot;net.bujige.testQueue2&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    dispatch_async(queue1, ^&#123;</span><br><span class="line">        [weakSelf saleTicketNotSafe];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue2, ^&#123;</span><br><span class="line">        [weakSelf saleTicketNotSafe];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 售卖火车票(非线程安全)</span><br><span class="line"> */</span><br><span class="line">- (void)saleTicketNotSafe &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        </span><br><span class="line">        if (self.ticketSurplusCount &gt; 0) &#123;  //如果还有票，继续售卖</span><br><span class="line">            self.ticketSurplusCount--;</span><br><span class="line">            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%d 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]);</span><br><span class="line">            [NSThread sleepForTimeInterval:0.2];</span><br><span class="line">        &#125; else &#123; //如果已卖完，关闭售票窗口</span><br><span class="line">            NSLog(@&quot;所有火车票均已售完&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果（部分）：<br>2018-02-23 22:25:35.789072+0800 YSC-GCD-demo[20712:5258914] currentThread—{number = 1, name = main}<br>2018-02-23 22:25:35.789260+0800 YSC-GCD-demo[20712:5258914] semaphore—begin<br>2018-02-23 22:25:35.789641+0800 YSC-GCD-demo[20712:5259176] 剩余票数：48 窗口：{number = 3, name = (null)}<br>2018-02-23 22:25:35.789646+0800 YSC-GCD-demo[20712:5259175] 剩余票数：49 窗口：{number = 4, name = (null)}<br>2018-02-23 22:25:35.994113+0800 YSC-GCD-demo[20712:5259175] 剩余票数：47 窗口：{number = 4, name = (null)}<br>2018-02-23 22:25:35.994129+0800 YSC-GCD-demo[20712:5259176] 剩余票数：46 窗口：{number = 3, name = (null)}<br>2018-02-23 22:25:36.198993+0800 YSC-GCD-demo[20712:5259176] 剩余票数：45 窗口：{number = 3, name = (null)}<br>…</p>
</blockquote>
<p>可以看到在不考虑线程安全，不使用 semaphore 的情况下，得到票数是错乱的，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。</p>
<h4 id="6-6-2-2-线程安全（使用-semaphore-加锁）"><a href="#6-6-2-2-线程安全（使用-semaphore-加锁）" class="headerlink" title="6.6.2.2 线程安全（使用 semaphore 加锁）"></a>6.6.2.2 线程安全（使用 semaphore 加锁）</h4><p>考虑线程安全的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线程安全：使用 semaphore 加锁</span><br><span class="line"> * 初始化火车票数量、卖票窗口(线程安全)、并开始卖票</span><br><span class="line"> */</span><br><span class="line">- (void)initTicketStatusSave &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    NSLog(@&quot;semaphore---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    semaphoreLock = dispatch_semaphore_create(1);</span><br><span class="line">    </span><br><span class="line">    self.ticketSurplusCount = 50;</span><br><span class="line">    </span><br><span class="line">    // queue1 代表北京火车票售卖窗口</span><br><span class="line">    dispatch_queue_t queue1 = dispatch_queue_create(&quot;net.bujige.testQueue1&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    // queue2 代表上海火车票售卖窗口</span><br><span class="line">    dispatch_queue_t queue2 = dispatch_queue_create(&quot;net.bujige.testQueue2&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    dispatch_async(queue1, ^&#123;</span><br><span class="line">        [weakSelf saleTicketSafe];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue2, ^&#123;</span><br><span class="line">        [weakSelf saleTicketSafe];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 售卖火车票(线程安全)</span><br><span class="line"> */</span><br><span class="line">- (void)saleTicketSafe &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        // 相当于加锁</span><br><span class="line">        dispatch_semaphore_wait(semaphoreLock, DISPATCH_TIME_FOREVER);</span><br><span class="line">        </span><br><span class="line">        if (self.ticketSurplusCount &gt; 0) &#123;  //如果还有票，继续售卖</span><br><span class="line">            self.ticketSurplusCount--;</span><br><span class="line">            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%d 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]);</span><br><span class="line">            [NSThread sleepForTimeInterval:0.2];</span><br><span class="line">        &#125; else &#123; //如果已卖完，关闭售票窗口</span><br><span class="line">            NSLog(@&quot;所有火车票均已售完&quot;);</span><br><span class="line">            </span><br><span class="line">            // 相当于解锁</span><br><span class="line">            dispatch_semaphore_signal(semaphoreLock);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 相当于解锁</span><br><span class="line">        dispatch_semaphore_signal(semaphoreLock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果为：<br>2018-02-23 22:32:19.814232+0800 YSC-GCD-demo[20862:5290531] currentThread—{number = 1, name = main}<br>2018-02-23 22:32:19.814412+0800 YSC-GCD-demo[20862:5290531] semaphore—begin<br>2018-02-23 22:32:19.814837+0800 YSC-GCD-demo[20862:5290687] 剩余票数：49 窗口：{number = 3, name = (null)}<br>2018-02-23 22:32:20.017745+0800 YSC-GCD-demo[20862:5290689] 剩余票数：48 窗口：{number = 4, name = (null)}<br>2018-02-23 22:32:20.222039+0800 YSC-GCD-demo[20862:5290687] 剩余票数：47 窗口：{number = 3, name = (null)}<br>…<br>2018-02-23 22:32:29.024817+0800 YSC-GCD-demo[20862:5290689] 剩余票数：4 窗口：{number = 4, name = (null)}<br>2018-02-23 22:32:29.230110+0800 YSC-GCD-demo[20862:5290687] 剩余票数：3 窗口：{number = 3, name = (null)}<br>2018-02-23 22:32:29.433615+0800 YSC-GCD-demo[20862:5290689] 剩余票数：2 窗口：{number = 4, name = (null)}<br>2018-02-23 22:32:29.637572+0800 YSC-GCD-demo[20862:5290687] 剩余票数：1 窗口：{number = 3, name = (null)}<br>2018-02-23 22:32:29.840234+0800 YSC-GCD-demo[20862:5290689] 剩余票数：0 窗口：{number = 4, name = (null)}<br>2018-02-23 22:32:30.044960+0800 YSC-GCD-demo[20862:5290687] 所有火车票均已售完<br>2018-02-23 22:32:30.045260+0800 YSC-GCD-demo[20862:5290689] 所有火车票均已售完</p>
</blockquote>
<p>可以看出，在考虑了线程安全的情况下，使用 <code>dispatch_semaphore</code><br>机制之后，得到的票数是正确的，没有出现混乱的情况。我们也就解决了多个线程同步的问题。</p>
<hr>
<p>参考资料：</p>
<ul>
<li><a href="https://blog.csdn.net/liuyang11908/article/details/70757534" target="_blank" rel="noopener">iOS GCD之dispatch_semaphore（信号量）</a></li>
</ul>
<hr>
<p>iOS多线程详尽总结系列文章：</p>
<ul>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-pthread-and-NSThread.html" target="_blank" rel="noopener">iOS多线程：『pthread、NSThread』详尽总结</a></li>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-GCD.html" target="_blank" rel="noopener">iOS多线程：『GCD』详解总结</a></li>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-NSOperation.html" target="_blank" rel="noopener">iOS多线程：『NSOperation』详解总结</a></li>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-RunLoop.html" target="_blank" rel="noopener">iOS多线程：『RunLoop』详解总结</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/iOS-Block用法和实现原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/iOS-Block用法和实现原理/" itemprop="url">
                  iOS Block用法和实现原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 11:49:27 / 修改时间：11:55:19" itemprop="dateCreated datePublished" datetime="2018-09-17T11:49:27+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Block/" itemprop="url" rel="index"><span itemprop="name">Block</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>《Objective-C高级编程》是一本有趣又难懂的书，全书就讲了引用计数、Block、GCD三个概念，有趣是因为讲原理、实现的部分是其它iOS专业书籍里少有的。然而每个章节不读个三五遍还是比较难理解贯通的。本文针对其中的Block部分做些简单的笔记记录，讲述Block的用法和部分实现原理，详细解说从原书中寻。</p>
<h2 id="Block概要"><a href="#Block概要" class="headerlink" title="Block概要"></a>Block概要</h2><p><strong>Block</strong>：带有<strong>自动变量</strong>的<strong>匿名函数</strong>。<br><strong>匿名函数</strong>：没有函数名的函数，一对{}包裹的内容是匿名函数的作用域。<br><strong>自动变量</strong>：栈上声明的一个变量不是静态变量和全局变量，是不可以在这个栈内声明的匿名函数中使用的，但在Block中却可以。<br>虽然使用Block不用声明类，但是Block提供了类似Objective-C的类一样可以通过成员变量来<strong>保存作用域外变量值</strong>的方法，那些在Block的一对{}里使用到但却是在{}作用域以外声明的变量，就是Block截获的自动变量。</p>
<h2 id="Block常规概念"><a href="#Block常规概念" class="headerlink" title="Block常规概念"></a>Block常规概念</h2><h3 id="Block语法"><a href="#Block语法" class="headerlink" title="Block语法"></a>Block语法</h3><p>Block表达式语法：</p>
<blockquote>
<p>^ 返回值类型 (参数列表) {表达式}</p>
</blockquote>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^ int (int count) &#123;</span><br><span class="line">    return count + 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，可省略部分有：</p>
<ul>
<li>返回类型，例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^ (int count) &#123;</span><br><span class="line">    return count + 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数列表为空，则可省略，例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^ &#123;</span><br><span class="line">    NSLog(@&quot;No Parameter&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>即最简模式语法为：</p>
<blockquote>
<p>^ {表达式}</p>
</blockquote>
<h3 id="Block类型变量"><a href="#Block类型变量" class="headerlink" title="Block类型变量"></a>Block类型变量</h3><p>声明Block类型变量语法：</p>
<blockquote>
<p>返回值类型 (^变量名)(参数列表) = Block表达式</p>
</blockquote>
<p>例如，如下声明了一个变量名为blk的Block：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int (^blk)(int) = ^(int count) &#123;</span><br><span class="line">    return count + 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当Block类型变量作为函数的参数时，写作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)func:(int (^)(int))blk &#123;</span><br><span class="line">    NSLog(@&quot;Param:%@&quot;, blk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>借助typedef可简写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef int (^blk_k)(int);</span><br><span class="line"></span><br><span class="line">- (void)func:(blk_k)blk &#123;</span><br><span class="line">    NSLog(@&quot;Param:%@&quot;, blk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Block类型变量作返回值时，写作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (int (^)(int))funcR &#123;</span><br><span class="line">    return ^(int count) &#123;</span><br><span class="line">        return count ++;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>借助typedef简写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef int (^blk_k)(int);</span><br><span class="line"></span><br><span class="line">- (blk_k)funcR &#123;</span><br><span class="line">    return ^(int count) &#123;</span><br><span class="line">        return count ++;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="截获自动变量值"><a href="#截获自动变量值" class="headerlink" title="截获自动变量值"></a>截获自动变量值</h3><p>Block表达式可截获所使用的自动变量的值。<br><strong>截获</strong>：保存自动变量的<strong>瞬间值</strong>。<br>因为是“瞬间值”，所以声明Block之后，即便在Block外修改自动变量的值，也不会对Block内截获的自动变量值产生影响。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int i = 10;</span><br><span class="line">void (^blk)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;In block, i = %d&quot;, i);</span><br><span class="line">&#125;;</span><br><span class="line">i = 20;//Block外修改变量i，也不影响Block内的自动变量</span><br><span class="line">blk();//i修改为20后才执行，打印: In block, i = 10</span><br><span class="line">NSLog(@&quot;i = %d&quot;, i);//打印：i = 20</span><br></pre></td></tr></table></figure>
<h3 id="block说明符号"><a href="#block说明符号" class="headerlink" title="__block说明符号"></a>__block说明符号</h3><p>自动变量截获的值为Block声明时刻的瞬间值，保存后就不能改写该值，如需对自动变量进行重新赋值，需要在变量声明前附加<strong>block说明符，这时该变量称为</strong>block变量。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__block int i = 10;//i为__block变量，可在block中重新赋值</span><br><span class="line">void (^blk)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;In block, i = %d&quot;, i);</span><br><span class="line">&#125;;</span><br><span class="line">i = 20;</span><br><span class="line">blk();//打印: In block, i = 20</span><br><span class="line">NSLog(@&quot;i = %d&quot;, i);//打印：i = 20</span><br></pre></td></tr></table></figure>
<h3 id="自动变量值为一个对象情况"><a href="#自动变量值为一个对象情况" class="headerlink" title="自动变量值为一个对象情况"></a>自动变量值为一个对象情况</h3><p>当自动变量为一个类的<strong>对象</strong>，且没有使用__block修饰时，虽然不可以在Block内对该变量进行重新赋值，但可以修改该对象的属性。<br>如果该对象是个Mutable的对象，例如NSMutableArray，则还可以在Block内对NSMutableArray进行元素的增删：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *array = [[NSMutableArray alloc] initWithObjects:@&quot;1&quot;, @&quot;2&quot;,nil ];</span><br><span class="line">NSLog(@&quot;Array Count:%ld&quot;, array.count);//打印Array Count:2</span><br><span class="line">void (^blk)(void) = ^&#123;</span><br><span class="line">    [array removeObjectAtIndex:0];//Ok</span><br><span class="line">    //array = [NSNSMutableArray new];//没有__block修饰，编译失败！</span><br><span class="line">&#125;;</span><br><span class="line">blk();</span><br><span class="line">NSLog(@&quot;Array Count:%ld&quot;, array.count);//打印Array Count:1</span><br></pre></td></tr></table></figure>
<h2 id="Block实现原理"><a href="#Block实现原理" class="headerlink" title="Block实现原理"></a>Block实现原理</h2><h3 id="使用Clang"><a href="#使用Clang" class="headerlink" title="使用Clang"></a>使用Clang</h3><p>Block实际上是作为极普通的<strong>C语言源码</strong>来处理的：含有Block语法的源码首先被转换<strong>成C语言编译器能处理的源码</strong>，再作为普通的C源代码<strong>进行编译</strong>。<br>使用LLVM编译器的clang命令可将含有Block的Objective-C代码转换成C++的源代码，以探查其具体实现方式：</p>
<blockquote>
<p>clang -rewrite-objc 源码文件名</p>
</blockquote>
<p>注：如果使用该命令报错：<em>’UIKit/UIKit.h’ file not found</em>，可参考<a href="https://www.jianshu.com/p/43a09727eb2c" target="_blank" rel="noopener">《Objective-C编译成C++代码报错》</a>解决。</p>
<h3 id="Block结构"><a href="#Block结构" class="headerlink" title="Block结构"></a>Block结构</h3><p>使用Block的时候，编译器对Block语法进行了怎样的转换？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    int count = 10;</span><br><span class="line">    void (^ blk)() = ^()&#123;</span><br><span class="line">        NSLog(@&quot;In Block:%d&quot;, count);</span><br><span class="line">    &#125;;</span><br><span class="line">    blk();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示的最简单的Block使用代码，经clang转换后，可得到以下几个部分（有代码删减和注释添加）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void __main_block_func_0(</span><br><span class="line">    struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    int count = __cself-&gt;count; // bound by copy</span><br><span class="line">    </span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_64_vf2p_jz52yz7x4xtcx55yv0r0000gn_T_main_d2f8d2_mi_0, </span><br><span class="line">    count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个函数的实现，对应Block中{}内的内容，这些内容被当做了C语言函数来处理，函数参数中的<strong>__cself</strong>相当于Objective-C中的self。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc; //描述Block大小、版本等信息</span><br><span class="line">  int count;</span><br><span class="line">  //构造函数函数</span><br><span class="line">  __main_block_impl_0(void *fp,</span><br><span class="line">          struct __main_block_desc_0 *desc,</span><br><span class="line">          int _count,</span><br><span class="line">          int flags=0) : count(_count) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock; //在函数栈上声明，则为_NSConcreteStackBlock</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>__main_block_impl_0</strong>即为<strong>main()函数栈上的Block结构体</strong>，其中的__block_impl结构体声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct __block_impl &#123;</span><br><span class="line">  void *isa;//指明对象的Class</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>__block_impl</strong>结构体，即为Block的结构体，可理解为<strong>Block的类结构</strong>。<br>再看下main()函数翻译的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    int count = 10;</span><br><span class="line">    void (* blk)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, count));</span><br><span class="line">    </span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>去除掉复杂的类型转化，可简写为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    int count = 10;</span><br><span class="line">    sturct __main_block_impl_0 *blk = &amp;__main_block_impl_0(__main_block_func_0,         //函数指针</span><br><span class="line">                                                           &amp;__main_block_desc_0_DATA)); //Block大小、版本等信息</span><br><span class="line">    </span><br><span class="line">    (*blk-&gt;FuncPtr)(blk);   //调用FuncPtr指向的函数，并将blk自己作为参数传入</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此，可以看出，<strong>Block也是Objective-C中的对象</strong>。<br>Block有三种类（即__block_impl的<strong>isa</strong>指针指向的值，isa说明参考<a href="https://www.jianshu.com/p/41735c66dccb" target="_blank" rel="noopener">《Objective-C isa 指针 与 runtime 机制》</a>），根据Block对象创建时<strong>所处数据区不同</strong>而进行区别：</p>
<ul>
<li><strong>_NSConcreteStackBlock</strong>：在栈上创建的Block对象</li>
<li><strong>_NSConcreteMallocBlock</strong>：在堆上创建的Block对象</li>
<li><strong>_NSConcreteGlobalBlock</strong>：全局数据区的Block对象</li>
</ul>
<h3 id="如何截获自动变量"><a href="#如何截获自动变量" class="headerlink" title="如何截获自动变量"></a>如何截获自动变量</h3><p>上部分介绍了<strong>Block的结构</strong>，和<strong>作为匿名函数的调用机制</strong>，那<strong>自动变量截获</strong>是发生在什么时候呢？<br>观察上节代码中<strong>__main_block_impl_0</strong>结构体（main栈上Block的结构体）的构造函数可以看到，栈上的变量count以参数的形式传入到了这个构造函数中，此处即为<strong>变量的自动截获</strong>。<br>因此可以这样理解：<strong>__block_impl</strong>结构体已经可以代表Block类了，但在栈上又声明了<strong>__main_block_impl_0</strong>结构体，对<strong>__block_impl</strong>进行<strong>封装</strong>后才来表示栈上的<strong>Block类</strong>，就是为了获取Block中使用到的栈上声明的变量（<strong>栈上没在Block中使用的变量不会被捕获</strong>），变量被保存在Block的结构体实例中。<br>所以在blk()执行之前，栈上简单数据类型的count无论发生什么变化，都不会影响到Block以参数形式传入而捕获的值。但这个变量是指向对象的指针时，是可以修改这个对象的属性的，只是不能为变量重新赋值。</p>
<h3 id="Block的存储域"><a href="#Block的存储域" class="headerlink" title="Block的存储域"></a>Block的存储域</h3><p>上文已提到，根据Block创建的位置不同，Block有三种类型，创建的Block对象分别会存储到栈、堆、全局数据区域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void (^blk)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;Global Block&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    blk();</span><br><span class="line">    NSLog(@&quot;%@&quot;,[blk class]);//打印：__NSGlobalBlock__</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面代码块中的全局blk自然是存储在全局数据区，但注意在<strong>函数栈上</strong>创建的blk，如果<strong>没有截获自动变量</strong>，Block的结构实例还是会被设置在程序的<strong>全局数据区，而非栈上</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    void (^blk)(void) = ^&#123;//没有截获自动变量的Block</span><br><span class="line">        NSLog(@&quot;Stack Block&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    blk();</span><br><span class="line">    NSLog(@&quot;%@&quot;,[blk class]);//打印:__NSGlobalBlock__</span><br><span class="line">    </span><br><span class="line">    int i = 1;</span><br><span class="line">    void (^captureBlk)(void) = ^&#123;//截获自动变量i的Block</span><br><span class="line">        NSLog(@&quot;Capture:%d&quot;, i);</span><br><span class="line">    &#125;;</span><br><span class="line">    captureBlk();</span><br><span class="line">    NSLog(@&quot;%@&quot;,[captureBlk class]);//打印：__NSMallocBlock__</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到截获了自动变量的Block打印的类是<strong>NSGlobalBlock</strong>，表示存储在全局数据区。<br>但为什么捕获自动变量的Block打印的类却是设置在堆上的<strong>NSMallocBlock</strong>，而非栈上的<strong>NSStackBlock</strong>?这个问题稍后解释。</p>
<h3 id="Block复制"><a href="#Block复制" class="headerlink" title="Block复制"></a>Block复制</h3><p>配置在栈上的Block，如果其所属的栈作用域结束，该Block就会被废弃，对于超出Block作用域仍需使用Block的情况，Block提供了<strong>将Block从栈上复制到堆上的方法</strong>来解决这种问题，即便Block栈作用域已结束，但被拷贝到堆上的Block还可以继续存在。<br>复制到堆上的Block，<strong>将_NSConcreteMallocBlock</strong>类对象写入Block结构体实例的成员变量isa：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">impl.isa = &amp;_NSConcreteMallocBlock;</span><br></pre></td></tr></table></figure>
<p>在ARC有效时，大多数情况下编译器会进行判断，自动生成将Block从栈上复制到堆上的代码，以下几种情况<strong>栈上的Block会自动复制到堆上</strong>：</p>
<ul>
<li>调用Block的copy方法</li>
<li>将Block作为函数返回值时</li>
<li>将Block赋值给__strong修改的变量时</li>
<li>向Cocoa框架含有usingBlock的方法或者GCD的API传递Block参数时</li>
</ul>
<p>其它时候向方法的参数中传递Block时，需要手动调用copy方法复制Block。<br>上一节的栈上截获了自动变量i的Block之所以在栈上创建，却是<em>NSMallocBlock<strong>类，就是因为这个Block对象赋值给了</strong></em>_strong修饰的变量<strong>captureBlk（_strong是ARC下对象的默认修饰符）。<br>因为上面四条规则，在ARC下其实很少见到_NSConcreteStackBlock类的Block，大多数情况编译器都保证了Block是在堆上创建的，如下代码所示，仅最后一行代码直接使用一个不赋值给变量的Block，它的类才是</strong>NSStackBlock**：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int count = 0;</span><br><span class="line">blk_t blk = ^()&#123;</span><br><span class="line">    NSLog(@&quot;In Stack:%d&quot;, count);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;blk&apos;s Class:%@&quot;, [blk class]);//打印：blk&apos;s Class:__NSMallocBlock__</span><br><span class="line">NSLog(@&quot;Global Block:%@&quot;, [^&#123;NSLog(@&quot;Global Block&quot;);&#125; class]);//打印：Global Block:__NSGlobalBlock__</span><br><span class="line">NSLog(@&quot;Copy Block:%@&quot;, [[^&#123;NSLog(@&quot;Copy Block:%d&quot;,count);&#125; copy] class]);//打印：Copy Block:__NSMallocBlock__</span><br><span class="line">NSLog(@&quot;Stack Block:%@&quot;, [^&#123;NSLog(@&quot;Stack Block:%d&quot;,count);&#125; class]);//打印：Stack Block:__NSStackBlock__</span><br></pre></td></tr></table></figure>
<p>关于ARC下和MRC下Block自动copy的区别，查看<a href="https://link.jianshu.com/?t=https://www.zybuluo.com/MicroCai/note/49713" target="_blank" rel="noopener">《Block 小测验》</a>里几道题目就能区分了。<br>另外，原书存在ARC和MRC混合讲解、区分不明的情况，比如书中几个使用到栈上对象导致Crash的例子是MRC条件下才会发生的，但书中没做特殊说明。</p>
<h3 id="使用-block发生了什么"><a href="#使用-block发生了什么" class="headerlink" title="使用__block发生了什么"></a>使用__block发生了什么</h3><p>Block捕获的自动变量添加<strong>block说明符，就可在Block内读和写该变量，也可以在原来的栈上读写该变量。<br><strong>自动变量的截获</strong>保证了栈上的自动变量被销毁后，Block内仍可使用该变量。<br>**</strong>block<strong>保证了栈上和Block内（通常在堆上）可以访问和修改</strong>“同一个变量”**，__block是如何实现这一功能的？</p>
<p><strong>block发挥作用的<strong>原理</strong>：将栈上用</strong>block修饰的自动变量<strong>封装成一个结构体</strong>，让其在堆上创建，以方便从栈上或堆上访问和修改同一份数据。</p>
<p><strong>验证过程</strong>：<br>现在对刚才的代码段，加上__block说明符，并在block内外读写变量count。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    __block int count = 10;</span><br><span class="line">    void (^ blk)() = ^()&#123;</span><br><span class="line">        count = 20;</span><br><span class="line">        NSLog(@&quot;In Block:%d&quot;, count);//打印：In Block:20</span><br><span class="line">    &#125;;</span><br><span class="line">    count ++;</span><br><span class="line">    NSLog(@&quot;Out Block:%d&quot;, count);//打印：Out Block:11</span><br><span class="line">    </span><br><span class="line">    blk();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上面的代码段clang，发现Block的结构体<strong>__main_block_impl_0</strong>结构如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_count_0 *count; // by ref</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_count_0 *_count, int flags=0) : count(_count-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最大的变化就是count变量不再是int类型了，count变成了一个指向<strong>__Block_byref_count_0</strong>结构体的指针，<strong>__Block_byref_count_0</strong>结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_count_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_count_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它保存了int count变量，还有一个指向<strong>__Block_byref_count_0</strong>实例的指针<strong>__forwarding</strong>，通过下面两段代码<strong>__forwarding</strong>指针的用法可以知道，该指针其实指向的是对象自身：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Block的执行函数</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_count_0 *count = __cself-&gt;count; // bound by ref</span><br><span class="line"></span><br><span class="line">        (count-&gt;__forwarding-&gt;count) = 20;//对应count = 20;</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_64_vf2p_jz52yz7x4xtcx55yv0r0000gn_T_main_fafeeb_mi_0, </span><br><span class="line">        (count-&gt;__forwarding-&gt;count));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//main函数</span><br><span class="line">int main() &#123;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_count_0 count = &#123;(void*)0,</span><br><span class="line">    (__Block_byref_count_0 *)&amp;count, </span><br><span class="line">    0, </span><br><span class="line">    sizeof(__Block_byref_count_0), </span><br><span class="line">    10&#125;;</span><br><span class="line">    </span><br><span class="line">    void (* blk)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, </span><br><span class="line">    &amp;__main_block_desc_0_DATA, </span><br><span class="line">    (__Block_byref_count_0 *)&amp;count, </span><br><span class="line">    570425344));</span><br><span class="line">    </span><br><span class="line">    (count.__forwarding-&gt;count) ++;//对应count ++;</span><br><span class="line">    </span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_64_vf2p_jz52yz7x4xtcx55yv0r0000gn_T_main_fafeeb_mi_1, </span><br><span class="line">    (count.__forwarding-&gt;count));</span><br><span class="line">    </span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要通过<strong>forwarding指针完成对count变量的读写修改？<br>为了保证无论是在栈上还是在堆上，都能通过都</strong>forwarding指针找到在堆上创建的count这个<strong>main_block_func_0结构体，以完成对count-&gt;count（第一个count是</strong>main_block_func_0对象，第二个count是int类型变量）的访问和修改。<br>示意图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2814-c2c1c0ffeda6ad43.jpg_s?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<h3 id="Block的循环引用"><a href="#Block的循环引用" class="headerlink" title="Block的循环引用"></a>Block的循环引用</h3><p>Block的循环引用原理和解决方法大家都比较熟悉，此处将结合上文的介绍，介绍一种不常用的解决Block循环引用的方法和一种借助Block参数解决该问题的方法。<br>Block循环引用<strong>原因</strong>：一个对象A有Block类型的属性，从而持有这个Block，如果Block的代码块中使用到这个对象A，或者仅仅是用用到A对象的属性，会使Block也持有A对象，导致两者互相持有，不能在作用域结束后正常释放。<br><strong>解决原理</strong>：对象A照常持有Block，但Block不能强引用持有对象A以打破循环。<br><strong>解决方法</strong>：<br><strong>方法一：</strong>对Block内要使用的对象A使用_<strong>_weak</strong>进行修饰，Block对对象A弱引用打破循环。</p>
<p>有三种常用形式：</p>
<ul>
<li>使用__weak ClassName</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__block XXViewController* weakSelf = self;</span><br><span class="line">self.blk = ^&#123;</span><br><span class="line">    NSLog(@&quot;In Block : %@&quot;,weakSelf);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用__weak typeof(self)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">self.blk = ^&#123;</span><br><span class="line">    NSLog(@&quot;In Block : %@&quot;,weakSelf);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>Reactive Cocoa中的@weakify和@strongify</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@weakify(self);</span><br><span class="line">self.blk = ^&#123;</span><br><span class="line">    @strongify(self);</span><br><span class="line">    NSLog(@&quot;In Block : %@&quot;,self);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其原理参考<a href="https://www.jianshu.com/p/3d6c4416db5e" target="_blank" rel="noopener">《@weakify, @strongify》</a>，自己简便实现参考<a href="https://link.jianshu.com/?t=http://blog.csdn.net/u014773226/article/details/54617716" target="_blank" rel="noopener">《@weak - @strong 宏的实现》</a></p>
<p><strong>方法二：</strong>对Block内要使用的对象A使用<strong>__block</strong>进行修饰，并在代码块内，使用完__block变量后将其设为nil，并且该block必须至少执行一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__block XXController *blkSelf = self;</span><br><span class="line">self.blk = ^&#123;</span><br><span class="line">    NSLog(@&quot;In Block : %@&quot;,blkSelf);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意上述代码仍<strong>存在内存泄露</strong>，因为：</p>
<ul>
<li>XXController对象持有Block对象blk</li>
<li>blk对象持有__block变量blkSelf</li>
<li>__block变量blkSelf持有XXController对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__block XXController *blkSelf = self;</span><br><span class="line">self.blk = ^&#123;</span><br><span class="line">    NSLog(@&quot;In Block : %@&quot;,blkSelf);</span><br><span class="line">    blkSelf = nil;//不能省略</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">self.blk();//该block必须执行一次，否则还是内存泄露</span><br></pre></td></tr></table></figure>
<p>在block代码块内，使用完使用完__block变量后将其设为nil，并且该block必须至少执行一次后，<strong>不存在内存泄露</strong>，因为此时：</p>
<ul>
<li>XXController对象持有Block对象blk</li>
<li>blk对象持有__block变量blkSelf(类型为编译器创建的结构体)</li>
<li><strong>block变量blkSelf在执行blk()之后被设置为nil（</strong>block变量结构体的__forwarding指针指向了nil），不再持有XXController对象，打破循环</li>
</ul>
<p>第二种使用__block打破循环的方法，<strong>优点</strong>是：</p>
<ul>
<li>可通过<strong>block变量动态控制持有XXController对象的时间，运行时决定是否将nil或其他变量赋值给</strong>block变量</li>
<li>不能使用<strong>weak的系统中，使用</strong>unsafe_unretained来替代<strong>weak打破循环可能有野指针问题，使用</strong>block则可避免该问题</li>
</ul>
<p>其<strong>缺点</strong>也明显：</p>
<ul>
<li>必须手动保证__block变量最后设置为nil</li>
<li>block必须执行一次，否则__block不为nil循环应用仍存在</li>
</ul>
<p>因此，还是避免使用第二种不常用方式，直接使用<strong>weak打破Block循环引用。<br><strong>方法三</strong>：将在Block内要使用到的对象（一般为self对象），以Block参数的形式传入，Block就不会捕获该对象，而将其作为参数使用，其生命周期系统的栈自动管理，不造成内存泄露。<br>即原来使用</strong>weak的写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">self.blk = ^&#123;</span><br><span class="line">    __strong typeof(self) strongSelf = weakSelf;</span><br><span class="line">    NSLog(@&quot;Use Property:%@&quot;, strongSelf.name);</span><br><span class="line">    //……</span><br><span class="line">&#125;;</span><br><span class="line">self.blk();</span><br></pre></td></tr></table></figure>
<p>改为Block传参写法后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.blk = ^(UIViewController *vc) &#123;</span><br><span class="line">    NSLog(@&quot;Use Property:%@&quot;, vc.name);</span><br><span class="line">&#125;;</span><br><span class="line">self.blk(self);</span><br></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>简化了两行代码，更优雅</li>
<li>更明确的API设计：告诉API使用者，该方法的Block直接使用传进来的参数对象，不会造成循环引用，不用调用者再使用weak避免循环</li>
</ul>
<p>该种用法的详细思路，和clang后的数据结构，可参考<a href="https://link.jianshu.com/?t=https://github.com/ChenYilong/iOSBlog/blob/master/Tips/Heap-Stack%20Dance/Heap-Stack%20Dance.md" target="_blank" rel="noopener">《Heap-Stack Dance》</a>。</p>
<p><a href="https://www.jianshu.com/p/d28a5633b963" target="_blank" rel="noopener">转自 [<a href="https://www.jianshu.com/u/AqMpQK" target="_blank" rel="noopener">kamous</a>]</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Sun Lei</p>
              <p class="site-description motion-element" itemprop="description">只有用心才能看清楚·真正重要的东西·用眼睛是看不见的</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">30</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sun Lei</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.4.4</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Muse</a> v6.4.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.1"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
