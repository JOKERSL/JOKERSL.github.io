<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.1" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.1">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.4.1',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
<meta property="og:type" content="website">
<meta property="og:title" content="Man Tou Pu&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/iOS面试/index.html">
<meta property="og:site_name" content="Man Tou Pu&#39;s Blog">
<meta property="og:description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Man Tou Pu&#39;s Blog">
<meta name="twitter:description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">






  <link rel="canonical" href="http://yoursite.com/iOS面试/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Man Tou Pu's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Man Tou Pu's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">技术、生活个人博客</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/TCP和UDP的区别和优缺点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/TCP和UDP的区别和优缺点/" itemprop="url">
                  TCP和UDP的区别和优缺点
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 14:44:15 / 修改时间：14:50:31" itemprop="dateCreated datePublished" datetime="2018-09-17T14:44:15+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络相关/" itemprop="url" rel="index"><span itemprop="name">网络相关</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://blog.csdn.net/xiaobangkuaipao/article/details/76793702" target="_blank" rel="noopener">转自 <a href="https://blog.csdn.net/xiaobangkuaipao" target="_blank" rel="noopener">xiaobangkuaipao</a></a></p>
<h1 id="TCP与UDP区别总结："><a href="#TCP与UDP区别总结：" class="headerlink" title="TCP与UDP区别总结："></a>TCP与UDP区别总结：</h1><p>1、TCP面向连接</p>
<p>（如打电话要先拨号建立连接）;</p>
<p>UDP是无连接</p>
<p>的，即发送数据之前不需要建立连接</p>
<p>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</p>
<p>Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</p>
<p>3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</p>
<p>4.每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</p>
<p>5、TCP对系统资源要求较多，UDP对系统资源要求较少。</p>
<p>2、为什么UDP有时比TCP更有优势?</p>
<p>UDP以其简单、传输快的优势，在越来越多场景下取代了TCP,如实时游戏。</p>
<p>（1）网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。</p>
<p>（2）TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。</p>
<p>采用TCP，一旦发生丢包，TCP会将后续的包缓存起来，等前面的包重传并接收到后再继续发送，延时会越来越大，基于UDP对实时性要求较为严格的情况下，采用自定义重传机制，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成影响。</p>
<p>3、UDP和TCP编程步骤也有些不同，如下：</p>
<p><strong>TCP: </strong><br>TCP编程的服务器端一般步骤是：<br>　　1、创建一个socket，用函数socket()；     SOCKET SocketListen =socket(AF_INET,SOCK_STREAM, IPPROTO_TCP);<br>　　2、设置socket属性，用函数setsockopt(); <em> 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind(); SOCKET_ERROR = bind(SocketListen,(const sockaddr</em>)&amp;addr,sizeof(addr))<br>　　4、开启监听，用函数listen()；                 SOCKET_ERROR == listen(SocketListen,2)<br>　　5、接收客户端上来的连接，用函数accept()；    SOCKET SocketWaiter = accept(SocketListen,</p>
<p>​                                                  <em>Out</em>    struct sockaddr *addr</p>
<p> <em>Inout</em>  int <em>addrlen);<br>　　6、收发数据，用函数send()和recv()，或者read()和write();<br>　　7、关闭网络连接； closesocket(SocketListen);closesocket(SocketWaiter);<br>　　8、关闭监听；<br>SOCK_STREAM这种的特点是面向连接的，即每次收发数据之前必须通过connect建立连接，而SOCK_DGRAM这种是User Datagram Protocol协议的网络通讯，它是无连接的，不可靠的。<br>TCP编程的客户端一般步骤是：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt();</em> 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选<br>　　4、设置要连接的对方的IP地址和端口等属性；<br>　　5、连接服务器，用函数connect()；<br>　　6、收发数据，用函数send()和recv()，或者read()和write();<br>　　7、关闭网络连接；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int send(</span><br><span class="line">  _In_  SOCKET s,         //向哪个socket发送，accept返回的socket。</span><br><span class="line">  _In_  const char *buf,</span><br><span class="line">  _In_  int len,</span><br><span class="line">  _In_  int flags</span><br><span class="line">);                               由于</span><br></pre></td></tr></table></figure>
<p>send(SocketClient,(const char *)&amp;fh,sizeof(fh),0);</p>
<p>recv(SocketClient,szbuf,sizeof(szbuf),0);<br><strong>UDP:</strong><br>与之对应的UDP编程步骤要简单许多，分别如下：<br>　　UDP编程的服务器端一般步骤是：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt();<em> 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();<br>　　4、循环接收数据，用函数recvfrom();<br>　　5、关闭网络连接；<br>UDP编程的客户端一般步骤是：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt();</em> 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选<br>　　4、设置对方的IP地址和端口等属性;<br>　　5、发送数据，用函数sendto();<br>　　6、关闭网络连接；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int recvfrom(</span><br><span class="line">  _In_         SOCKET s,       //绑定的socket</span><br><span class="line">  _Out_        char *buf,</span><br><span class="line">  _In_         int len,</span><br><span class="line">  _In_         int flags,</span><br><span class="line">  _Out_        struct sockaddr *from,  //用来接收对方的</span><br><span class="line">  _Inout_opt_  int *fromlen</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>int nres=</p>
<p>recvfrom</p>
<p>(pThis-&gt;m_socketListen,szBuf,sizeof(szBuf),0,(sockaddr<em>)&amp;addrClient,&amp;nSize);//0处标志位<br>sendto(m_socketListen,szBuffer,nSize,0,(const sockaddr</em>)&amp;addr,sizeof(sockaddr_in))</p>
<p>TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。</p>
<p>4、将socket设置为广播属性<br>bool optval=true;<br>setsockopt(m_socketListen,SOL_SOCKET,SO_BROADCAST,(const char *)&amp;optval,sizeof(bool));</p>
<p>5、将Socket设置为非阻塞。<br>//bool benable=true;<br>//ioctlsocket(m_socketListen,FIONBIO,(u_long*)&amp;benable);</p>
<p>6、Tcp头，20字节</p>
<p><img src="/Users/sunlei/Desktop/20170806225229000.png" alt="20170806225229000"></p>
<p>7、UDP首部,8个字节</p>
<p><img src="/Users/sunlei/Desktop/20170806225326602.png" alt="20170806225326602"></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/RunLoop详尽总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/RunLoop详尽总结/" itemprop="url">
                  RunLoop详尽总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 14:22:30 / 修改时间：14:24:43" itemprop="dateCreated datePublished" datetime="2018-09-17T14:22:30+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/RunLoop/" itemprop="url" rel="index"><span itemprop="name">RunLoop</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.bujige.net/blog/iOS-Complete-learning-RunLoop.html" target="_blank" rel="noopener">转自 行走的少年郎</a></p>
<h2 id="1-RunLoop简介"><a href="#1-RunLoop简介" class="headerlink" title="1. RunLoop简介"></a>1. RunLoop简介</h2><h3 id="1-1-什么是RunLoop？"><a href="#1-1-什么是RunLoop？" class="headerlink" title="1.1 什么是RunLoop？"></a>1.1 什么是RunLoop？</h3><p>可以理解为字面意思：Run表示运行，Loop表示循环。结合在一起就是运行的循环的意思。哈哈，我更愿意翻译为『跑圈』。直观理解就像是不停的跑圈。</p>
<p>RunLoop实际上是一个对象，这个对象在循环中用来处理程序运行过程中出现的各种事件（比如说触摸事件、UI刷新事件、定时器事件、Selector事件），从而保持程序的持续运行；而且在没有事件处理的时候，会进入睡眠模式，从而节省CPU资源，提高程序性能。</p>
<h3 id="1-2-RunLoop和线程"><a href="#1-2-RunLoop和线程" class="headerlink" title="1.2 RunLoop和线程"></a>1.2 RunLoop和线程</h3><p>RunLoop和线程是息息相关的，我们知道线程的作用是用来执行特定的一个或多个任务，但是在默认情况下，线程执行完之后就会退出，就不能再执行任务了。这时我们就需要采用一种方式来让线程能够处理任务，并不退出。所以，我们就有了RunLoop。</p>
<ol>
<li>一条线程对应一个RunLoop对象，每条线程都有唯一一个与之对应的RunLoop对象。</li>
<li>我们只能在当前线程中操作当前线程的RunLoop，而不能去操作其他线程的RunLoop。</li>
<li>RunLoop对象在第一次获取RunLoop时创建，销毁则是在线程结束的时候。</li>
<li>主线程的RunLoop对象系统自动帮助我们创建好了(原理如下)，而子线程的RunLoop对象需要我们主动创建。</li>
</ol>
<h3 id="1-3-默认情况下主线程的RunLoop原理"><a href="#1-3-默认情况下主线程的RunLoop原理" class="headerlink" title="1.3 默认情况下主线程的RunLoop原理"></a>1.3 默认情况下主线程的RunLoop原理</h3><p>我们在启动一个iOS程序的时候，系统会调用创建项目时自动生成的main.m的文件。main.m文件如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>UIApplicationMain</code>函数内部帮我们开启了主线程的RunLoop，<code>UIApplicationMain</code>内部拥有一个无线循环的代码。上边的代码中开启RunLoop的过程可以简单的理解为如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;        </span><br><span class="line">    BOOL running = YES;</span><br><span class="line">    do &#123;</span><br><span class="line">        // 执行各种任务，处理各种事件</span><br><span class="line">        // ......</span><br><span class="line">    &#125; while (running);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上边可看出，程序一直在do-while循环中执行，所以UIApplicationMain函数一直没有返回，我们在运行程序之后程序不会马上退出，会保持持续运行状态。</p>
<p>下图是苹果官方给出的RunLoop模型图。</p>
<p><a href="https://upload-images.jianshu.io/upload_images/1877784-6ab632fc118e31f3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/1877784-6ab632fc118e31f3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="官方RunLoop模型图"></a></p>
<p>从上图中可以看出，RunLoop就是线程中的一个循环，RunLoop在循环中会不断检测，通过Input sources（输入源）和Timer sources（定时源）两种来源等待接受事件；然后对接受到的事件通知线程进行处理，并在没有事件的时候进行休息。</p>
<h2 id="2-RunLoop相关类"><a href="#2-RunLoop相关类" class="headerlink" title="2. RunLoop相关类"></a>2. RunLoop相关类</h2><p>下面我们来了解一下Core Foundation框架下关于RunLoop的5个类，只有弄懂这几个类的含义，我们才能深入了解RunLoop运行机制。</p>
<ol>
<li>CFRunLoopRef：代表RunLoop的对象</li>
<li>CFRunLoopModeRef：RunLoop的运行模式</li>
<li>CFRunLoopSourceRef：就是RunLoop模型图中提到的输入源/事件源</li>
<li>CFRunLoopTimerRef：就是RunLoop模型图中提到的定时源</li>
<li>CFRunLoopObserverRef：观察者，能够监听RunLoop的状态改变</li>
</ol>
<p>下边详细讲解下几种类的具体含义和关系。</p>
<p>先来看一张表示这5个类的关系图（来源：<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">https://blog.ibireme.com/2015/05/18/runloop/</a>）。</p>
<p><a href="https://upload-images.jianshu.io/upload_images/1877784-2177aa2828b1ad34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/1877784-2177aa2828b1ad34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RunLoop相关类关系图.png"></a></p>
<p>接着来讲解这5个类的相互关系（来源：<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">https://blog.ibireme.com/2015/05/18/runloop/</a>），这篇文章总结的特别好，就拿来参考一下，有兴趣的朋友可以去看看，写的很好。</p>
<p>一个RunLoop对象（CFRunLoopRef）中包含若干个运行模式（CFRunLoopModeRef）。而每一个运行模式下又包含若干个输入源（CFRunLoopSourceRef）、定时源（CFRunLoopTimerRef）、观察者（CFRunLoopObserverRef）。</p>
<ul>
<li>每次RunLoop启动时，只能指定其中一个运行模式（CFRunLoopModeRef），这个运行模式（CFRunLoopModeRef）被称作CurrentMode。</li>
<li>如果需要切换运行模式（CFRunLoopModeRef），只能退出Loop，再重新指定一个运行模式（CFRunLoopModeRef）进入。</li>
<li>这样做主要是为了分隔开不同组的输入源（CFRunLoopSourceRef）、定时源（CFRunLoopTimerRef）、观察者（CFRunLoopObserverRef），让其互不影响 。</li>
</ul>
<p>下边我们来详细讲解下这五个类：</p>
<h3 id="2-1-CFRunLoopRef"><a href="#2-1-CFRunLoopRef" class="headerlink" title="2.1 CFRunLoopRef"></a>2.1 CFRunLoopRef</h3><p>CFRunLoopRef就是Core Foundation框架下RunLoop对象类。我们可通过以下方式来获取RunLoop对象：</p>
<ul>
<li>Core Foundation<ul>
<li><code>CFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象</code></li>
<li><code>CFRunLoopGetMain(); // 获得主线程的RunLoop对象</code></li>
</ul>
</li>
</ul>
<p>当然，在Foundation框架下获取RunLoop对象类的方法如下：</p>
<ul>
<li>Foundation<ul>
<li><code>[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象</code></li>
<li><code>[NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象</code></li>
</ul>
</li>
</ul>
<h3 id="2-2-CFRunLoopModeRef"><a href="#2-2-CFRunLoopModeRef" class="headerlink" title="2.2 CFRunLoopModeRef"></a>2.2 CFRunLoopModeRef</h3><p>系统默认定义了多种运行模式（CFRunLoopModeRef），如下：</p>
<ol>
<li><strong>kCFRunLoopDefaultMode</strong>：App的默认运行模式，通常主线程是在这个运行模式下运行</li>
<li><strong>UITrackingRunLoopMode</strong>：跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响）</li>
<li>UIInitializationRunLoopMode：在刚启动App时第进入的第一个 Mode，启动完成后就不再使用</li>
<li>GSEventReceiveRunLoopMode：接受系统内部事件，通常用不到</li>
<li><strong>kCFRunLoopCommonModes</strong>：伪模式，不是一种真正的运行模式（后边会用到）</li>
</ol>
<p>其中<strong>kCFRunLoopDefaultMode</strong>、<strong>UITrackingRunLoopMode</strong>、<strong>kCFRunLoopCommonModes</strong>是我们开发中需要用到的模式，具体使用方法我们在 <strong>2.3 CFRunLoopTimerRef</strong> 中结合CFRunLoopTimerRef来演示说明。</p>
<h3 id="2-3-CFRunLoopTimerRef"><a href="#2-3-CFRunLoopTimerRef" class="headerlink" title="2.3 CFRunLoopTimerRef"></a>2.3 CFRunLoopTimerRef</h3><p>CFRunLoopTimerRef是定时源（RunLoop模型图中提到过），理解为基于时间的触发器，基本上就是NSTimer（哈哈，这个理解就简单了吧）。</p>
<p>下面我们来演示下CFRunLoopModeRef和CFRunLoopTimerRef结合的使用用法，从而加深理解。</p>
<ol>
<li><p>首先我们新建一个iOS项目，在Main.storyboard中拖入一个Text View。</p>
</li>
<li><p>在ViewController.m文件中加入以下代码，<a href="https://github.com/lianai911/YSC-RunLoopDemo" target="_blank" rel="noopener">Demo</a>中请调用<code>[self ShowDemo1];</code>来演示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    // 定义一个定时器，约定两秒之后调用self的run方法</span><br><span class="line">    NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];</span><br><span class="line"></span><br><span class="line">    // 将定时器添加到当前RunLoop的NSDefaultRunLoopMode下</span><br><span class="line">    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)run</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;---run&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后运行，这时候我们发现如果我们不对模拟器进行任何操作的话，定时器会稳定的每隔2秒调用run方法打印。</p>
</li>
<li><p>但是当我们拖动Text View滚动时，我们发现：run方法不打印了，也就是说NSTimer不工作了。而当我们松开鼠标的时候，NSTimer就又开始正常工作了。</p>
</li>
</ol>
<p>这是因为：</p>
<ul>
<li>当我们不做任何操作的时候，RunLoop处于NSDefaultRunLoopMode下。</li>
<li>而当我们拖动Text View的时候，RunLoop就结束NSDefaultRunLoopMode，切换到了UITrackingRunLoopMode模式下，这个模式下没有添加NSTimer，所以我们的NSTimer就不工作了。</li>
<li>但当我们松开鼠标的时候，RunLoop就结束UITrackingRunLoopMode模式，又切换回NSDefaultRunLoopMode模式，所以NSTimer就又开始正常工作了。</li>
</ul>
<p>你可以试着将上述代码中的<code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</code>语句换为<code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];</code>，也就是将定时器添加到当前RunLoop的UITrackingRunLoopMode下，你就会发现定时器只会在拖动Text View的模式下工作，而不做操作的时候定时器就不工作。</p>
<p>那难道我们就不能在这两种模式下让NSTimer都能正常工作吗？</p>
<p>当然可以，这就用到了我们之前说过的<strong>伪模式（kCFRunLoopCommonModes）</strong>，这其实不是一种真实的模式，而是一种标记模式，意思就是可以在打上Common Modes标记的模式下运行。</p>
<p>那么哪些模式被标记上了Common Modes呢？</p>
<p><strong>NSDefaultRunLoopMode</strong> 和 <strong>UITrackingRunLoopMode</strong>。</p>
<p>所以我们只要我们将NSTimer添加到当前RunLoop的kCFRunLoopCommonModes（Foundation框架下为NSRunLoopCommonModes）下，我们就可以让NSTimer在不做操作和拖动Text View两种情况下愉快的正常工作了。</p>
<p>具体做法就是讲添加语句改为<code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</code></p>
<p>既然讲到了NSTimer，这里顺便讲下NSTimer中的<code>scheduledTimerWithTimeInterval</code>方法和RunLoop的关系。添加下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];</span><br></pre></td></tr></table></figure>
<p>这句代码调用了scheduledTimer返回的定时器，NSTimer会自动被加入到了RunLoop的NSDefaultRunLoopMode模式下。这句代码相当于下面两句代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</span><br></pre></td></tr></table></figure>
<h3 id="2-4-CFRunLoopSourceRef"><a href="#2-4-CFRunLoopSourceRef" class="headerlink" title="2.4 CFRunLoopSourceRef"></a>2.4 CFRunLoopSourceRef</h3><p>CFRunLoopSourceRef是事件源（RunLoop模型图中提到过），CFRunLoopSourceRef有两种分类方法。</p>
<ul>
<li>第一种按照官方文档来分类（就像RunLoop模型图中那样）：<ul>
<li>Port-Based Sources（基于端口）</li>
<li>Custom Input Sources（自定义）</li>
<li>Cocoa Perform Selector Sources</li>
</ul>
</li>
<li>第二种按照函数调用栈来分类：<ul>
<li>Source0 ：非基于Port</li>
<li>Source1：基于Port，通过内核和其他线程通信，接收、分发系统事件</li>
</ul>
</li>
</ul>
<p>这两种分类方式其实没有区别，只不过第一种是通过官方理论来分类，第二种是在实际应用中通过调用函数来分类。</p>
<p>下边我们举个例子大致来了解一下函数调用栈和Source。</p>
<ol>
<li><p>在我们的项目中的Main.storyboard中添加一个Button按钮，并添加点击动作。</p>
</li>
<li><p>然后在点击动作的代码中加入一句输出语句，并打上断点，如下图所示：</p>
<p><a href="https://upload-images.jianshu.io/upload_images/1877784-f801715c95de19f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/1877784-f801715c95de19f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加Button.png"></a></p>
</li>
<li><p>然后运行程序，并点击按钮。</p>
</li>
<li><p>然后在项目中单击下下图红色部分。</p>
<p><a href="https://upload-images.jianshu.io/upload_images/1877784-970c15ff611d4d6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/1877784-970c15ff611d4d6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="函数调用栈展示图"></a></p>
</li>
<li><p>可以看到如下图所示就是点击事件产生的函数调用栈。</p>
<p><a href="https://upload-images.jianshu.io/upload_images/1877784-c014e77adce248c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/1877784-c014e77adce248c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="函数调用栈"></a></p>
</li>
</ol>
<p>所以点击事件是这样来的：</p>
<ol>
<li>首先程序启动，调用16行的main函数，main函数调用15行UIApplicationMain函数，然后一直往上调用函数，最终调用到0行的BtnClick函数，即点击函数。</li>
<li>同时我们可以看到11行中有Sources0，也就是说我们点击事件是属于Sources0函数的，点击事件就是在Sources0中处理的。</li>
<li>而至于Sources1，则是用来接收、分发系统事件，然后再分发到Sources0中处理的。</li>
</ol>
<h3 id="2-5-CFRunLoopObserverRef"><a href="#2-5-CFRunLoopObserverRef" class="headerlink" title="2.5 CFRunLoopObserverRef"></a>2.5 CFRunLoopObserverRef</h3><p>CFRunLoopObserverRef是观察者，用来监听RunLoop的状态改变</p>
<p>CFRunLoopObserverRef可以监听的状态改变有以下几种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0),               // 即将进入Loop：1</span><br><span class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),        // 即将处理Timer：2    </span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),       // 即将处理Source：4</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),       // 即将进入休眠：32</span><br><span class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),        // 即将从休眠中唤醒：64</span><br><span class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7),                // 即将从Loop中退出：128</span><br><span class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU       // 监听全部状态改变  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下边我们通过代码来监听下RunLoop中的状态改变。</p>
<ol>
<li><p>在ViewController.m中添加如下代码，<a href="https://github.com/lianai911/YSC-RunLoopDemo" target="_blank" rel="noopener">Demo</a>中请调用<code>[self showDemo2];</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    // 创建观察者</span><br><span class="line">    CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">        NSLog(@&quot;监听到RunLoop发生改变---%zd&quot;,activity);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 添加观察者到当前RunLoop中</span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);</span><br><span class="line"></span><br><span class="line">    // 释放observer，最后添加完需要释放掉</span><br><span class="line">    CFRelease(observer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后运行，看下打印结果，如下图。</p>
</li>
</ol>
<p><a href="https://upload-images.jianshu.io/upload_images/1877784-2005e92565b30e68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/1877784-2005e92565b30e68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打印结果"></a></p>
<p>可以看到RunLoop的状态在不断的改变，最终变成了状态 32，也就是即将进入睡眠状态，说明RunLoop之后就会进入睡眠状态。</p>
<h2 id="3-RunLoop原理"><a href="#3-RunLoop原理" class="headerlink" title="3. RunLoop原理"></a>3. RunLoop原理</h2><p>好了，五个类都讲解完了，下边开始放大招了。这下我们就可以来理解RunLoop的运行逻辑了。</p>
<p>下边上一张之前提到的文章中博主提供的运行逻辑图（来源：<a href="https://blog.ibireme.com/2015/05/18/runloop/%EF%BC%89" target="_blank" rel="noopener">https://blog.ibireme.com/2015/05/18/runloop/）</a></p>
<p><a href="https://upload-images.jianshu.io/upload_images/1877784-94c6cdb3a7864593.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/1877784-94c6cdb3a7864593.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RunLoop运行逻辑图"></a></p>
<p>这张图对于我们理解RunLoop来说太有帮助了，下边我们可以来说下官方文档给我们的RunLoop逻辑。</p>
<p>在每次运行开启RunLoop的时候，所在线程的RunLoop会自动处理之前未处理的事件，并且通知相关的观察者。</p>
<p>具体的顺序如下：</p>
<ol>
<li>通知观察者RunLoop已经启动</li>
<li>通知观察者即将要开始的定时器</li>
<li>通知观察者任何即将启动的非基于端口的源</li>
<li>启动任何准备好的非基于端口的源</li>
<li>如果基于端口的源准备好并处于等待状态，立即启动；并进入步骤9</li>
<li>通知观察者线程进入休眠状态</li>
<li>将线程置于休眠知道任一下面的事件发生：<ul>
<li>某一事件到达基于端口的源</li>
<li>定时器启动</li>
<li>RunLoop设置的时间已经超时</li>
<li>RunLoop被显示唤醒</li>
</ul>
</li>
<li>通知观察者线程将被唤醒</li>
<li>处理未处理的事件<ul>
<li>如果用户定义的定时器启动，处理定时器事件并重启RunLoop。进入步骤2</li>
<li>如果输入源启动，传递相应的消息</li>
<li>如果RunLoop被显示唤醒而且时间还没超时，重启RunLoop。进入步骤2</li>
</ul>
</li>
<li>通知观察者RunLoop结束。</li>
</ol>
<h2 id="4-RunLoop实战应用"><a href="#4-RunLoop实战应用" class="headerlink" title="4. RunLoop实战应用"></a>4. RunLoop实战应用</h2><p>哈哈，讲了这么多云里雾里的原理知识，下边终于到了实战应用环节。</p>
<p>光弄懂是没啥用的，能够实战应用才是硬道理。下面讲解一下RunLoop的几种应用。</p>
<h3 id="4-1-NSTimer的使用"><a href="#4-1-NSTimer的使用" class="headerlink" title="4.1 NSTimer的使用"></a>4.1 NSTimer的使用</h3><p>NSTimer的使用方法在讲解<code>CFRunLoopTimerRef</code>类的时候详细讲解过，具体参考上边 <strong>2.3 CFRunLoopTimerRef</strong>。</p>
<h3 id="4-2-ImageView推迟显示"><a href="#4-2-ImageView推迟显示" class="headerlink" title="4.2 ImageView推迟显示"></a>4.2 ImageView推迟显示</h3><p>有时候，我们会遇到这种情况：<br>当界面中含有UITableView，而且每个UITableViewCell里边都有图片。这时候当我们滚动UITableView的时候，如果有一堆的图片需要显示，那么可能会出现卡顿的现象。</p>
<p>怎么解决这个问题呢？</p>
<p>这时候，我们应该推迟图片的显示，也就是ImageView推迟显示图片。有两种方法：</p>
<h4 id="1-监听UIScrollView的滚动"><a href="#1-监听UIScrollView的滚动" class="headerlink" title="1. 监听UIScrollView的滚动"></a>1. 监听UIScrollView的滚动</h4><p>因为UITableView继承自UIScrollView，所以我们可以通过监听UIScrollView的滚动，实现UIScrollView相关delegate即可。</p>
<h4 id="2-利用PerformSelector设置当前线程的RunLoop的运行模式"><a href="#2-利用PerformSelector设置当前线程的RunLoop的运行模式" class="headerlink" title="2. 利用PerformSelector设置当前线程的RunLoop的运行模式"></a>2. 利用PerformSelector设置当前线程的RunLoop的运行模式</h4><p>利用<code>performSelector</code>方法为UIImageView调用<code>setImage:</code>方法，并利用<code>inModes</code>将其设置为RunLoop下NSDefaultRunLoopMode运行模式。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@&quot;tupian&quot;] afterDelay:4.0 inModes:NSDefaultRunLoopMode];</span><br></pre></td></tr></table></figure>
<p>下边利用Demo演示一下该方法。</p>
<ol>
<li><p>在项目中的Main.storyboard中添加一个UIImageView，并添加属性，并简单添加一下约束（不然无法显示）如下图所示。</p>
<p><a href="https://upload-images.jianshu.io/upload_images/1877784-8253c4b57f1b674e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/1877784-8253c4b57f1b674e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加UIImageView"></a></p>
</li>
<li><p>在项目中拖入一张图片，比如下图。</p>
<p><a href="https://upload-images.jianshu.io/upload_images/1877784-b4777f945878a0b9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/1877784-b4777f945878a0b9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tupian.jpg"></a></p>
</li>
<li><p>然后我们在<code>touchesBegan</code>方法中添加下面的代码，在<a href="https://github.com/lianai911/YSC-RunLoopDemo" target="_blank" rel="noopener">Demo</a>中请在<code>touchesBegan</code>中调用<code>[self showDemo3];</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    [self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@&quot;tupian&quot;] afterDelay:4.0 inModes:@[NSDefaultRunLoopMode]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行程序，点击一下屏幕，然后拖动UIText View，拖动4秒以上，发现过了4秒之后，UIImageView还没有显示图片，当我们松开的时候，则显示图片，效果如下：</p>
</li>
</ol>
<p><a href="https://upload-images.jianshu.io/upload_images/1877784-13880540c8c89552.gif?imageMogr2/auto-orient/strip" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/1877784-13880540c8c89552.gif?imageMogr2/auto-orient/strip" alt="UIImageView延迟显示效果.gif"></a></p>
<p>这样我们就实现了在拖动完之后，在延迟显示UIImageView。</p>
<h3 id="4-3-后台常驻线程（很常用）"><a href="#4-3-后台常驻线程（很常用）" class="headerlink" title="4.3 后台常驻线程（很常用）"></a>4.3 后台常驻线程（很常用）</h3><p>我们在开发应用程序的过程中，如果后台操作特别频繁，经常会在子线程做一些耗时操作（下载文件、后台播放音乐等），我们最好能让这条线程永远常驻内存。</p>
<p>那么怎么做呢？</p>
<p>添加一条用于常驻内存的强引用的子线程，在该线程的RunLoop下添加一个Sources，开启RunLoop。</p>
<p>具体实现过程如下：</p>
<ol>
<li><p>在项目的ViewController.m中添加一条强引用的thread线程属性，如下图：</p>
<p><a href="https://upload-images.jianshu.io/upload_images/1877784-ffce8301e3bd4736.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/1877784-ffce8301e3bd4736.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加thread属性"></a></p>
</li>
<li><p>在viewDidLoad中创建线程self.thread，使线程启动并执行run1方法，代码如下。在<a href="https://github.com/lianai911/YSC-RunLoopDemo" target="_blank" rel="noopener">Demo</a>中，请在viewDidLoad调用<code>[self showDemo4];</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    // 创建线程，并调用run1方法执行任务</span><br><span class="line">    self.thread = [[NSThread alloc] initWithTarget:self selector:@selector(run1) object:nil];</span><br><span class="line">    // 开启线程</span><br><span class="line">    [self.thread start];    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) run1</span><br><span class="line">&#123;</span><br><span class="line">    // 这里写任务</span><br><span class="line">    NSLog(@&quot;----run1-----&quot;);</span><br><span class="line"></span><br><span class="line">    // 添加下边两句代码，就可以开启RunLoop，之后self.thread就变成了常驻线程，可随时添加任务，并交于RunLoop处理</span><br><span class="line">    [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">    [[NSRunLoop currentRunLoop] run];</span><br><span class="line"></span><br><span class="line">    // 测试是否开启了RunLoop，如果开启RunLoop，则来不了这里，因为RunLoop开启了循环。</span><br><span class="line">    NSLog(@&quot;未开启RunLoop&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行之后发现打印了<strong>—-run1—–</strong>，而<strong>未开启RunLoop</strong>则未打印。</p>
</li>
</ol>
<p>这时，我们就开启了一条常驻线程，下边我们来试着添加其他任务，除了之前创建的时候调用了run1方法，我们另外在点击的时候调用run2方法。</p>
<p>那么，我们在touchesBegan中调用PerformSelector，从而实现在点击屏幕的时候调用run2方法。<a href="https://github.com/lianai911/YSC-RunLoopDemo" target="_blank" rel="noopener">Demo地址</a>。具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;   </span><br><span class="line">    // 利用performSelector，在self.thread的线程中调用run2方法执行任务</span><br><span class="line">    [self performSelector:@selector(run2) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) run2</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;----run2------&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过运行测试，除了之前打印的<strong>—-run1—–</strong>，每当我们点击屏幕，都能调用<strong>—-run2——</strong>。<br>这样我们就实现了常驻线程的需求。</p>
<hr>
<p>彻底学会多线程系列其他文章：</p>
<ul>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-pthread-and-NSThread.html" target="_blank" rel="noopener">iOS多线程–彻底学会多线程之『pthread、NSThread』</a></li>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-GCD.html" target="_blank" rel="noopener">iOS多线程–彻底学会多线程之『GCD』</a></li>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-NSOperation.html" target="_blank" rel="noopener">iOS多线程–彻底学会多线程之『NSOperation』</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/pthread、NSThread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/pthread、NSThread/" itemprop="url">
                  pthread、NSThread
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 12:24:19 / 修改时间：14:28:05" itemprop="dateCreated datePublished" datetime="2018-09-17T12:24:19+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/多线程/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.bujige.net/blog/iOS-Complete-learning-pthread-and-NSThread.html" target="_blank" rel="noopener">转自 行走的少年郎</a></p>
<p><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-background.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-background.png" alt="img"></a></p>
<blockquote>
<p>本文用来介绍 iOS 多线程中，<strong>pthread、NSThread</strong> 的使用方法及实现。<br>第一部分：pthread 的使用、其他相关方法。<br>第二部分：NSThread 的使用、线程相关用法、线程状态控制方法、线程之间的通信、线程安全和线程同步，以及线程的状态转换相关知识。</p>
<p>文中 Demo 我已放在了 Github 上，Demo 链接：<a href="https://github.com/bujige/YSC-pthread-NSThread-demo" target="_blank" rel="noopener">传送门</a></p>
</blockquote>
<h1 id="1-pthread"><a href="#1-pthread" class="headerlink" title="1. pthread"></a>1. pthread</h1><h2 id="1-1-pthread-简介"><a href="#1-1-pthread-简介" class="headerlink" title="1.1 pthread 简介"></a>1.1 pthread 简介</h2><p>pthread 是一套通用的多线程的 API，可以在Unix / Linux / Windows 等系统跨平台使用，使用 C 语言编写，需要程序员自己管理线程的生命周期，使用难度较大，我们在 iOS 开发中几乎不使用 pthread，但是还是来可以了解一下的。</p>
<blockquote>
<p>引自 <a href="https://baike.baidu.com/item/Pthread" target="_blank" rel="noopener">百度百科</a><br>POSIX 线程（POSIX threads），简称 Pthreads，是线程的 POSIX 标准。该标准定义了创建和操纵线程的一整套 API。在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用 Pthreads 作为操作系统的线程。Windows 操作系统也有其移植版 pthreads-win32。</p>
<p>引自 <a href="https://zh.wikipedia.org/wiki/POSIX%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener">维基百科</a><br>POSIX 线程（英语：POSIX Threads，常被缩写 为 Pthreads）是 POSIX 的线程标准，定义了创建和操纵线程的一套 API。<br>实现 POSIX 线程标准的库常被称作 Pthreads，一般用于 Unix-like POSIX 系统，如 Linux、Solaris。但是 Microsoft Windows 上的实现也存在，例如直接使用 Windows API 实现的第三方库 pthreads-w32；而利用 Windows 的 SFU/SUA 子系统，则可以使用微软提供的一部分原生 POSIX API。</p>
</blockquote>
<h2 id="1-2-pthread-使用方法"><a href="#1-2-pthread-使用方法" class="headerlink" title="1.2 pthread 使用方法"></a>1.2 pthread 使用方法</h2><ol>
<li>首先要包含头文件<code>#import &lt;pthread.h&gt;</code></li>
<li>其次要创建线程，并开启线程执行任务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 1. 创建线程: 定义一个pthread_t类型变量</span><br><span class="line">pthread_t thread;</span><br><span class="line">// 2. 开启线程: 执行任务</span><br><span class="line">pthread_create(&amp;thread, NULL, run, NULL);</span><br><span class="line">// 3. 设置子线程的状态设置为 detached，该线程运行结束后会自动释放所有资源</span><br><span class="line">pthread_detach(thread);</span><br><span class="line"></span><br><span class="line">void * run(void *param)    // 新线程调用方法，里边为需要执行的任务</span><br><span class="line">&#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line"></span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pthread_create(&amp;thread, NULL, run, NULL);</code> 中各项参数含义：</li>
<li>第一个参数<code>&amp;thread</code>是线程对象，指向线程标识符的指针</li>
<li>第二个是线程属性，可赋值<code>NULL</code></li>
<li>第三个<code>run</code>表示指向函数的指针(run对应函数里是需要在新线程中执行的任务)</li>
<li>第四个是运行函数的参数，可赋值<code>NULL</code></li>
</ul>
<h2 id="1-3-pthread-其他相关方法"><a href="#1-3-pthread-其他相关方法" class="headerlink" title="1.3 pthread 其他相关方法"></a>1.3 pthread 其他相关方法</h2><ul>
<li><code>pthread_create()</code> 创建一个线程</li>
<li><code>pthread_exit()</code> 终止当前线程</li>
<li><code>pthread_cancel()</code> 中断另外一个线程的运行</li>
<li><code>pthread_join()</code> 阻塞当前的线程，直到另外一个线程运行结束</li>
<li><code>pthread_attr_init()</code> 初始化线程的属性</li>
<li><code>pthread_attr_setdetachstate()</code> 设置脱离状态的属性（决定这个线程在终止时是否可以被结合）</li>
<li><code>pthread_attr_getdetachstate()</code> 获取脱离状态的属性</li>
<li><code>pthread_attr_destroy()</code> 删除线程的属性</li>
<li><code>pthread_kill()</code> 向线程发送一个信号</li>
</ul>
<hr>
<h1 id="2-NSThread"><a href="#2-NSThread" class="headerlink" title="2. NSThread"></a>2. NSThread</h1><p>NSThread 是苹果官方提供的，使用起来比 pthread 更加面向对象，简单易用，可以直接操作线程对象。不过也需要需要程序员自己管理线程的生命周期(主要是创建)，我们在开发的过程中偶尔使用 NSThread。比如我们会经常调用<code>[NSThread currentThread]</code>来显示当前的进程信息。</p>
<p>下边我们说说 NSThread 如何使用。</p>
<h2 id="2-1-创建、启动线程"><a href="#2-1-创建、启动线程" class="headerlink" title="2.1 创建、启动线程"></a>2.1 创建、启动线程</h2><ul>
<li>先创建线程，再启动线程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 1. 创建线程</span><br><span class="line">NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];</span><br><span class="line">// 2. 启动线程</span><br><span class="line">[thread start];    // 线程一启动，就会在线程thread中执行self的run方法</span><br><span class="line"></span><br><span class="line">// 新线程调用方法，里边为需要执行的任务</span><br><span class="line">- (void)run &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建线程后自动启动线程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 1. 创建线程后自动启动线程</span><br><span class="line">[NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];</span><br><span class="line"></span><br><span class="line">// 新线程调用方法，里边为需要执行的任务</span><br><span class="line">- (void)run &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>隐式创建并启动线程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 1. 隐式创建并启动线程</span><br><span class="line">[self performSelectorInBackground:@selector(run) withObject:nil];</span><br><span class="line"></span><br><span class="line">// 新线程调用方法，里边为需要执行的任务</span><br><span class="line">- (void)run &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-线程相关用法"><a href="#2-2-线程相关用法" class="headerlink" title="2.2 线程相关用法"></a>2.2 线程相关用法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 获得主线程</span><br><span class="line">+ (NSThread *)mainThread;</span><br><span class="line"></span><br><span class="line">// 判断是否为主线程(对象方法)</span><br><span class="line">- (BOOL)isMainThread;</span><br><span class="line"></span><br><span class="line">// 判断是否为主线程(类方法)</span><br><span class="line">+ (BOOL)isMainThread;</span><br><span class="line"></span><br><span class="line">// 获得当前线程</span><br><span class="line">NSThread *current = [NSThread currentThread];</span><br><span class="line"></span><br><span class="line">// 线程的名字——setter方法</span><br><span class="line">- (void)setName:(NSString *)n;</span><br><span class="line"></span><br><span class="line">// 线程的名字——getter方法</span><br><span class="line">- (NSString *)name;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-线程状态控制方法"><a href="#2-3-线程状态控制方法" class="headerlink" title="2.3 线程状态控制方法"></a>2.3 线程状态控制方法</h2><ul>
<li>启动线程方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)start;</span><br><span class="line">// 线程进入就绪状态 -&gt; 运行状态。当线程任务执行完毕，自动进入死亡状态</span><br></pre></td></tr></table></figure>
<ul>
<li>阻塞（暂停）线!程方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (void)sleepUntilDate:(NSDate *)date;</span><br><span class="line">+ (void)sleepForTimeInterval:(NSTimeInterval)ti;</span><br><span class="line">// 线程进入阻塞状态</span><br></pre></td></tr></table></figure>
<ul>
<li>强制停止线程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (void)exit;</span><br><span class="line">// 线程进入死亡状态</span><br></pre></td></tr></table></figure>
<h2 id="2-4-线程之间的通信"><a href="#2-4-线程之间的通信" class="headerlink" title="2.4 线程之间的通信"></a>2.4 线程之间的通信</h2><p>在开发中，我们经常会在子线程进行耗时操作，操作结束后再回到主线程去刷新 UI。这就涉及到了子线程和主线程之间的通信。我们先来了解一下官方关于 NSThread 的线程间通信的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 在主线程上执行操作</span><br><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;</span><br><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray&lt;NSString *&gt; *)array;</span><br><span class="line">// equivalent to the first method with kCFRunLoopCommonModes</span><br><span class="line"></span><br><span class="line">// 在指定线程上执行操作</span><br><span class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array NS_AVAILABLE(10_5, 2_0);</span><br><span class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait NS_AVAILABLE(10_5, 2_0);</span><br><span class="line"></span><br><span class="line">// 在当前线程上执行操作，调用 NSObject 的 performSelector:相关方法</span><br><span class="line">- (id)performSelector:(SEL)aSelector;</span><br><span class="line">- (id)performSelector:(SEL)aSelector withObject:(id)object;</span><br><span class="line">- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;</span><br></pre></td></tr></table></figure>
<p>下面通过一个经典的下载图片 DEMO 来展示线程之间的通信。具体步骤如下：</p>
<ol>
<li>开启一个子线程，在子线程中下载图片。</li>
<li>回到主线程刷新 UI，将图片展示在 UIImageView 中。</li>
</ol>
<p>DEMO 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 创建一个线程下载图片</span><br><span class="line">*/</span><br><span class="line">- (void)downloadImageOnSubThread &#123;</span><br><span class="line">// 在创建的子线程中调用downloadImage下载图片</span><br><span class="line">[NSThread detachNewThreadSelector:@selector(downloadImage) toTarget:self withObject:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 下载图片，下载完之后回到主线程进行 UI 刷新</span><br><span class="line">*/</span><br><span class="line">- (void)downloadImage &#123;</span><br><span class="line">NSLog(@&quot;current thread -- %@&quot;, [NSThread currentThread]);</span><br><span class="line"></span><br><span class="line">// 1. 获取图片 imageUrl</span><br><span class="line">NSURL *imageUrl = [NSURL URLWithString:@&quot;https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-icon.jpg&quot;];</span><br><span class="line"></span><br><span class="line">// 2. 从 imageUrl 中读取数据(下载图片) -- 耗时操作</span><br><span class="line">NSData *imageData = [NSData dataWithContentsOfURL:imageUrl];</span><br><span class="line">// 通过二进制 data 创建 image</span><br><span class="line">UIImage *image = [UIImage imageWithData:imageData];</span><br><span class="line"></span><br><span class="line">// 3. 回到主线程进行图片赋值和界面刷新</span><br><span class="line">[self performSelectorOnMainThread:@selector(refreshOnMainThread:) withObject:image waitUntilDone:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 回到主线程进行图片赋值和界面刷新</span><br><span class="line">*/</span><br><span class="line">- (void)refreshOnMainThread:(UIImage *)image &#123;</span><br><span class="line">NSLog(@&quot;current thread -- %@&quot;, [NSThread currentThread]);</span><br><span class="line"></span><br><span class="line">// 赋值图片到imageview</span><br><span class="line">self.imageView.image = image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-5-NSThread-线程安全和线程同步"><a href="#2-5-NSThread-线程安全和线程同步" class="headerlink" title="2.5 NSThread 线程安全和线程同步"></a>2.5 NSThread 线程安全和线程同步</h2><p><strong>线程安全</strong>：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<p>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。</p>
<p><strong>线程同步</strong>：可理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。</p>
<p>举个简单例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清(操作冲突)。等一个人说完(一个线程结束操作)，另一个再说(另一个线程再开始操作)。</p>
<p>下面，我们模拟火车票售卖的方式，实现 NSThread 线程安全和解决线程同步问题。</p>
<p>场景：总共有50张火车票，有两个售卖火车票的窗口，一个是北京火车票售卖窗口，另一个是上海火车票售卖窗口。两个窗口同时售卖火车票，卖完为止。</p>
<h3 id="2-5-1-NSThread-非线程安全"><a href="#2-5-1-NSThread-非线程安全" class="headerlink" title="2.5.1 NSThread 非线程安全"></a>2.5.1 NSThread 非线程安全</h3><p>先来看看不考虑线程安全的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 初始化火车票数量、卖票窗口(非线程安全)、并开始卖票</span><br><span class="line">*/</span><br><span class="line">- (void)initTicketStatusNotSave &#123;</span><br><span class="line">// 1. 设置剩余火车票为 50</span><br><span class="line">self.ticketSurplusCount = 50;</span><br><span class="line"></span><br><span class="line">// 2. 设置北京火车票售卖窗口的线程</span><br><span class="line">self.ticketSaleWindow1 = [[NSThread alloc]initWithTarget:self selector:@selector(saleTicketNotSafe) object:nil];</span><br><span class="line">self.ticketSaleWindow1.name = @&quot;北京火车票售票窗口&quot;;</span><br><span class="line"></span><br><span class="line">// 3. 设置上海火车票售卖窗口的线程</span><br><span class="line">self.ticketSaleWindow2 = [[NSThread alloc]initWithTarget:self selector:@selector(saleTicketNotSafe) object:nil];</span><br><span class="line">self.ticketSaleWindow2.name = @&quot;上海火车票售票窗口&quot;;</span><br><span class="line"></span><br><span class="line">// 4. 开始售卖火车票</span><br><span class="line">[self.ticketSaleWindow1 start];</span><br><span class="line">[self.ticketSaleWindow2 start];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 售卖火车票(非线程安全)</span><br><span class="line">*/</span><br><span class="line">- (void)saleTicketNotSafe &#123;</span><br><span class="line">while (1) &#123;</span><br><span class="line">//如果还有票，继续售卖</span><br><span class="line">if (self.ticketSurplusCount &gt; 0) &#123;</span><br><span class="line">self.ticketSurplusCount --;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%ld 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread].name]);</span><br><span class="line">[NSThread sleepForTimeInterval:0.2];</span><br><span class="line">&#125;</span><br><span class="line">//如果已卖完，关闭售票窗口</span><br><span class="line">else &#123;</span><br><span class="line">NSLog(@&quot;所有火车票均已售完&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后部分结果为：</p>
<p><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-NotSave.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-NotSave.png" alt="YSC-phread-NSThread-demo-NotSave.png"></a></p>
<p>可以看到在不考虑线程安全的情况下，得到票数是错乱的，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。</p>
<h3 id="2-5-2-NSThread-线程安全"><a href="#2-5-2-NSThread-线程安全" class="headerlink" title="2.5.2 NSThread 线程安全"></a>2.5.2 NSThread 线程安全</h3><p>线程安全解决方案：可以给线程加锁，在一个线程执行该操作的时候，不允许其他线程进行操作。iOS 实现线程加锁有很多种方式。@synchronized、 NSLock、NSRecursiveLock、NSCondition、NSConditionLock、pthread_mutex、dispatch_semaphore、OSSpinLock、atomic(property) set/ge等等各种方式。为了简单起见，这里不对各种锁的解决方案和性能做分析，只用最简单的<code>@synchronized</code>来保证线程安全，从而解决线程同步问题。</p>
<p>考虑线程安全的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 初始化火车票数量、卖票窗口(线程安全)、并开始卖票</span><br><span class="line">*/</span><br><span class="line">- (void)initTicketStatusSave &#123;</span><br><span class="line">// 1. 设置剩余火车票为 50</span><br><span class="line">self.ticketSurplusCount = 50;</span><br><span class="line"></span><br><span class="line">// 2. 设置北京火车票售卖窗口的线程</span><br><span class="line">self.ticketSaleWindow1 = [[NSThread alloc]initWithTarget:self selector:@selector(saleTicketSafe) object:nil];</span><br><span class="line">self.ticketSaleWindow1.name = @&quot;北京火车票售票窗口&quot;;</span><br><span class="line"></span><br><span class="line">// 3. 设置上海火车票售卖窗口的线程</span><br><span class="line">self.ticketSaleWindow2 = [[NSThread alloc]initWithTarget:self selector:@selector(saleTicketSafe) object:nil];</span><br><span class="line">self.ticketSaleWindow2.name = @&quot;上海火车票售票窗口&quot;;</span><br><span class="line"></span><br><span class="line">// 4. 开始售卖火车票</span><br><span class="line">[self.ticketSaleWindow1 start];</span><br><span class="line">[self.ticketSaleWindow2 start];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 售卖火车票(线程安全)</span><br><span class="line">*/</span><br><span class="line">- (void)saleTicketSafe &#123;</span><br><span class="line">while (1) &#123;</span><br><span class="line">// 互斥锁</span><br><span class="line">@synchronized (self) &#123;</span><br><span class="line">//如果还有票，继续售卖</span><br><span class="line">if (self.ticketSurplusCount &gt; 0) &#123;</span><br><span class="line">self.ticketSurplusCount --;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%ld 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread].name]);</span><br><span class="line">[NSThread sleepForTimeInterval:0.2];</span><br><span class="line">&#125;</span><br><span class="line">//如果已卖完，关闭售票窗口</span><br><span class="line">else &#123;</span><br><span class="line">NSLog(@&quot;所有火车票均已售完&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后结果为：</p>
<p><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-Save.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-Save.png" alt="YSC-phread-NSThread-demo-Save.png"></a></p>
<p>省略一部分结果图。。。</p>
<p><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-Save1.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-Save1.png" alt="YSC-phread-NSThread-demo-Save1.png"></a></p>
<p>可以看出，在考虑了线程安全的情况下，加锁之后，得到的票数是正确的，没有出现混乱的情况。我们也就解决了多个线程同步的问题。</p>
<h2 id="2-6-线程的状态转换"><a href="#2-6-线程的状态转换" class="headerlink" title="2.6 线程的状态转换"></a>2.6 线程的状态转换</h2><p>当我们新建一条线程<code>NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];</code>，在内存中的表现为：</p>
<p><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-StatusChange.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-StatusChange.png" alt="YSC-phread-NSThread-demo-StatusChange.png"></a></p>
<p>当调用<code>[thread start];</code>后，系统把线程对象放入可调度线程池中，线程对象进入就绪状态，如下图所示。</p>
<p><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-StatusChange1.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-StatusChange1.png" alt="YSC-phread-NSThread-demo-StatusChange1.png"></a></p>
<p>当然，可调度线程池中，会有其他的线程对象，如下图所示。在这里我们只关心左边的线程对象。</p>
<p><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-StatusChange2.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-StatusChange2.png" alt="YSC-phread-NSThread-demo-StatusChange2.png"></a></p>
<p><strong>下边我们来看看当前线程的状态转换。</strong></p>
<ul>
<li>如果CPU现在调度当前线程对象，则当前线程对象进入运行状态，如果CPU调度其他线程对象，则当前线程对象回到就绪状态。</li>
<li>如果CPU在运行当前线程对象的时候调用了sleep方法\等待同步锁，则当前线程对象就进入了阻塞状态，等到sleep到时\得到同步锁，则回到就绪状态。</li>
<li>如果CPU在运行当前线程对象的时候线程任务执行完毕\异常强制退出，则当前线程对象进入死亡状态。</li>
</ul>
<p>只看文字可能不太好理解，具体当前线程对象的状态变化如下图所示。</p>
<p><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-StatusChange3.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-StatusChange3.png" alt="YSC-phread-NSThread-demo-StatusChange3.png"></a></p>
<hr>
<p>iOS多线程详尽总结系列文章：</p>
<ul>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-pthread-and-NSThread.html" target="_blank" rel="noopener">iOS多线程：『pthread、NSThread』详尽总结</a></li>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-GCD.html" target="_blank" rel="noopener">iOS多线程：『GCD』详解总结</a></li>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-NSOperation.html" target="_blank" rel="noopener">iOS多线程：『NSOperation』详解总结</a></li>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-RunLoop.html" target="_blank" rel="noopener">iOS多线程：『RunLoop』详解总结</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/NSOperation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/NSOperation/" itemprop="url">
                  NSOperation
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 12:17:42 / 修改时间：14:29:19" itemprop="dateCreated datePublished" datetime="2018-09-17T12:17:42+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/多线程/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[转自 <a href="https://bujige.net/" target="_blank" rel="noopener">『不羁阁』 | 行走的少年郎 - 博客</a></p>
<p><a href="https://bujige.net/blog/iOS-Complete-learning-NSOperation.html" target="_blank" rel="noopener">**](https://bujige.net/)</a></p>
<p><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-background.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-background.png" alt="img"></a></p>
<blockquote>
<p>本文用来介绍 iOS 多线程中 NSOperation、NSOperationQueue 的相关知识以及使用方法。<br>通过本文，您将了解到：<br><strong>NSOperation、NSOperationQueue 简介</strong>、<strong>操作和操作队列</strong>、<strong>使用步骤和基本使用方法</strong>、<strong>控制串行/并发执行</strong>、<strong>NSOperation 操作依赖和优先级</strong>、<strong>线程间的通信</strong>、<strong>线程同步和线程安全</strong>，以及 <strong>NSOperation、NSOperationQueue 常用属性和方法归纳</strong>。</p>
<p>文中 Demo 我已放在了 Github 上，Demo 链接：<a href="https://github.com/bujige/YSC-NSOperation-demo" target="_blank" rel="noopener">传送门</a></p>
</blockquote>
<h1 id="1-NSOperation、NSOperationQueue-简介"><a href="#1-NSOperation、NSOperationQueue-简介" class="headerlink" title="1. NSOperation、NSOperationQueue 简介"></a>1. NSOperation、NSOperationQueue 简介</h1><p>NSOperation、NSOperationQueue 是苹果提供给我们的一套多线程解决方案。实际上 NSOperation、NSOperationQueue 是基于 GCD 更高一层的封装，完全面向对象。但是比 GCD 更简单易用、代码可读性也更高。</p>
<p><strong>为什么要使用 NSOperation、NSOperationQueue？</strong></p>
<ol>
<li>可添加完成的代码块，在操作完成后执行。</li>
<li>添加操作之间的依赖关系，方便的控制执行顺序。</li>
<li>设定操作执行的优先级。</li>
<li>可以很方便的取消一个操作的执行。</li>
<li>使用 KVO 观察对操作执行状态的更改：isExecuteing、isFinished、isCancelled。</li>
</ol>
<h1 id="2-NSOperation、NSOperationQueue-操作和操作队列"><a href="#2-NSOperation、NSOperationQueue-操作和操作队列" class="headerlink" title="2. NSOperation、NSOperationQueue 操作和操作队列"></a>2. NSOperation、NSOperationQueue 操作和操作队列</h1><p>既然是基于 GCD 的更高一层的封装。那么，GCD 中的一些概念同样适用于 NSOperation、NSOperationQueue。在 NSOperation、NSOperationQueue 中也有类似的<strong>任务（操作）</strong>和<strong>队列（操作队列）</strong>的概念。</p>
<ul>
<li>操作（Operation）：<ul>
<li>执行操作的意思，换句话说就是你在线程中执行的那段代码。</li>
<li>在 GCD 中是放在 block 中的。在 NSOperation 中，我们使用 NSOperation 子类 <strong>NSInvocationOperation</strong>、<strong>NSBlockOperation</strong>，或者<strong>自定义子类</strong>来封装操作。</li>
</ul>
</li>
<li>操作队列（Operation Queues）：<ul>
<li>这里的队列指操作队列，即用来存放操作的队列。不同于 GCD 中的调度队列 FIFO（先进先出）的原则。NSOperationQueue 对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的<strong>开始执行顺序</strong>（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。</li>
<li>操作队列通过设置<strong>最大并发操作数（maxConcurrentOperationCount）</strong>来控制并发、串行。</li>
<li>NSOperationQueue 为我们提供了两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。</li>
</ul>
</li>
</ul>
<h1 id="3-NSOperation、NSOperationQueue-使用步骤"><a href="#3-NSOperation、NSOperationQueue-使用步骤" class="headerlink" title="3. NSOperation、NSOperationQueue 使用步骤"></a>3. NSOperation、NSOperationQueue 使用步骤</h1><p>NSOperation 需要配合 NSOperationQueue 来实现多线程。因为默认情况下，NSOperation 单独使用时系统同步执行操作，配合 NSOperationQueue 我们能更好的实现异步执行。</p>
<p>NSOperation 实现多线程的使用步骤分为三步：</p>
<ol>
<li>创建操作：先将需要执行的操作封装到一个 NSOperation 对象中。</li>
<li>创建队列：创建 NSOperationQueue 对象。</li>
<li>将操作加入到队列中：将 NSOperation 对象添加到 NSOperationQueue 对象中。</li>
</ol>
<p>之后呢，系统就会自动将 NSOperationQueue 中的 NSOperation 取出来，在新线程中执行操作。</p>
<p>下面我们来学习下 NSOperation 和 NSOperationQueue 的基本使用。</p>
<h1 id="4-NSOperation-和-NSOperationQueue-基本使用"><a href="#4-NSOperation-和-NSOperationQueue-基本使用" class="headerlink" title="4. NSOperation 和 NSOperationQueue 基本使用"></a>4. NSOperation 和 NSOperationQueue 基本使用</h1><h2 id="4-1-创建操作"><a href="#4-1-创建操作" class="headerlink" title="4.1 创建操作"></a>4.1 创建操作</h2><p>NSOperation 是个抽象类，不能用来封装操作。我们只有使用它的子类来封装操作。我们有三种方式来封装操作。</p>
<ol>
<li>使用子类 NSInvocationOperation</li>
<li>使用子类 NSBlockOperation</li>
<li>自定义继承自 NSOperation 的子类，通过实现内部相应的方法来封装操作。</li>
</ol>
<p>在不使用 NSOperationQueue，单独使用 NSOperation 的情况下系统同步执行操作，下面我们学习以下操作的三种创建方式。</p>
<h3 id="4-1-1-使用子类-NSInvocationOperation"><a href="#4-1-1-使用子类-NSInvocationOperation" class="headerlink" title="4.1.1 使用子类 NSInvocationOperation"></a>4.1.1 使用子类 <code>NSInvocationOperation</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用子类 NSInvocationOperation</span><br><span class="line"> */</span><br><span class="line">- (void)useInvocationOperation &#123;</span><br><span class="line"></span><br><span class="line">    // 1.创建 NSInvocationOperation 对象</span><br><span class="line">    NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task1) object:nil];</span><br><span class="line"></span><br><span class="line">    // 2.调用 start 方法开始执行操作</span><br><span class="line">    [op start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 任务1</span><br><span class="line"> */</span><br><span class="line">- (void)task1 &#123;</span><br><span class="line">    for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">        NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result01.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result01.png" alt="img"></a></p>
</blockquote>
<ul>
<li>可以看到：在没有使用 NSOperationQueue、在主线程中单独使用使用子类 NSInvocationOperation 执行一个操作的情况下，操作是在当前线程执行的，并没有开启新线程。</li>
</ul>
<p>如果在其他线程中执行操作，则打印结果为其他线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 在其他线程使用子类 NSInvocationOperation</span><br><span class="line">[NSThread detachNewThreadSelector:@selector(useInvocationOperation) toTarget:self withObject:nil];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result02.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result02.png" alt="img"></a></p>
</blockquote>
<ul>
<li>可以看到：在其他线程中单独使用子类 NSInvocationOperation，操作是在当前调用的其他线程执行的，并没有开启新线程。</li>
</ul>
<p>下边再来看看 NSBlockOperation。</p>
<h3 id="4-1-2-使用子类-NSBlockOperation"><a href="#4-1-2-使用子类-NSBlockOperation" class="headerlink" title="4.1.2 使用子类 NSBlockOperation"></a>4.1.2 使用子类 <code>NSBlockOperation</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用子类 NSBlockOperation</span><br><span class="line"> */</span><br><span class="line">- (void)useBlockOperation &#123;</span><br><span class="line"></span><br><span class="line">    // 1.创建 NSBlockOperation 对象</span><br><span class="line">    NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 2.调用 start 方法开始执行操作</span><br><span class="line">    [op start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result03.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result03.png" alt="img"></a></p>
</blockquote>
<ul>
<li>可以看到：在没有使用 NSOperationQueue、在主线程中单独使用 NSBlockOperation 执行一个操作的情况下，操作是在当前线程执行的，并没有开启新线程。</li>
</ul>
<blockquote>
<p>注意：和上边 NSInvocationOperation 使用一样。因为代码是在主线程中调用的，所以打印结果为主线程。如果在其他线程中执行操作，则打印结果为其他线程。</p>
</blockquote>
<p>但是，NSBlockOperation 还提供了一个方法 <code>addExecutionBlock:</code>，通过 <code>addExecutionBlock:</code> 就可以为 NSBlockOperation 添加额外的操作。这些操作（包括 blockOperationWithBlock 中的操作）可以在不同的线程中同时（并发）执行。只有当所有相关的操作已经完成执行时，才视为完成。</p>
<p>如果添加的操作多的话，<code>blockOperationWithBlock:</code> 中的操作也可能会在其他线程（非当前线程）中执行，这是由系统决定的，并不是说添加到 <code>blockOperationWithBlock:</code> 中的操作一定会在当前线程中执行。（可以使用 <code>addExecutionBlock:</code> 多添加几个操作试试）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用子类 NSBlockOperation</span><br><span class="line"> * 调用方法 AddExecutionBlock:</span><br><span class="line"> */</span><br><span class="line">- (void)useBlockOperationAddExecutionBlock &#123;</span><br><span class="line"></span><br><span class="line">    // 1.创建 NSBlockOperation 对象</span><br><span class="line">    NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 2.添加额外的操作</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;5---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;6---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;7---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;8---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 3.调用 start 方法开始执行操作</span><br><span class="line">    [op start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result04.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result04.png" alt="img"></a></p>
</blockquote>
<ul>
<li>可以看出：使用子类 <code>NSBlockOperation</code>，并调用方法 <code>AddExecutionBlock:</code> 的情况下，<code>blockOperationWithBlock:</code>方法中的操作 和 <code>addExecutionBlock:</code> 中的操作是在不同的线程中异步执行的。而且，这次执行结果中 <code>blockOperationWithBlock:</code>方法中的操作也不是在当前线程（主线程）中执行的。从而印证了<code>blockOperationWithBlock:</code> 中的操作也可能会在其他线程（非当前线程）中执行。</li>
</ul>
<p>一般情况下，如果一个 NSBlockOperation 对象封装了多个操作。NSBlockOperation 是否开启新线程，取决于操作的个数。如果添加的操作的个数多，就会自动开启新线程。当然开启的线程数是由系统来决定的。</p>
<h3 id="4-1-3-使用自定义继承自-NSOperation-的子类"><a href="#4-1-3-使用自定义继承自-NSOperation-的子类" class="headerlink" title="4.1.3 使用自定义继承自 NSOperation 的子类"></a>4.1.3 使用自定义继承自 NSOperation 的子类</h3><p>如果使用子类 NSInvocationOperation、NSBlockOperation 不能满足日常需求，我们可以使用自定义继承自 NSOperation 的子类。可以通过重写 <code>main</code> 或者 <code>start</code> 方法 来定义自己的 NSOperation 对象。重写<code>main</code>方法比较简单，我们不需要管理操作的状态属性 <code>isExecuting</code> 和 <code>isFinished</code>。当 <code>main</code> 执行完返回的时候，这个操作就结束了。</p>
<p>先定义一个继承自 NSOperation 的子类，重写<code>main</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// YSCOperation.h 文件</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface YSCOperation : NSOperation</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// YSCOperation.m 文件</span><br><span class="line">#import &quot;YSCOperation.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation YSCOperation</span><br><span class="line"></span><br><span class="line">- (void)main &#123;</span><br><span class="line">    if (!self.isCancelled) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>然后使用的时候导入头文件<code>YSCOperation.h</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用自定义继承自 NSOperation 的子类</span><br><span class="line"> */</span><br><span class="line">- (void)useCustomOperation &#123;</span><br><span class="line">    // 1.创建 YSCOperation 对象</span><br><span class="line">    YSCOperation *op = [[YSCOperation alloc] init];</span><br><span class="line">    // 2.调用 start 方法开始执行操作</span><br><span class="line">    [op start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result05.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result05.png" alt="img"></a></p>
</blockquote>
<ul>
<li>可以看出：在没有使用 NSOperationQueue、在主线程单独使用自定义继承自 NSOperation 的子类的情况下，是在主线程执行操作，并没有开启新线程。</li>
</ul>
<p>下边我们来讲讲 NSOperationQueue 的创建。</p>
<h2 id="4-2-创建队列"><a href="#4-2-创建队列" class="headerlink" title="4.2 创建队列"></a>4.2 创建队列</h2><p>NSOperationQueue 一共有两种队列：主队列、自定义队列。其中自定义队列同时包含了串行、并发功能。下边是主队列、自定义队列的基本创建方法和特点。</p>
<ul>
<li>主队列<ul>
<li>凡是添加到主队列中的操作，都会放到主线程中执行。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 主队列获取方法</span><br><span class="line">NSOperationQueue *queue = [NSOperationQueue mainQueue];</span><br></pre></td></tr></table></figure>
<ul>
<li>自定义队列（非主队列）<ul>
<li>添加到这种队列中的操作，就会自动放到子线程中执行。</li>
<li>同时包含了：串行、并发功能。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 自定义队列创建方法</span><br><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br></pre></td></tr></table></figure>
<h2 id="4-3-将操作加入到队列中"><a href="#4-3-将操作加入到队列中" class="headerlink" title="4.3 将操作加入到队列中"></a>4.3 将操作加入到队列中</h2><p>上边我们说到 NSOperation 需要配合 NSOperationQueue 来实现多线程。</p>
<p>那么我们需要将创建好的操作加入到队列中去。总共有两种方法：</p>
<ol>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)addOperation:(NSOperation *)op;</span><br></pre></td></tr></table></figure>
<ul>
<li>需要先创建操作，再将创建好的操作加入到创建好的队列中去。</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用 addOperation: 将操作加入到操作队列中</span><br><span class="line"> */</span><br><span class="line">- (void)addOperationToQueue &#123;</span><br><span class="line"></span><br><span class="line">    // 1.创建队列</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line"></span><br><span class="line">    // 2.创建操作</span><br><span class="line">    // 使用 NSInvocationOperation 创建操作1</span><br><span class="line">    NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task1) object:nil];</span><br><span class="line"></span><br><span class="line">    // 使用 NSInvocationOperation 创建操作2</span><br><span class="line">    NSInvocationOperation *op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task2) object:nil];</span><br><span class="line"></span><br><span class="line">    // 使用 NSBlockOperation 创建操作3</span><br><span class="line">    NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op3 addExecutionBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 3.使用 addOperation: 添加所有操作到队列中</span><br><span class="line">    [queue addOperation:op1]; // [op1 start]</span><br><span class="line">    [queue addOperation:op2]; // [op2 start]</span><br><span class="line">    [queue addOperation:op3]; // [op3 start]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result06.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result06.png" alt="img"></a></p>
</blockquote>
<ul>
<li>可以看出：使用 NSOperation 子类创建操作，并使用 <code>addOperation:</code> 将操作加入到操作队列后能够开启新线程，进行并发执行。</li>
</ul>
<ol>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)addOperationWithBlock:(void (^)(void))block;</span><br></pre></td></tr></table></figure>
<ul>
<li>无需先创建操作，在 block 中添加操作，直接将包含操作的 block 加入到队列中。</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用 addOperationWithBlock: 将操作加入到操作队列中</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">- (void)addOperationWithBlockToQueue &#123;</span><br><span class="line">    // 1.创建队列</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line"></span><br><span class="line">    // 2.使用 addOperationWithBlock: 添加操作到队列中</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result07.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result07.png" alt="img"></a></p>
</blockquote>
<ul>
<li>可以看出：使用 addOperationWithBlock: 将操作加入到操作队列后能够开启新线程，进行并发执行。</li>
</ul>
<h1 id="5-NSOperationQueue-控制串行执行、并发执行"><a href="#5-NSOperationQueue-控制串行执行、并发执行" class="headerlink" title="5. NSOperationQueue 控制串行执行、并发执行"></a>5. NSOperationQueue 控制串行执行、并发执行</h1><p>之前我们说过，NSOperationQueue 创建的自定义队列同时具有串行、并发功能，上边我们演示了并发功能，那么他的串行功能是如何实现的？</p>
<p>这里有个关键属性 <code>maxConcurrentOperationCount</code>，叫做<strong>最大并发操作数</strong>。用来控制一个特定队列中可以有多少个操作同时参与并发执行。</p>
<blockquote>
<p>注意：这里 <code>maxConcurrentOperationCount</code> 控制的不是并发线程的数量，而是一个队列中同时能并发执行的最大操作数。而且一个操作也并非只能在一个线程中运行。</p>
</blockquote>
<ul>
<li><p>最大并发操作数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxConcurrentOperationCount</span><br></pre></td></tr></table></figure>
<ul>
<li><code>maxConcurrentOperationCount</code> 默认情况下为-1，表示不进行限制，可进行并发执行。</li>
<li><code>maxConcurrentOperationCount</code> 为1时，队列为串行队列。只能串行执行。</li>
<li><code>maxConcurrentOperationCount</code> 大于1时，队列为并发队列。操作并发执行，当然这个值不应超过系统限制，即使自己设置一个很大的值，系统也会自动调整为 min{自己设定的值，系统设定的默认最大值}。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 设置 MaxConcurrentOperationCount（最大并发操作数）</span><br><span class="line"> */</span><br><span class="line">- (void)setMaxConcurrentOperationCount &#123;</span><br><span class="line"></span><br><span class="line">    // 1.创建队列</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line"></span><br><span class="line">    // 2.设置最大并发操作数</span><br><span class="line">    queue.maxConcurrentOperationCount = 1; // 串行队列</span><br><span class="line">// queue.maxConcurrentOperationCount = 2; // 并发队列</span><br><span class="line">// queue.maxConcurrentOperationCount = 8; // 并发队列</span><br><span class="line"></span><br><span class="line">    // 3.添加操作</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最大并发操作数为1 输出结果：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result08.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result08.png" alt="img"></a><br>最大并发操作数为2 输出结果：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result09.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result09.png" alt="img"></a></p>
</blockquote>
<ul>
<li>可以看出：当最大并发操作数为1时，操作是按顺序串行执行的，并且一个操作完成之后，下一个操作才开始执行。当最大操作并发数为2时，操作是并发执行的，可以同时执行两个操作。而开启线程数量是由系统决定的，不需要我们来管理。</li>
</ul>
<p>这样看来，是不是比 GCD 还要简单了许多？</p>
<h1 id="6-NSOperation-操作依赖"><a href="#6-NSOperation-操作依赖" class="headerlink" title="6. NSOperation 操作依赖"></a>6. NSOperation 操作依赖</h1><p>NSOperation、NSOperationQueue 最吸引人的地方是它能添加操作之间的依赖关系。通过操作依赖，我们可以很方便的控制操作之间的执行先后顺序。NSOperation 提供了3个接口供我们管理和查看依赖。</p>
<ul>
<li><code>- (void)addDependency:(NSOperation *)op;</code> 添加依赖，使当前操作依赖于操作 op 的完成。</li>
<li><code>- (void)removeDependency:(NSOperation *)op;</code> 移除依赖，取消当前操作对操作 op 的依赖。</li>
<li><code>@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies;</code> 在当前操作开始执行之前完成执行的所有操作对象数组。</li>
</ul>
<p>当然，我们经常用到的还是添加依赖操作。现在考虑这样的需求，比如说有 A、B 两个操作，其中 A 执行完操作，B 才能执行操作。</p>
<p>如果使用依赖来处理的话，那么就需要让操作 B 依赖于操作 A。具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 操作依赖</span><br><span class="line"> * 使用方法：addDependency:</span><br><span class="line"> */</span><br><span class="line">- (void)addDependency &#123;</span><br><span class="line"></span><br><span class="line">    // 1.创建队列</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line"></span><br><span class="line">    // 2.创建操作</span><br><span class="line">    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 3.添加依赖</span><br><span class="line">    [op2 addDependency:op1]; // 让op2 依赖于 op1，则先执行op1，在执行op2</span><br><span class="line"></span><br><span class="line">    // 4.添加操作到队列中</span><br><span class="line">    [queue addOperation:op1];</span><br><span class="line">    [queue addOperation:op2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result10.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result10.png" alt="img"></a></p>
</blockquote>
<ul>
<li>可以看到：通过添加操作依赖，无论运行几次，其结果都是 op1 先执行，op2 后执行。</li>
</ul>
<h1 id="7-NSOperation-优先级"><a href="#7-NSOperation-优先级" class="headerlink" title="7. NSOperation 优先级"></a>7. NSOperation 优先级</h1><p>NSOperation 提供了<code>queuePriority</code>（优先级）属性，<code>queuePriority</code>属性适用于同一操作队列中的操作，不适用于不同操作队列中的操作。默认情况下，所有新创建的操作对象优先级都是<code>NSOperationQueuePriorityNormal</code>。但是我们可以通过<code>setQueuePriority:</code>方法来改变当前操作在同一队列中的执行优先级。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 优先级的取值</span><br><span class="line">typedef NS_ENUM(NSInteger, NSOperationQueuePriority) &#123;</span><br><span class="line">    NSOperationQueuePriorityVeryLow = -8L,</span><br><span class="line">    NSOperationQueuePriorityLow = -4L,</span><br><span class="line">    NSOperationQueuePriorityNormal = 0,</span><br><span class="line">    NSOperationQueuePriorityHigh = 4,</span><br><span class="line">    NSOperationQueuePriorityVeryHigh = 8</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上边我们说过：对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的<strong>开始执行顺序</strong>（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。</p>
<p><strong>那么，什么样的操作才是进入就绪状态的操作呢？</strong></p>
<ul>
<li>当一个操作的所有依赖都已经完成时，操作对象通常会进入准备就绪状态，等待执行。</li>
</ul>
<p>举个例子，现在有4个优先级都是 <code>NSOperationQueuePriorityNormal</code>（默认级别）的操作：op1，op2，op3，op4。其中 op3 依赖于 op2，op2 依赖于 op1，即 op3 -&gt; op2 -&gt; op1。现在将这4个操作添加到队列中并发执行。</p>
<ul>
<li>因为 op1 和 op4 都没有需要依赖的操作，所以在 op1，op4 执行之前，就是出于准备就绪状态的操作。</li>
<li>而 op3 和 op2 都有依赖的操作（op3 依赖于 op2，op2 依赖于 op1），所以 op3 和 op2 都不是准备就绪状态下的操作。</li>
</ul>
<p>理解了进入就绪状态的操作，那么我们就理解了<code>queuePriority</code> 属性的作用对象。</p>
<ul>
<li><code>queuePriority</code> 属性决定了<strong>进入准备就绪状态下的操作</strong>之间的开始执行顺序。并且，优先级不能取代依赖关系。</li>
<li>如果一个队列中既包含高优先级操作，又包含低优先级操作，并且两个操作都已经准备就绪，那么队列先执行高优先级操作。比如上例中，如果 op1 和 op4 是不同优先级的操作，那么就会先执行优先级高的操作。</li>
<li>如果，一个队列中既包含了准备就绪状态的操作，又包含了未准备就绪的操作，未准备就绪的操作优先级比准备就绪的操作优先级高。那么，虽然准备就绪的操作优先级低，也会优先执行。优先级不能取代依赖关系。如果要控制操作间的启动顺序，则必须使用依赖关系。</li>
</ul>
<h1 id="8-NSOperation、NSOperationQueue-线程间的通信"><a href="#8-NSOperation、NSOperationQueue-线程间的通信" class="headerlink" title="8. NSOperation、NSOperationQueue 线程间的通信"></a>8. NSOperation、NSOperationQueue 线程间的通信</h1><p>在 iOS 开发过程中，我们一般在主线程里边进行 UI 刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线程间通信</span><br><span class="line"> */</span><br><span class="line">- (void)communication &#123;</span><br><span class="line"></span><br><span class="line">    // 1.创建队列</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc]init];</span><br><span class="line"></span><br><span class="line">    // 2.添加操作</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        // 异步进行耗时操作</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 回到主线程</span><br><span class="line">        [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">            // 进行一些 UI 刷新等操作</span><br><span class="line">            for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">                [NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">                NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result11.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result11.png" alt="img"></a></p>
</blockquote>
<ul>
<li>可以看到：通过线程间的通信，先在其他线程中执行操作，等操作执行完了之后再回到主线程执行主线程的相应操作。</li>
</ul>
<h1 id="9-NSOperation、NSOperationQueue-线程同步和线程安全"><a href="#9-NSOperation、NSOperationQueue-线程同步和线程安全" class="headerlink" title="9. NSOperation、NSOperationQueue 线程同步和线程安全"></a>9. NSOperation、NSOperationQueue 线程同步和线程安全</h1><ul>
<li><strong>线程安全</strong>：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。<br>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。</li>
<li><strong>线程同步</strong>：可理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。</li>
</ul>
<p>举个简单例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清(操作冲突)。等一个人说完(一个线程结束操作)，另一个再说(另一个线程再开始操作)。</p>
<p>下面，我们模拟火车票售卖的方式，实现 NSOperation 线程安全和解决线程同步问题。<br>场景：总共有50张火车票，有两个售卖火车票的窗口，一个是北京火车票售卖窗口，另一个是上海火车票售卖窗口。两个窗口同时售卖火车票，卖完为止。</p>
<h2 id="9-1-NSOperation、NSOperationQueue-非线程安全"><a href="#9-1-NSOperation、NSOperationQueue-非线程安全" class="headerlink" title="9.1 NSOperation、NSOperationQueue 非线程安全"></a>9.1 NSOperation、NSOperationQueue 非线程安全</h2><p>先来看看不考虑线程安全的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 非线程安全：不使用 NSLock</span><br><span class="line"> * 初始化火车票数量、卖票窗口(非线程安全)、并开始卖票</span><br><span class="line"> */</span><br><span class="line">- (void)initTicketStatusNotSave &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程</span><br><span class="line"></span><br><span class="line">    self.ticketSurplusCount = 50;</span><br><span class="line"></span><br><span class="line">    // 1.创建 queue1,queue1 代表北京火车票售卖窗口</span><br><span class="line">    NSOperationQueue *queue1 = [[NSOperationQueue alloc] init];</span><br><span class="line">    queue1.maxConcurrentOperationCount = 1;</span><br><span class="line"></span><br><span class="line">    // 2.创建 queue2,queue2 代表上海火车票售卖窗口</span><br><span class="line">    NSOperationQueue *queue2 = [[NSOperationQueue alloc] init];</span><br><span class="line">    queue2.maxConcurrentOperationCount = 1;</span><br><span class="line"></span><br><span class="line">    // 3.创建卖票操作 op1</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        [weakSelf saleTicketNotSafe];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 4.创建卖票操作 op2</span><br><span class="line">    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        [weakSelf saleTicketNotSafe];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 5.添加操作，开始卖票</span><br><span class="line">    [queue1 addOperation:op1];</span><br><span class="line">    [queue2 addOperation:op2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 售卖火车票(非线程安全)</span><br><span class="line"> */</span><br><span class="line">- (void)saleTicketNotSafe &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line"></span><br><span class="line">        if (self.ticketSurplusCount &gt; 0) &#123;</span><br><span class="line">            //如果还有票，继续售卖</span><br><span class="line">            self.ticketSurplusCount--;</span><br><span class="line">            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数:%d 窗口:%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]);</span><br><span class="line">            [NSThread sleepForTimeInterval:0.2];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            NSLog(@&quot;所有火车票均已售完&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result13.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result13.png" alt="img"></a><br>……<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result14.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result14.png" alt="img"></a></p>
</blockquote>
<ul>
<li>可以看到：在不考虑线程安全，不使用 NSLock 情况下，得到票数是错乱的，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。</li>
</ul>
<h2 id="9-2-NSOperation、NSOperationQueue-非线程安全"><a href="#9-2-NSOperation、NSOperationQueue-非线程安全" class="headerlink" title="9.2 NSOperation、NSOperationQueue 非线程安全"></a>9.2 NSOperation、NSOperationQueue 非线程安全</h2><p>线程安全解决方案：可以给线程加锁，在一个线程执行该操作的时候，不允许其他线程进行操作。iOS 实现线程加锁有很多种方式。@synchronized、 NSLock、NSRecursiveLock、NSCondition、NSConditionLock、pthread_mutex、dispatch_semaphore、OSSpinLock、atomic(property) set/ge等等各种方式。这里我们使用 NSLock 对象来解决线程同步问题。NSLock 对象可以通过进入锁时调用 lock 方法，解锁时调用 unlock 方法来保证线程安全。</p>
<p>考虑线程安全的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线程安全：使用 NSLock 加锁</span><br><span class="line"> * 初始化火车票数量、卖票窗口(线程安全)、并开始卖票</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">- (void)initTicketStatusSave &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程</span><br><span class="line"></span><br><span class="line">    self.ticketSurplusCount = 50;</span><br><span class="line"></span><br><span class="line">    self.lock = [[NSLock alloc] init];  // 初始化 NSLock 对象</span><br><span class="line"></span><br><span class="line">    // 1.创建 queue1,queue1 代表北京火车票售卖窗口</span><br><span class="line">    NSOperationQueue *queue1 = [[NSOperationQueue alloc] init];</span><br><span class="line">    queue1.maxConcurrentOperationCount = 1;</span><br><span class="line"></span><br><span class="line">    // 2.创建 queue2,queue2 代表上海火车票售卖窗口</span><br><span class="line">    NSOperationQueue *queue2 = [[NSOperationQueue alloc] init];</span><br><span class="line">    queue2.maxConcurrentOperationCount = 1;</span><br><span class="line"></span><br><span class="line">    // 3.创建卖票操作 op1</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        [weakSelf saleTicketSafe];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 4.创建卖票操作 op2</span><br><span class="line">    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        [weakSelf saleTicketSafe];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 5.添加操作，开始卖票</span><br><span class="line">    [queue1 addOperation:op1];</span><br><span class="line">    [queue2 addOperation:op2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 售卖火车票(线程安全)</span><br><span class="line"> */</span><br><span class="line">- (void)saleTicketSafe &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line"></span><br><span class="line">        // 加锁</span><br><span class="line">        [self.lock lock];</span><br><span class="line"></span><br><span class="line">        if (self.ticketSurplusCount &gt; 0) &#123;</span><br><span class="line">            //如果还有票，继续售卖</span><br><span class="line">            self.ticketSurplusCount--;</span><br><span class="line">            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数:%d 窗口:%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]);</span><br><span class="line">            [NSThread sleepForTimeInterval:0.2];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 解锁</span><br><span class="line">        [self.lock unlock];</span><br><span class="line"></span><br><span class="line">        if (self.ticketSurplusCount &lt;= 0) &#123;</span><br><span class="line">            NSLog(@&quot;所有火车票均已售完&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result15.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result15.png" alt="img"></a><br>……<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result16.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-NSOperation-demo-result16.png" alt="img"></a></p>
</blockquote>
<ul>
<li>可以看出：在考虑了线程安全，使用 NSLock 加锁、解锁机制的情况下，得到的票数是正确的，没有出现混乱的情况。我们也就解决了多个线程同步的问题。</li>
</ul>
<h1 id="10-NSOperation、NSOperationQueue-常用属性和方法归纳"><a href="#10-NSOperation、NSOperationQueue-常用属性和方法归纳" class="headerlink" title="10. NSOperation、NSOperationQueue 常用属性和方法归纳"></a>10. NSOperation、NSOperationQueue 常用属性和方法归纳</h1><h2 id="10-1-NSOperation-常用属性和方法"><a href="#10-1-NSOperation-常用属性和方法" class="headerlink" title="10.1 NSOperation 常用属性和方法"></a>10.1 NSOperation 常用属性和方法</h2><ol>
<li>取消操作方法<ul>
<li><code>- (void)cancel;</code> 可取消操作，实质是标记 isCancelled 状态。</li>
</ul>
</li>
<li>判断操作状态方法<ul>
<li><code>- (BOOL)isFinished;</code> 判断操作是否已经结束。</li>
<li><code>- (BOOL)isCancelled;</code> 判断操作是否已经标记为取消。</li>
<li><code>- (BOOL)isExecuting;</code> 判断操作是否正在在运行。</li>
<li><code>- (BOOL)isReady;</code> 判断操作是否处于准备就绪状态，这个值和操作的依赖关系相关。</li>
</ul>
</li>
<li>操作同步<ul>
<li><code>- (void)waitUntilFinished;</code> 阻塞当前线程，直到该操作结束。可用于线程执行顺序的同步。</li>
<li><code>- (void)setCompletionBlock:(void (^)(void))block;</code> <code>completionBlock</code> 会在当前操作执行完毕时执行 completionBlock。</li>
<li><code>- (void)addDependency:(NSOperation *)op;</code> 添加依赖，使当前操作依赖于操作 op 的完成。</li>
<li><code>- (void)removeDependency:(NSOperation *)op;</code> 移除依赖，取消当前操作对操作 op 的依赖。</li>
<li><code>@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies;</code> 在当前操作开始执行之前完成执行的所有操作对象数组。</li>
</ul>
</li>
</ol>
<h2 id="10-2-NSOperationQueue-常用属性和方法"><a href="#10-2-NSOperationQueue-常用属性和方法" class="headerlink" title="10.2 NSOperationQueue 常用属性和方法"></a>10.2 NSOperationQueue 常用属性和方法</h2><ol>
<li>取消/暂停/恢复操作<ul>
<li><code>- (void)cancelAllOperations;</code> 可以取消队列的所有操作。</li>
<li><code>- (BOOL)isSuspended;</code> 判断队列是否处于暂停状态。 YES 为暂停状态，NO 为恢复状态。</li>
<li><code>- (void)setSuspended:(BOOL)b;</code> 可设置操作的暂停和恢复，YES 代表暂停队列，NO 代表恢复队列。</li>
</ul>
</li>
<li>操作同步<ul>
<li><code>- (void)waitUntilAllOperationsAreFinished;</code> 阻塞当前线程，直到队列中的操作全部执行完毕。</li>
</ul>
</li>
<li>添加/获取操作`<ul>
<li><code>- (void)addOperationWithBlock:(void (^)(void))block;</code> 向队列中添加一个 NSBlockOperation 类型操作对象。</li>
<li><code>- (void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait;</code> 向队列中添加操作数组，wait 标志是否阻塞当前线程直到所有操作结束</li>
<li><code>- (NSArray *)operations;</code> 当前在队列中的操作数组（某个操作执行结束后会自动从这个数组清除）。</li>
<li><code>- (NSUInteger)operationCount;</code> 当前队列中的操作数。</li>
</ul>
</li>
<li>获取队列<ul>
<li><code>+ (id)currentQueue;</code> 获取当前队列，如果当前线程不是在 NSOperationQueue 上运行则返回 nil。</li>
<li><code>+ (id)mainQueue;</code> 获取主队列。</li>
</ul>
</li>
</ol>
<blockquote>
<p>注意：</p>
<ol>
<li>这里的暂停和取消（包括操作的取消和队列的取消）并不代表可以将当前的操作立即取消，而是当当前的操作执行完毕之后不再执行新的操作。</li>
<li>暂停和取消的区别就在于：暂停操作之后还可以恢复操作，继续向下执行；而取消操作之后，所有的操作就清空了，无法再接着执行剩下的操作。</li>
</ol>
</blockquote>
<hr>
<p>参考资料：</p>
<ul>
<li><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html" target="_blank" rel="noopener">苹果官方——并发编程指南：Operation Queues</a> <strong>推荐看看</strong></li>
<li><a href="https://developer.apple.com/documentation/foundation/nsoperation?language=occ" target="_blank" rel="noopener">苹果官方文档：NSOperation</a></li>
<li><a href="https://objccn.io/issue-2-1/" target="_blank" rel="noopener">Objc 中国：并发编程：API 及挑战</a></li>
</ul>
<hr>
<p>iOS多线程详尽总结系列文章：</p>
<ul>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-pthread-and-NSThread.html" target="_blank" rel="noopener">iOS多线程：『pthread、NSThread』详尽总结</a></li>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-GCD.html" target="_blank" rel="noopener">iOS多线程：『GCD』详解总结</a></li>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-NSOperation.html" target="_blank" rel="noopener">iOS多线程：『NSOperation』详解总结</a></li>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-RunLoop.html" target="_blank" rel="noopener">iOS多线程：『RunLoop』详解总结</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/线程安全/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/线程安全/" itemprop="url">
                  线程安全
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 12:01:40 / 修改时间：12:07:13" itemprop="dateCreated datePublished" datetime="2018-09-17T12:01:40+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/多线程/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>前段时间看了几个开源项目，发现他们保持线程同步的方式各不相同，有@synchronized、NSLock、dispatch_semaphore、NSCondition、pthread_mutex、OSSpinLock。后来网上查了一下，发现他们的实现机制各不相同，性能也各不一样。不好意思，我们平常使用最多的@synchronized是性能最差的。下面我们先分别介绍每个加锁方式的使用，在使用一个案例来对他们进行性能对比。</p>
<h2 id="二、介绍与使用"><a href="#二、介绍与使用" class="headerlink" title="二、介绍与使用"></a>二、介绍与使用</h2><h3 id="2-1、-synchronized"><a href="#2-1、-synchronized" class="headerlink" title="2.1、@synchronized"></a>2.1、@synchronized</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">NSObject *obj = [[NSObject alloc] init];</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    @synchronized(obj) &#123;</span><br><span class="line">        NSLog(@&quot;需要线程同步的操作1 开始&quot;);</span><br><span class="line">        sleep(3);</span><br><span class="line">        NSLog(@&quot;需要线程同步的操作1 结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    sleep(1);</span><br><span class="line">    @synchronized(obj) &#123;</span><br><span class="line">        NSLog(@&quot;需要线程同步的操作2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>@synchronized(obj)指令使用的obj为该锁的唯一标识，只有当标识相同时，才为满足互斥，如果线程2中的@synchronized(obj)改为@synchronized(self),刚线程2就不会被阻塞，@synchronized指令实现锁的优点就是我们不需要在代码中显式的创建锁对象，便可以实现锁的机制，但作为一种预防措施，@synchronized块会隐式的添加一个异常处理例程来保护代码，该处理例程会在异常抛出的时候自动的释放互斥锁。所以如果不想让隐式的异常处理例程带来额外的开销，你可以考虑使用锁对象。</p>
<p>上面结果的执行结果为：</p>
<p>2016-06-29 20:48:35.747 SafeMultiThread[35945:580107] 需要线程同步的操作1 开始<br>2016-06-29 20:48:38.748 SafeMultiThread[35945:580107] 需要线程同步的操作1 结束<br>2016-06-29 20:48:38.749 SafeMultiThread[35945:580118] 需要线程同步的操作2</p>
<h3 id="2-2、dispatch-semaphore"><a href="#2-2、dispatch-semaphore" class="headerlink" title="2.2、dispatch_semaphore"></a>2.2、dispatch_semaphore</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t signal = dispatch_semaphore_create(1);</span><br><span class="line">dispatch_time_t overTime = dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    dispatch_semaphore_wait(signal, overTime);</span><br><span class="line">        NSLog(@&quot;需要线程同步的操作1 开始&quot;);</span><br><span class="line">        sleep(2);</span><br><span class="line">        NSLog(@&quot;需要线程同步的操作1 结束&quot;);</span><br><span class="line">    dispatch_semaphore_signal(signal);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    sleep(1);</span><br><span class="line">    dispatch_semaphore_wait(signal, overTime);</span><br><span class="line">        NSLog(@&quot;需要线程同步的操作2&quot;);</span><br><span class="line">    dispatch_semaphore_signal(signal);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是dispatch_semaphore_create，dispatch_semaphore_signal，dispatch_semaphore_wait。</p>
<p>（1）dispatch_semaphore_create的声明为：</p>
<p>dispatch_semaphore_t dispatch_semaphore_create(long value);</p>
<p>传入的参数为long，输出一个dispatch_semaphore_t类型且值为value的信号量。</p>
<p>值得注意的是，这里的传入的参数value必须大于或等于0，否则dispatch_semaphore_create会返回NULL。</p>
<p>（2）dispatch_semaphore_signal的声明为：</p>
<p>long dispatch_semaphore_signal(dispatch_semaphore_t dsema)</p>
<p>这个函数会使传入的信号量dsema的值加1；</p>
<p>(3) dispatch_semaphore_wait的声明为：</p>
<p>long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)；</p>
<p>这个函数会使传入的信号量dsema的值减1；这个函数的作用是这样的，如果dsema信号量的值大于0，该函数所处线程就继续执行下面的语句，并且将信号量的值减1；如果desema的值为0，那么这个函数就阻塞当前线程等待timeout（注意timeout的类型为dispatch_time_t，不能直接传入整形或float型数），如果等待的期间desema的值被dispatch_semaphore_signal函数加1了，且该函数（即dispatch_semaphore_wait）所处线程获得了信号量，那么就继续向下执行并将信号量减1。如果等待期间没有获取到信号量或者信号量的值一直为0，那么等到timeout时，其所处线程自动执行其后语句。</p>
<p>dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。</p>
<p>如上的代码，如果超时时间overTime设置成&gt;2，可完成同步操作。如果overTime&lt;2的话，在线程1还没有执行完成的情况下，此时超时了，将自动执行下面的代码。</p>
<p>上面代码的执行结果为：</p>
<p>2016-06-29 20:47:52.324 SafeMultiThread[35945:579032] 需要线程同步的操作1 开始<br>2016-06-29 20:47:55.325 SafeMultiThread[35945:579032] 需要线程同步的操作1 结束<br>2016-06-29 20:47:55.326 SafeMultiThread[35945:579033] 需要线程同步的操作2</p>
<p>如果把超时时间设置为&lt;2s的时候，执行的结果就是：</p>
<p>2016-06-30 18:53:24.049 SafeMultiThread[30834:434334] 需要线程同步的操作1 开始<br>2016-06-30 18:53:25.554 SafeMultiThread[30834:434332] 需要线程同步的操作2<br>2016-06-30 18:53:26.054 SafeMultiThread[30834:434334] 需要线程同步的操作1 结束</p>
<h3 id="2-3、NSLock"><a href="#2-3、NSLock" class="headerlink" title="2.3、NSLock"></a>2.3、NSLock</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">NSLock *lock = [[NSLock alloc] init];</span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    //[lock lock];</span><br><span class="line">    [lock lockBeforeDate:[NSDate date]];</span><br><span class="line">        NSLog(@&quot;需要线程同步的操作1 开始&quot;);</span><br><span class="line">        sleep(2);</span><br><span class="line">        NSLog(@&quot;需要线程同步的操作1 结束&quot;);</span><br><span class="line">    [lock unlock];</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    sleep(1);</span><br><span class="line">    if ([lock tryLock]) &#123;//尝试获取锁，如果获取不到返回NO，不会阻塞该线程</span><br><span class="line">        NSLog(@&quot;锁可用的操作&quot;);</span><br><span class="line">        [lock unlock];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;锁不可用的操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSDate *date = [[NSDate alloc] initWithTimeIntervalSinceNow:3];</span><br><span class="line">    if ([lock lockBeforeDate:date]) &#123;//尝试在未来的3s内获取锁，并阻塞该线程，如果3s内获取不到恢复线程, 返回NO,不会阻塞该线程</span><br><span class="line">        NSLog(@&quot;没有超时，获得锁&quot;);</span><br><span class="line">        [lock unlock];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;超时，没有获得锁&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>NSLock是Cocoa提供给我们最基本的锁对象，这也是我们经常所使用的，除lock和unlock方法外，NSLock还提供了tryLock和lockBeforeDate:两个方法，前一个方法会尝试加锁，如果锁不可用(已经被锁住)，刚并不会阻塞线程，并返回NO。lockBeforeDate:方法会在所指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。</p>
<p>上面代码的执行结果为：</p>
<p>2016-06-29 20:45:08.864 SafeMultiThread[35911:575795] 需要线程同步的操作1 开始<br>2016-06-29 20:45:09.869 SafeMultiThread[35911:575781] 锁不可用的操作<br>2016-06-29 20:45:10.869 SafeMultiThread[35911:575795] 需要线程同步的操作1 结束<br>2016-06-29 20:45:10.870 SafeMultiThread[35911:575781] 没有超时，获得锁</p>
<p>源码定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@protocol NSLocking</span><br><span class="line"></span><br><span class="line">- (void)lock;</span><br><span class="line">- (void)unlock;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface NSLock : NSObject &lt;NSLocking&gt; &#123;</span><br><span class="line">@private</span><br><span class="line">    void *_priv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)tryLock;</span><br><span class="line">- (BOOL)lockBeforeDate:(NSDate *)limit;</span><br><span class="line"></span><br><span class="line">@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="2-4、NSRecursiveLock递归锁"><a href="#2-4、NSRecursiveLock递归锁" class="headerlink" title="2.4、NSRecursiveLock递归锁"></a>2.4、NSRecursiveLock递归锁</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//NSLock *lock = [[NSLock alloc] init];</span><br><span class="line">NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    </span><br><span class="line">    static void (^RecursiveMethod)(int);</span><br><span class="line">    </span><br><span class="line">    RecursiveMethod = ^(int value) &#123;</span><br><span class="line">        </span><br><span class="line">        [lock lock];</span><br><span class="line">        if (value &gt; 0) &#123;</span><br><span class="line">            </span><br><span class="line">            NSLog(@&quot;value = %d&quot;, value);</span><br><span class="line">            sleep(1);</span><br><span class="line">            RecursiveMethod(value - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        [lock unlock];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    RecursiveMethod(5);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>NSRecursiveLock实际上定义的是一个递归锁，这个锁可以被同一线程多次请求，而不会引起死锁。这主要是用在循环或递归操作中。</p>
<p>这段代码是一个典型的死锁情况。在我们的线程中，RecursiveMethod是递归调用的。所以每次进入这个block时，都会去加一次锁，而从第二次开始，由于锁已经被使用了且没有解锁，所以它需要等待锁被解除，这样就导致了死锁，线程被阻塞住了。调试器中会输出如下信息：</p>
<p>2016-06-30 19:08:06.393 SafeMultiThread[30928:449008] value = 5<br>2016-06-30 19:08:07.399 SafeMultiThread[30928:449008] <strong><em> -[NSLock lock]: deadlock (<nslock: 0x7fd811d28810=""> ‘(null)’)<br>2016-06-30 19:08:07.399 SafeMultiThread[30928:449008] </nslock:></em></strong> Break on _NSLockError() to debug.</p>
<p>在这种情况下，我们就可以使用NSRecursiveLock。它可以允许同一线程多次加锁，而不会造成死锁。递归锁会跟踪它被lock的次数。每次成功的lock都必须平衡调用unlock操作。只有所有达到这种平衡，锁最后才能被释放，以供其它线程使用。</p>
<p>如果我们将NSLock代替为NSRecursiveLock，上面代码则会正确执行。</p>
<p>2016-06-30 19:09:41.414 SafeMultiThread[30949:450684] value = 5<br>2016-06-30 19:09:42.418 SafeMultiThread[30949:450684] value = 4<br>2016-06-30 19:09:43.419 SafeMultiThread[30949:450684] value = 3<br>2016-06-30 19:09:44.424 SafeMultiThread[30949:450684] value = 2<br>2016-06-30 19:09:45.426 SafeMultiThread[30949:450684] value = 1</p>
<p>如果需要其他功能，源码定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@interface NSRecursiveLock : NSObject &lt;NSLocking&gt; &#123;</span><br><span class="line">@private</span><br><span class="line">    void *_priv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)tryLock;</span><br><span class="line">- (BOOL)lockBeforeDate:(NSDate *)limit;</span><br><span class="line"></span><br><span class="line">@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="2-5、NSConditionLock条件锁"><a href="#2-5、NSConditionLock条件锁" class="headerlink" title="2.5、NSConditionLock条件锁"></a>2.5、NSConditionLock条件锁</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *products = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">NSInteger HAS_DATA = 1;</span><br><span class="line">NSInteger NO_DATA = 0;</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        [lock lockWhenCondition:NO_DATA];</span><br><span class="line">        [products addObject:[[NSObject alloc] init]];</span><br><span class="line">        NSLog(@&quot;produce a product,总量:%zi&quot;,products.count);</span><br><span class="line">        [lock unlockWithCondition:HAS_DATA];</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        NSLog(@&quot;wait for product&quot;);</span><br><span class="line">        [lock lockWhenCondition:HAS_DATA];</span><br><span class="line">        [products removeObjectAtIndex:0];</span><br><span class="line">        NSLog(@&quot;custome a product&quot;);</span><br><span class="line">        [lock unlockWithCondition:NO_DATA];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当我们在使用多线程的时候，有时一把只会lock和unlock的锁未必就能完全满足我们的使用。因为普通的锁只能关心锁与不锁，而不在乎用什么钥匙才能开锁，而我们在处理资源共享的时候，多数情况是只有满足一定条件的情况下才能打开这把锁：</p>
<p>在线程1中的加锁使用了lock，所以是不需要条件的，所以顺利的就锁住了，但在unlock的使用了一个整型的条件，它可以开启其它线程中正在等待这把钥匙的临界地，而线程2则需要一把被标识为2的钥匙，所以当线程1循环到最后一次的时候，才最终打开了线程2中的阻塞。但即便如此，NSConditionLock也跟其它的锁一样，是需要lock与unlock对应的，只是lock,lockWhenCondition:与unlock，unlockWithCondition:是可以随意组合的，当然这是与你的需求相关的。</p>
<p>上面代码执行结果如下：</p>
<p>2016-06-30 20:31:58.699 SafeMultiThread[31282:521698] wait for product<br>2016-06-30 20:31:58.699 SafeMultiThread[31282:521708] produce a product,总量:1<br>2016-06-30 20:31:58.700 SafeMultiThread[31282:521698] custome a product<br>2016-06-30 20:31:58.700 SafeMultiThread[31282:521698] wait for product<br>2016-06-30 20:31:59.705 SafeMultiThread[31282:521708] produce a product,总量:1<br>2016-06-30 20:31:59.706 SafeMultiThread[31282:521698] custome a product<br>2016-06-30 20:31:59.706 SafeMultiThread[31282:521698] wait for product<br>2016-06-30 20:32:00.707 SafeMultiThread[31282:521708] produce a product,总量:1<br>2016-06-30 20:32:00.708 SafeMultiThread[31282:521698] custome a product</p>
<p>如果你需要其他功能，源码定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@interface NSConditionLock : NSObject &lt;NSLocking&gt; &#123;</span><br><span class="line">@private</span><br><span class="line">    void *_priv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER;</span><br><span class="line"></span><br><span class="line">@property (readonly) NSInteger condition;</span><br><span class="line">- (void)lockWhenCondition:(NSInteger)condition;</span><br><span class="line">- (BOOL)tryLock;</span><br><span class="line">- (BOOL)tryLockWhenCondition:(NSInteger)condition;</span><br><span class="line">- (void)unlockWithCondition:(NSInteger)condition;</span><br><span class="line">- (BOOL)lockBeforeDate:(NSDate *)limit;</span><br><span class="line">- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;</span><br><span class="line"></span><br><span class="line">@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="2-6、NSCondition"><a href="#2-6、NSCondition" class="headerlink" title="2.6、NSCondition"></a>2.6、NSCondition</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">NSCondition *condition = [[NSCondition alloc] init];</span><br><span class="line"></span><br><span class="line">NSMutableArray *products = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        [condition lock];</span><br><span class="line">        if ([products count] == 0) &#123;</span><br><span class="line">            NSLog(@&quot;wait for product&quot;);</span><br><span class="line">            [condition wait];</span><br><span class="line">        &#125;</span><br><span class="line">        [products removeObjectAtIndex:0];</span><br><span class="line">        NSLog(@&quot;custome a product&quot;);</span><br><span class="line">        [condition unlock];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        [condition lock];</span><br><span class="line">        [products addObject:[[NSObject alloc] init]];</span><br><span class="line">        NSLog(@&quot;produce a product,总量:%zi&quot;,products.count);</span><br><span class="line">        [condition signal];</span><br><span class="line">        [condition unlock];</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>一种最基本的条件锁。手动控制线程wait和signal。</p>
<p>[condition lock];一般用于多线程同时访问、修改同一个数据源，保证在同一时间内数据源只被访问、修改一次，其他线程的命令需要在lock 外等待，只到unlock ，才可访问</p>
<p>[condition unlock];与lock 同时使用</p>
<p>[condition wait];让当前线程处于等待状态</p>
<p>[condition signal];CPU发信号告诉线程不用在等待，可以继续执行</p>
<p>上面代码执行结果如下：</p>
<p>2016-06-30 20:21:25.295 SafeMultiThread[31256:513991] wait for product<br>2016-06-30 20:21:25.296 SafeMultiThread[31256:513994] produce a product,总量:1<br>2016-06-30 20:21:25.296 SafeMultiThread[31256:513991] custome a product<br>2016-06-30 20:21:25.297 SafeMultiThread[31256:513991] wait for product<br>2016-06-30 20:21:26.302 SafeMultiThread[31256:513994] produce a product,总量:1<br>2016-06-30 20:21:26.302 SafeMultiThread[31256:513991] custome a product<br>2016-06-30 20:21:26.302 SafeMultiThread[31256:513991] wait for product<br>2016-06-30 20:21:27.307 SafeMultiThread[31256:513994] produce a product,总量:1<br>2016-06-30 20:21:27.308 SafeMultiThread[31256:513991] custome a product</p>
<h3 id="2-7、pthread-mutex"><a href="#2-7、pthread-mutex" class="headerlink" title="2.7、pthread_mutex"></a>2.7、pthread_mutex</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__block pthread_mutex_t theLock;</span><br><span class="line">pthread_mutex_init(&amp;theLock, NULL);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;theLock);</span><br><span class="line">        NSLog(@&quot;需要线程同步的操作1 开始&quot;);</span><br><span class="line">        sleep(3);</span><br><span class="line">        NSLog(@&quot;需要线程同步的操作1 结束&quot;);</span><br><span class="line">        pthread_mutex_unlock(&amp;theLock);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        pthread_mutex_lock(&amp;theLock);</span><br><span class="line">        NSLog(@&quot;需要线程同步的操作2&quot;);</span><br><span class="line">        pthread_mutex_unlock(&amp;theLock);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>c语言定义下多线程加锁方式。</p>
<p>1：pthread_mutex_init(<strong>pthread_mutex_t*</strong> mutex,const pthread_mutexattr_t <em>attr);初始化锁变量mutex。attr为锁属性，NULL值为默认属性。2：pthread_mutex_lock(<strong>pthread_mutex_t</strong> </em>mutex);加锁3：pthread_mutex_tylock(<strong>pthread_mutex_t</strong> <em>mutex);加锁，但是与2不一样的是当锁已经在使用的时候，返回为EBUSY，而不是挂起等待。4：pthread_mutex_unlock(<strong>pthread_mutex_t</strong> </em>mutex);释放锁5：pthread_mutex_destroy(<strong>pthread_mutex_t</strong> *mutex);使用完后释放</p>
<p>代码执行操作结果如下：</p>
<p>2016-06-30 21:13:32.440 SafeMultiThread[31429:548869] 需要线程同步的操作1 开始<br>2016-06-30 21:13:35.445 SafeMultiThread[31429:548869] 需要线程同步的操作1 结束<br>2016-06-30 21:13:35.446 SafeMultiThread[31429:548866] 需要线程同步的操作2</p>
<h3 id="2-8、pthread-mutex-recursive"><a href="#2-8、pthread-mutex-recursive" class="headerlink" title="2.8、pthread_mutex(recursive)"></a>2.8、pthread_mutex(recursive)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">__block pthread_mutex_t theLock;</span><br><span class="line">//pthread_mutex_init(&amp;theLock, NULL);</span><br><span class="line"></span><br><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init(&amp;attr);</span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">pthread_mutex_init(&amp;lock, &amp;attr);</span><br><span class="line">pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    </span><br><span class="line">    static void (^RecursiveMethod)(int);</span><br><span class="line">    </span><br><span class="line">    RecursiveMethod = ^(int value) &#123;</span><br><span class="line">        </span><br><span class="line">        pthread_mutex_lock(&amp;theLock);</span><br><span class="line">        if (value &gt; 0) &#123;</span><br><span class="line">            </span><br><span class="line">            NSLog(@&quot;value = %d&quot;, value);</span><br><span class="line">            sleep(1);</span><br><span class="line">            RecursiveMethod(value - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;theLock);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    RecursiveMethod(5);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这是pthread_mutex为了防止在递归的情况下出现死锁而出现的递归锁。作用和NSRecursiveLock递归锁类似。</p>
<p>如果使用pthread_mutex_init(&amp;theLock, NULL);初始化锁的话，上面的代码会出现死锁现象。如果使用递归锁的形式，则没有问题。</p>
<h3 id="2-9、OSSpinLock"><a href="#2-9、OSSpinLock" class="headerlink" title="2.9、OSSpinLock"></a>2.9、OSSpinLock</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">__block OSSpinLock theLock = OS_SPINLOCK_INIT;</span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    OSSpinLockLock(&amp;theLock);</span><br><span class="line">    NSLog(@&quot;需要线程同步的操作1 开始&quot;);</span><br><span class="line">    sleep(3);</span><br><span class="line">    NSLog(@&quot;需要线程同步的操作1 结束&quot;);</span><br><span class="line">    OSSpinLockUnlock(&amp;theLock);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    OSSpinLockLock(&amp;theLock);</span><br><span class="line">    sleep(1);</span><br><span class="line">    NSLog(@&quot;需要线程同步的操作2&quot;);</span><br><span class="line">    OSSpinLockUnlock(&amp;theLock);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>OSSpinLock 自旋锁，性能最高的锁。原理很简单，就是一直 do while 忙等。它的缺点是当等待时会消耗大量 CPU 资源，所以它不适用于较长时间的任务。 不过最近YY大神在自己的博客<a href="https://link.jianshu.com/?t=http://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的 OSSpinLock</a>中说明了OSSpinLock已经不再安全，请大家谨慎使用。</p>
<h2 id="三、性能对比"><a href="#三、性能对比" class="headerlink" title="三、性能对比"></a>三、性能对比</h2><p>对以上各个锁进行1000000此的加锁解锁的空操作时间如下：</p>
<p>OSSpinLock: 46.15 ms<br>dispatch_semaphore: 56.50 ms<br>pthread_mutex: 178.28 ms<br>NSCondition: 193.38 ms<br>NSLock: 175.02 ms<br>pthread_mutex(recursive): 172.56 ms<br>NSRecursiveLock: 157.44 ms<br>NSConditionLock: 490.04 ms<br>@synchronized: 371.17 ms</p>
<p>总的来说：</p>
<p>OSSpinLock和dispatch_semaphore的效率远远高于其他。</p>
<p>@synchronized和NSConditionLock效率较差。</p>
<p>鉴于OSSpinLock的不安全，所以我们在开发中如果考虑性能的话，建议使用dispatch_semaphore。</p>
<p>如果不考虑性能，只是图个方便的话，那就使用@synchronized。</p>
<h2 id="四、联系方式"><a href="#四、联系方式" class="headerlink" title="四、联系方式"></a>四、联系方式</h2><p><a href="https://link.jianshu.com/?t=http://weibo.com/5612984599/info" target="_blank" rel="noopener">新浪微博</a><br><a href="https://link.jianshu.com/?t=https://github.com/yixiangboy" target="_blank" rel="noopener">github</a><br><a href="https://www.jianshu.com/users/c3c893a27097/timeline" target="_blank" rel="noopener">简书首页</a><br>欢迎加好友、一起交流。</p>
<p><a href="https://www.jianshu.com/p/938d68ed832c" target="_blank" rel="noopener">转自 <a href="https://www.jianshu.com/u/c3c893a27097" target="_blank" rel="noopener">景铭巴巴</a></a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/GCD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/GCD/" itemprop="url">
                  GCD
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 12:01:23 / 修改时间：14:28:49" itemprop="dateCreated datePublished" datetime="2018-09-17T12:01:23+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/多线程/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://juejin.im/post/5a90de68f265da4e9b592b40" target="_blank" rel="noopener">转自 <a href="https://juejin.im/user/5a43aed3f265da4318770885" target="_blank" rel="noopener">行走的少年郎</a></a></p>
<p><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-background.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-background.png" alt="img"></a></p>
<blockquote>
<p>本文用来介绍 iOS 多线程中 GCD 的相关知识以及使用方法。这大概是史上最详细、清晰的关于 GCD 的详细讲解+总结的文章了。通过本文，您将了解到：<br><strong>1. GCD 简介</strong><br><strong>2. GCD 任务和队列</strong><br><strong>3. GCD 的使用步骤</strong><br><strong>4. GCD 的基本使用</strong>（6种不同组合区别）<br><strong>5. GCD 线程间的通信</strong><br><strong>6. GCD 的其他方法</strong>（栅栏方法：dispatch_barrier_async、延时执行方法：dispatch_after、一次性代码（只执行一次）：dispatch_once、快速迭代方法：dispatch_apply、队列组：dispatch_group、信号量：dispatch_semaphore）</p>
<p>文中 Demo 我已放在了 Github 上，Demo 链接：<a href="https://github.com/bujige/YSC-GCD-demo" target="_blank" rel="noopener">传送门</a></p>
</blockquote>
<h1 id="1-GCD-简介"><a href="#1-GCD-简介" class="headerlink" title="1. GCD 简介"></a>1. GCD 简介</h1><p>什么是 GCD 呢？我们先来看看百度百科的解释简单了解下概念</p>
<blockquote>
<p>引自<a href="https://baike.baidu.com/item/GCD" target="_blank" rel="noopener">百度百科</a><br><strong>Grand Central Dispatch(GCD)</strong> 是 Apple 开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并发任务。在 Mac OS X 10.6 雪豹中首次推出，也可在 iOS 4 及以上版本使用。</p>
</blockquote>
<p><strong>为什么要用 GCD 呢？</strong></p>
<p>因为 GCD 有很多好处啊，具体如下：</p>
<ul>
<li>GCD 可用于多核的并行运算</li>
<li>GCD 会自动利用更多的 CPU 内核（比如双核、四核）</li>
<li>GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li>
<li>程序员只需要告诉 GCD 想要执行什么任务，不需要编写任何线程管理代码</li>
</ul>
<p>既然 GCD 有这么多的好处，那么下面我们就来系统的学习一下 GCD 的使用方法。</p>
<h1 id="2-GCD-任务和队列"><a href="#2-GCD-任务和队列" class="headerlink" title="2. GCD 任务和队列"></a>2. GCD 任务和队列</h1><p>学习 GCD 之前，先来了解 GCD 中两个核心概念：<strong>任务</strong>和<strong>队列</strong>。</p>
<p><strong>任务</strong>：就是执行操作的意思，换句话说就是你在线程中执行的那段代码。在 GCD 中是放在 block 中的。执行任务有两种方式：<strong>同步执行（sync）</strong>和<strong>异步执行（async）</strong>。两者的主要区别是：<strong>是否等待队列的任务执行结束，以及是否具备开启新线程的能力。</strong></p>
<ul>
<li><p>同步执行（sync）</p>
<p>：</p>
<ul>
<li>同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。</li>
<li>只能在当前线程中执行任务，不具备开启新线程的能力。</li>
</ul>
</li>
<li><p>异步执行（async）</p>
<p>：</p>
<ul>
<li>异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。</li>
<li>可以在新的线程中执行任务，具备开启新线程的能力。</li>
</ul>
</li>
</ul>
<p>举个简单例子：你要打电话给小明和小白。<br>同步执行就是，你打电话给小明的时候，不能同时打给小白，等到给小明打完了，才能打给小白（等待任务执行结束）。而且只能用当前的电话（不具备开启新线程的能力）。<br>而异步执行就是，你打电话给小明的时候，不等和小明通话结束，还能直接给小白打电话，不用等着和小明通话结束再打（不用等待任务执行结束）。除了当前电话，你还可以使用其他所能使用的电话（具备开启新线程的能力）。</p>
<blockquote>
<p>注意：<strong>异步执行（async）</strong>虽然具有开启新线程的能力，但是并不一定开启新线程。这跟任务所指定的队列类型有关（下面会讲）。</p>
</blockquote>
<p><strong>队列（Dispatch Queue）</strong>：这里的队列指执行任务的等待队列，即用来存放任务的队列。队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。队列的结构可参考下图：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-DispatchQueue.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-DispatchQueue.png" alt="DispatchQueue.png"></a></p>
<p>在 GCD 中有两种队列：<strong>串行队列</strong>和<strong>并发队列</strong>。两者都符合 FIFO（先进先出）的原则。两者的主要区别是：<strong>执行顺序不同，以及开启线程数不同。</strong></p>
<ul>
<li><p>串行队列（Serial Dispatch Queue）</p>
<p>：</p>
<ul>
<li>每次只有一个任务被执行。让任务一个接着一个地执行。一个任务执行完毕后，再执行下一个任务。</li>
<li>只开启一个新线程（或者不开启新线程，在当前线程执行任务）。</li>
</ul>
</li>
<li><p>并发队列（Concurrent Dispatch Queue）</p>
<p>：</p>
<ul>
<li>可以让多个任务并发（同时）执行。</li>
<li>可以开启多个线程，并且同时执行任务。</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：<strong>并发队列</strong>的并发功能只有在异步（dispatch_async）函数下才有效。</p>
</blockquote>
<p>两者具体区别如下两图所示。</p>
<p><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-SerialDispatchQueue.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-SerialDispatchQueue.png" alt="SerialDispatchQueue.png"></a></p>
<p><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-ConcurrentDispatchQueue.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-ConcurrentDispatchQueue.png" alt="ConcurrentDispatchQueue.png"></a></p>
<h1 id="3-GCD-的使用步骤"><a href="#3-GCD-的使用步骤" class="headerlink" title="3. GCD 的使用步骤"></a>3. GCD 的使用步骤</h1><p>GCD 的使用步骤其实很简单，只有两步。</p>
<ol>
<li>创建一个队列（串行队列或并发队列）</li>
<li>将任务追加到任务的等待队列中，然后系统就会根据任务类型执行任务（同步执行或异步执行）</li>
</ol>
<p>下边来看看队列的创建方法/获取方法，以及任务的创建方法。</p>
<h2 id="3-1-队列的创建方法-获取方法"><a href="#3-1-队列的创建方法-获取方法" class="headerlink" title="3.1 队列的创建方法/获取方法"></a>3.1 队列的创建方法/获取方法</h2><ul>
<li>可以使用<code>dispatch_queue_create</code>来创建队列，需要传入两个参数，第一个参数表示队列的唯一标识符，用于 DEBUG，可为空，Dispatch Queue 的名称推荐使用应用程序 ID 这种逆序全程域名；第二个参数用来识别是串行队列还是并发队列。<code>DISPATCH_QUEUE_SERIAL</code> 表示串行队列，<code>DISPATCH_QUEUE_CONCURRENT</code> 表示并发队列。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 串行队列的创建方法</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">// 并发队列的创建方法</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>对于串行队列，GCD 提供了的一种特殊的串行队列：</p>
<p>主队列（Main Dispatch Queue）</p>
<p>。</p>
<ul>
<li>所有放在主队列中的任务，都会放到主线程中执行。</li>
<li>可使用<code>dispatch_get_main_queue()</code>获得主队列。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 主队列的获取方法</span><br><span class="line">dispatch_queue_t queue = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure>
<ul>
<li><p>对于并发队列，GCD 默认提供了</p>
<p>全局并发队列（Global Dispatch Queue）</p>
<p>。</p>
<ul>
<li>可以使用<code>dispatch_get_global_queue</code>来获取。需要传入两个参数。第一个参数表示队列优先级，一般用<code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code>。第二个参数暂时没用，用<code>0</code>即可。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 全局并发队列的获取方法</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br></pre></td></tr></table></figure>
<h2 id="3-2-任务的创建方法"><a href="#3-2-任务的创建方法" class="headerlink" title="3.2 任务的创建方法"></a>3.2 任务的创建方法</h2><p>GCD 提供了同步执行任务的创建方法<code>dispatch_sync</code>和异步执行任务创建方法<code>dispatch_async</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 同步执行任务创建方法</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">    // 这里放同步执行任务代码</span><br><span class="line">&#125;);</span><br><span class="line">// 异步执行任务创建方法</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    // 这里放异步执行任务代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>虽然使用 GCD 只需两步，但是既然我们有两种队列（串行队列/并发队列），两种任务执行方式（同步执行/异步执行），那么我们就有了四种不同的组合方式。这四种不同的组合方式是：</p>
<blockquote>
<ol>
<li>同步执行 + 并发队列</li>
<li>异步执行 + 并发队列</li>
<li>同步执行 + 串行队列</li>
<li>异步执行 + 串行队列</li>
</ol>
</blockquote>
<p>实际上，刚才还说了两种特殊队列：全局并发队列、主队列。全局并发队列可以作为普通并发队列来使用。但是主队列因为有点特殊，所以我们就又多了两种组合方式。这样就有六种不同的组合方式了。</p>
<blockquote>
<ol>
<li>同步执行 + 主队列</li>
<li>异步执行 + 主队列</li>
</ol>
</blockquote>
<p>那么这几种不同组合方式各有什么区别呢，这里为了方便，先上结果，再来讲解。你可以直接查看表格结果，然后跳过 <strong>4. GCD的基本使用</strong> 。</p>
<table>
<thead>
<tr>
<th>区别</th>
<th>并发队列</th>
<th>串行队列</th>
<th>主队列</th>
</tr>
</thead>
<tbody>
<tr>
<td>同步(sync)</td>
<td>没有开启新线程，串行执行任务</td>
<td>没有开启新线程，串行执行任务</td>
<td>主线程调用：死锁卡住不执行其他线程调用：没有开启新线程，串行执行任务</td>
</tr>
<tr>
<td>异步(async)</td>
<td>有开启新线程，并发执行任务</td>
<td>有开启新线程(1条)，串行执行任务</td>
<td>没有开启新线程，串行执行任务</td>
</tr>
</tbody>
</table>
<p>下边我们来分别讲讲这几种不同的组合方式的使用方法。</p>
<h1 id="4-GCD-的基本使用"><a href="#4-GCD-的基本使用" class="headerlink" title="4. GCD 的基本使用"></a>4. GCD 的基本使用</h1><p><strong>先来讲讲并发队列的两种执行方式。</strong></p>
<h2 id="4-1-同步执行-并发队列"><a href="#4-1-同步执行-并发队列" class="headerlink" title="4.1 同步执行 + 并发队列"></a>4.1 同步执行 + 并发队列</h2><ul>
<li>在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 同步执行 + 并发队列</span><br><span class="line"> * 特点：在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。</span><br><span class="line"> */</span><br><span class="line">- (void)syncConcurrent &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    NSLog(@&quot;syncConcurrent---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;syncConcurrent---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2018-02-23 20:34:55.095932+0800 YSC-GCD-demo[19892:4996930] currentThread—{number = 1, name = main}<br>2018-02-23 20:34:55.096086+0800 YSC-GCD-demo[19892:4996930] syncConcurrent—begin<br>2018-02-23 20:34:57.097589+0800 YSC-GCD-demo[19892:4996930] 1—{number = 1, name = main}<br>2018-02-23 20:34:59.099100+0800 YSC-GCD-demo[19892:4996930] 1—{number = 1, name = main}<br>2018-02-23 20:35:01.099843+0800 YSC-GCD-demo[19892:4996930] 2—{number = 1, name = main}<br>2018-02-23 20:35:03.101171+0800 YSC-GCD-demo[19892:4996930] 2—{number = 1, name = main}<br>2018-02-23 20:35:05.101750+0800 YSC-GCD-demo[19892:4996930] 3—{number = 1, name = main}<br>2018-02-23 20:35:07.102414+0800 YSC-GCD-demo[19892:4996930] 3—{number = 1, name = main}<br>2018-02-23 20:35:07.102575+0800 YSC-GCD-demo[19892:4996930] syncConcurrent—end</p>
</blockquote>
<p>从<code>同步执行 + 并发队列</code>中可看到：</p>
<ul>
<li>所有任务都是在当前线程（主线程）中执行的，没有开启新的线程（<code>同步执行</code>不具备开启新线程的能力）。</li>
<li>所有任务都在打印的<code>syncConcurrent---begin</code>和<code>syncConcurrent---end</code>之间执行的（<code>同步任务</code>需要等待队列的任务执行结束）。</li>
<li>任务按顺序执行的。按顺序执行的原因：虽然<code>并发队列</code>可以开启多个线程，并且同时执行多个任务。但是因为本身不能创建新线程，只有当前线程这一个线程（<code>同步任务</code>不具备开启新线程的能力），所以也就不存在并发。而且当前线程只有等待当前队列中正在执行的任务执行完毕之后，才能继续接着执行下面的操作（<code>同步任务</code>需要等待队列的任务执行结束）。所以任务只能一个接一个按顺序执行，不能同时被执行。</li>
</ul>
<h2 id="4-2-异步执行-并发队列"><a href="#4-2-异步执行-并发队列" class="headerlink" title="4.2 异步执行 + 并发队列"></a>4.2 异步执行 + 并发队列</h2><ul>
<li>可以开启多个线程，任务交替（同时）执行。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 异步执行 + 并发队列</span><br><span class="line"> * 特点：可以开启多个线程，任务交替（同时）执行。</span><br><span class="line"> */</span><br><span class="line">- (void)asyncConcurrent &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    NSLog(@&quot;asyncConcurrent---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;asyncConcurrent---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2018-02-23 20:36:41.769269+0800 YSC-GCD-demo[19929:5005237] currentThread—{number = 1, name = main}<br>2018-02-23 20:36:41.769496+0800 YSC-GCD-demo[19929:5005237] asyncConcurrent—begin<br>2018-02-23 20:36:41.769725+0800 YSC-GCD-demo[19929:5005237] asyncConcurrent—end<br>2018-02-23 20:36:43.774442+0800 YSC-GCD-demo[19929:5005566] 2—{number = 5, name = (null)}<br>2018-02-23 20:36:43.774440+0800 YSC-GCD-demo[19929:5005567] 3—{number = 4, name = (null)}<br>2018-02-23 20:36:43.774440+0800 YSC-GCD-demo[19929:5005565] 1—{number = 3, name = (null)}<br>2018-02-23 20:36:45.779286+0800 YSC-GCD-demo[19929:5005567] 3—{number = 4, name = (null)}<br>2018-02-23 20:36:45.779302+0800 YSC-GCD-demo[19929:5005565] 1—{number = 3, name = (null)}<br>2018-02-23 20:36:45.779286+0800 YSC-GCD-demo[19929:5005566] 2—{number = 5, name = (null)}</p>
</blockquote>
<p>在<code>异步执行 + 并发队列</code>中可以看出：</p>
<ul>
<li>除了当前线程（主线程），系统又开启了3个线程，并且任务是交替/同时执行的。（<code>异步执行</code>具备开启新线程的能力。且<code>并发队列</code>可开启多个线程，同时执行多个任务）。</li>
<li>所有任务是在打印的<code>syncConcurrent---begin</code>和<code>syncConcurrent---end</code>之后才执行的。说明当前线程没有等待，而是直接开启了新线程，在新线程中执行任务（<code>异步执行</code>不做等待，可以继续执行任务）。</li>
</ul>
<p><strong>接下来再来讲讲串行队列的两种执行方式。</strong></p>
<h2 id="4-3-同步执行-串行队列"><a href="#4-3-同步执行-串行队列" class="headerlink" title="4.3 同步执行 + 串行队列"></a>4.3 同步执行 + 串行队列</h2><ul>
<li>不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 同步执行 + 串行队列</span><br><span class="line"> * 特点：不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。</span><br><span class="line"> */</span><br><span class="line">- (void)syncSerial &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    NSLog(@&quot;syncSerial---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;syncSerial---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果为：<br>2018-02-23 20:39:37.876811+0800 YSC-GCD-demo[19975:5017162] currentThread—{number = 1, name = main}<br>2018-02-23 20:39:37.876998+0800 YSC-GCD-demo[19975:5017162] syncSerial—begin<br>2018-02-23 20:39:39.878316+0800 YSC-GCD-demo[19975:5017162] 1—{number = 1, name = main}<br>2018-02-23 20:39:41.879829+0800 YSC-GCD-demo[19975:5017162] 1—{number = 1, name = main}<br>2018-02-23 20:39:43.880660+0800 YSC-GCD-demo[19975:5017162] 2—{number = 1, name = main}<br>2018-02-23 20:39:45.881265+0800 YSC-GCD-demo[19975:5017162] 2—{number = 1, name = main}<br>2018-02-23 20:39:47.882257+0800 YSC-GCD-demo[19975:5017162] 3—{number = 1, name = main}<br>2018-02-23 20:39:49.883008+0800 YSC-GCD-demo[19975:5017162] 3—{number = 1, name = main}<br>2018-02-23 20:39:49.883253+0800 YSC-GCD-demo[19975:5017162] syncSerial—end</p>
</blockquote>
<p>在<code>同步执行 + 串行队列</code>可以看到：</p>
<ul>
<li>所有任务都是在当前线程（主线程）中执行的，并没有开启新的线程（<code>同步执行</code>不具备开启新线程的能力）。</li>
<li>所有任务都在打印的<code>syncConcurrent---begin</code>和<code>syncConcurrent---end</code>之间执行（<code>同步任务</code>需要等待队列的任务执行结束）。</li>
<li>任务是按顺序执行的（<code>串行队列</code>每次只有一个任务被执行，任务一个接一个按顺序执行）。</li>
</ul>
<h2 id="4-4-异步执行-串行队列"><a href="#4-4-异步执行-串行队列" class="headerlink" title="4.4 异步执行 + 串行队列"></a>4.4 异步执行 + 串行队列</h2><ul>
<li>会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 异步执行 + 串行队列</span><br><span class="line"> * 特点：会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务。</span><br><span class="line"> */</span><br><span class="line">- (void)asyncSerial &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    NSLog(@&quot;asyncSerial---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;asyncSerial---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果为：<br>2018-02-23 20:41:17.029999+0800 YSC-GCD-demo[20008:5024757] currentThread—{number = 1, name = main}<br>2018-02-23 20:41:17.030212+0800 YSC-GCD-demo[20008:5024757] asyncSerial—begin<br>2018-02-23 20:41:17.030364+0800 YSC-GCD-demo[20008:5024757] asyncSerial—end<br>2018-02-23 20:41:19.035379+0800 YSC-GCD-demo[20008:5024950] 1—{number = 3, name = (null)}<br>2018-02-23 20:41:21.037140+0800 YSC-GCD-demo[20008:5024950] 1—{number = 3, name = (null)}<br>2018-02-23 20:41:23.042220+0800 YSC-GCD-demo[20008:5024950] 2—{number = 3, name = (null)}<br>2018-02-23 20:41:25.042971+0800 YSC-GCD-demo[20008:5024950] 2—{number = 3, name = (null)}<br>2018-02-23 20:41:27.047690+0800 YSC-GCD-demo[20008:5024950] 3—{number = 3, name = (null)}<br>2018-02-23 20:41:29.052327+0800 YSC-GCD-demo[20008:5024950] 3—{number = 3, name = (null)}</p>
</blockquote>
<p>在<code>异步执行 + 串行队列</code>可以看到：</p>
<ul>
<li>开启了一条新线程（<code>异步执行</code>具备开启新线程的能力，<code>串行队列</code>只开启一个线程）。</li>
<li>所有任务是在打印的<code>syncConcurrent---begin</code>和<code>syncConcurrent---end</code>之后才开始执行的（<code>异步执行</code>不会做任何等待，可以继续执行任务）。</li>
<li>任务是按顺序执行的（<code>串行队列</code>每次只有一个任务被执行，任务一个接一个按顺序执行）。</li>
</ul>
<p>下边讲讲刚才我们提到过的特殊队列：<strong>主队列</strong>。</p>
<ul>
<li><p>主队列：GCD自带的一种特殊的</p>
<p>串行队列</p>
<ul>
<li>所有放在主队列中的任务，都会放到主线程中执行</li>
<li>可使用<code>dispatch_get_main_queue()</code>获得主队列</li>
</ul>
</li>
</ul>
<p><strong>我们再来看看主队列的两种组合方式。</strong></p>
<h2 id="4-5-同步执行-主队列"><a href="#4-5-同步执行-主队列" class="headerlink" title="4.5 同步执行 + 主队列"></a>4.5 同步执行 + 主队列</h2><p><code>同步执行 + 主队列</code>在不同线程中调用结果也是不一样，在主线程中调用会出现死锁，而在其他线程中则不会。</p>
<h3 id="4-5-1-在主线程中调用同步执行-主队列"><a href="#4-5-1-在主线程中调用同步执行-主队列" class="headerlink" title="4.5.1 在主线程中调用同步执行 + 主队列"></a>4.5.1 在主线程中调用<code>同步执行 + 主队列</code></h3><ul>
<li>互相等待卡住不可行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 同步执行 + 主队列</span><br><span class="line"> * 特点(主线程调用)：互等卡主不执行。</span><br><span class="line"> * 特点(其他线程调用)：不会开启新线程，执行完一个任务，再执行下一个任务。</span><br><span class="line"> */</span><br><span class="line">- (void)syncMain &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    NSLog(@&quot;syncMain---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;syncMain---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果<br>2018-02-23 20:42:36.842892+0800 YSC-GCD-demo[20041:5030982] currentThread—{number = 1, name = main}<br>2018-02-23 20:42:36.843050+0800 YSC-GCD-demo[20041:5030982] syncMain—begin<br>(lldb)</p>
</blockquote>
<p>在<code>同步执行 + 主队列</code>可以惊奇的发现：</p>
<ul>
<li>在主线程中使用<code>同步执行 + 主队列</code>，追加到主线程的任务1、任务2、任务3都不再执行了，而且<code>syncMain---end</code>也没有打印，在XCode 9上还会报崩溃。这是为什么呢？</li>
</ul>
<p>这是因为我们在主线程中执行<code>syncMain</code>方法，相当于把<code>syncMain</code>任务放到了主线程的队列中。而<code>同步执行</code>会等待当前队列中的任务执行完毕，才会接着执行。那么当我们把<code>任务1</code>追加到主队列中，<code>任务1</code>就在等待主线程处理完<code>syncMain</code>任务。而<code>syncMain</code>任务需要等待<code>任务1</code>执行完毕，才能接着执行。</p>
<p>那么，现在的情况就是<code>syncMain</code>任务和<code>任务1</code>都在等对方执行完毕。这样大家互相等待，所以就卡住了，所以我们的任务执行不了，而且<code>syncMain---end</code>也没有打印。</p>
<p><strong>要是如果不在主线程中调用，而在其他线程中调用会如何呢？</strong></p>
<h3 id="4-5-2-在其他线程中调用同步执行-主队列"><a href="#4-5-2-在其他线程中调用同步执行-主队列" class="headerlink" title="4.5.2 在其他线程中调用同步执行 + 主队列"></a>4.5.2 在其他线程中调用<code>同步执行 + 主队列</code></h3><ul>
<li>不会开启新线程，执行完一个任务，再执行下一个任务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 使用 NSThread 的 detachNewThreadSelector 方法会创建线程，并自动启动线程执行</span><br><span class="line"> selector 任务</span><br><span class="line">[NSThread detachNewThreadSelector:@selector(syncMain) toTarget:self withObject:nil];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2018-02-23 20:44:19.377321+0800 YSC-GCD-demo[20083:5040347] currentThread—{number = 3, name = (null)}<br>2018-02-23 20:44:19.377494+0800 YSC-GCD-demo[20083:5040347] syncMain—begin<br>2018-02-23 20:44:21.384716+0800 YSC-GCD-demo[20083:5040132] 1—{number = 1, name = main}<br>2018-02-23 20:44:23.386091+0800 YSC-GCD-demo[20083:5040132] 1—{number = 1, name = main}<br>2018-02-23 20:44:25.387687+0800 YSC-GCD-demo[20083:5040132] 2—{number = 1, name = main}<br>2018-02-23 20:44:27.388648+0800 YSC-GCD-demo[20083:5040132] 2—{number = 1, name = main}<br>2018-02-23 20:44:29.390459+0800 YSC-GCD-demo[20083:5040132] 3—{number = 1, name = main}<br>2018-02-23 20:44:31.391965+0800 YSC-GCD-demo[20083:5040132] 3—{number = 1, name = main}<br>2018-02-23 20:44:31.392513+0800 YSC-GCD-demo[20083:5040347] syncMain—end</p>
</blockquote>
<p>在其他线程中使用<code>同步执行 + 主队列</code>可看到：</p>
<ul>
<li>所有任务都是在主线程（非当前线程）中执行的，没有开启新的线程（所有放在<code>主队列</code>中的任务，都会放到主线程中执行）。</li>
<li>所有任务都在打印的<code>syncConcurrent---begin</code>和<code>syncConcurrent---end</code>之间执行（<code>同步任务</code>需要等待队列的任务执行结束）。</li>
<li>任务是按顺序执行的（主队列是<code>串行队列</code>，每次只有一个任务被执行，任务一个接一个按顺序执行）。</li>
</ul>
<p>为什么现在就不会卡住了呢？<br>因为<code>syncMain 任务</code>放到了其他线程里，而<code>任务1</code>、<code>任务2</code>、<code>任务3</code>都在追加到主队列中，这三个任务都会在主线程中执行。<code>syncMain 任务</code>在其他线程中执行到追加<code>任务1</code>到主队列中，因为主队列现在没有正在执行的任务，所以，会直接执行主队列的<code>任务1</code>，等<code>任务1</code>执行完毕，再接着执行<code>任务2</code>、<code>任务3</code>。所以这里不会卡住线程。</p>
<h2 id="4-6-异步执行-主队列"><a href="#4-6-异步执行-主队列" class="headerlink" title="4.6 异步执行 + 主队列"></a>4.6 异步执行 + 主队列</h2><ul>
<li>只在主线程中执行任务，执行完一个任务，再执行下一个任务。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 异步执行 + 主队列</span><br><span class="line"> * 特点：只在主线程中执行任务，执行完一个任务，再执行下一个任务</span><br><span class="line"> */</span><br><span class="line">- (void)asyncMain &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    NSLog(@&quot;asyncMain---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;asyncMain---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2018-02-23 20:45:49.981505+0800 YSC-GCD-demo[20111:5046708] currentThread—{number = 1, name = main}<br>2018-02-23 20:45:49.981935+0800 YSC-GCD-demo[20111:5046708] asyncMain—begin<br>2018-02-23 20:45:49.982352+0800 YSC-GCD-demo[20111:5046708] asyncMain—end<br>2018-02-23 20:45:51.991096+0800 YSC-GCD-demo[20111:5046708] 1—{number = 1, name = main}<br>2018-02-23 20:45:53.991959+0800 YSC-GCD-demo[20111:5046708] 1—{number = 1, name = main}<br>2018-02-23 20:45:55.992937+0800 YSC-GCD-demo[20111:5046708] 2—{number = 1, name = main}<br>2018-02-23 20:45:57.993649+0800 YSC-GCD-demo[20111:5046708] 2—{number = 1, name = main}<br>2018-02-23 20:45:59.994928+0800 YSC-GCD-demo[20111:5046708] 3—{number = 1, name = main}<br>2018-02-23 20:46:01.995589+0800 YSC-GCD-demo[20111:5046708] 3—{number = 1, name = main}</p>
</blockquote>
<p>在<code>异步执行 + 主队列</code>可以看到：</p>
<ul>
<li>所有任务都是在当前线程（主线程）中执行的，并没有开启新的线程（虽然<code>异步执行</code>具备开启线程的能力，但因为是主队列，所以所有任务都在主线程中）。</li>
<li>所有任务是在打印的syncConcurrent—begin和syncConcurrent—end之后才开始执行的（异步执行不会做任何等待，可以继续执行任务）。</li>
<li>任务是按顺序执行的（因为主队列是<code>串行队列</code>，每次只有一个任务被执行，任务一个接一个按顺序执行）。</li>
</ul>
<p>弄懂了难理解、绕来绕去的<strong>队列+任务</strong>之后，我们来学习一个简单的东西：<strong>5. GCD 线程间的通信</strong>。</p>
<h1 id="5-GCD-线程间的通信"><a href="#5-GCD-线程间的通信" class="headerlink" title="5. GCD 线程间的通信"></a>5. GCD 线程间的通信</h1><p>在iOS开发过程中，我们一般在主线程里边进行UI刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线程间通信</span><br><span class="line"> */</span><br><span class="line">- (void)communication &#123;</span><br><span class="line">    // 获取全局并发队列</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); </span><br><span class="line">    // 获取主队列</span><br><span class="line">    dispatch_queue_t mainQueue = dispatch_get_main_queue(); </span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 异步追加任务</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 回到主线程</span><br><span class="line">        dispatch_async(mainQueue, ^&#123;</span><br><span class="line">            // 追加在主线程中执行的任务</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2018-02-23 20:47:03.462394+0800 YSC-GCD-demo[20154:5053282] 1—{number = 3, name = (null)}<br>2018-02-23 20:47:05.465912+0800 YSC-GCD-demo[20154:5053282] 1—{number = 3, name = (null)}<br>2018-02-23 20:47:07.466657+0800 YSC-GCD-demo[20154:5052953] 2—{number = 1, name = main}</p>
</blockquote>
<ul>
<li>可以看到在其他线程中先执行任务，执行完了之后回到主线程执行主线程的相应操作。</li>
</ul>
<h1 id="6-GCD-的其他方法"><a href="#6-GCD-的其他方法" class="headerlink" title="6. GCD 的其他方法"></a>6. GCD 的其他方法</h1><h2 id="6-1-GCD-栅栏方法：dispatch-barrier-async"><a href="#6-1-GCD-栅栏方法：dispatch-barrier-async" class="headerlink" title="6.1 GCD 栅栏方法：dispatch_barrier_async"></a>6.1 GCD 栅栏方法：dispatch_barrier_async</h2><ul>
<li>我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于<code>栅栏</code>一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到<code>dispatch_barrier_async</code>方法在两个操作组间形成栅栏。<br><code>dispatch_barrier_async</code>函数会等待前边追加到并发队列中的任务全部执行完毕之后，再将指定的任务追加到该异步队列中。然后在<code>dispatch_barrier_async</code>函数追加的任务执行完毕之后，异步队列才恢复为一般动作，接着追加任务到该异步队列并开始执行。具体如下图所示：<br><a href="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-barrier.png" target="_blank" rel="noopener"><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-barrier.png" alt="dispatch_barrier_async.png"></a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 栅栏方法 dispatch_barrier_async</span><br><span class="line"> */</span><br><span class="line">- (void)barrier &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        // 追加任务 barrier</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;barrier---%@&quot;,[NSThread currentThread]);// 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务4</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;4---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2018-02-23 20:48:18.297745+0800 YSC-GCD-demo[20188:5059274] 1—{number = 4, name = (null)}<br>2018-02-23 20:48:18.297745+0800 YSC-GCD-demo[20188:5059273] 2—{number = 3, name = (null)}<br>2018-02-23 20:48:20.301139+0800 YSC-GCD-demo[20188:5059274] 1—{number = 4, name = (null)}<br>2018-02-23 20:48:20.301139+0800 YSC-GCD-demo[20188:5059273] 2—{number = 3, name = (null)}<br>2018-02-23 20:48:22.306290+0800 YSC-GCD-demo[20188:5059274] barrier—{number = 4, name = (null)}<br>2018-02-23 20:48:24.311655+0800 YSC-GCD-demo[20188:5059274] barrier—{number = 4, name = (null)}<br>2018-02-23 20:48:26.316943+0800 YSC-GCD-demo[20188:5059273] 4—{number = 3, name = (null)}<br>2018-02-23 20:48:26.316956+0800 YSC-GCD-demo[20188:5059274] 3—{number = 4, name = (null)}<br>2018-02-23 20:48:28.320660+0800 YSC-GCD-demo[20188:5059273] 4—{number = 3, name = (null)}<br>2018-02-23 20:48:28.320649+0800 YSC-GCD-demo[20188:5059274] 3—{number = 4, name = (null)}</p>
</blockquote>
<p>在<code>dispatch_barrier_async</code>执行结果中可以看出：</p>
<ul>
<li>在执行完栅栏前面的操作之后，才执行栅栏操作，最后再执行栅栏后边的操作。</li>
</ul>
<h2 id="6-2-GCD-延时执行方法：dispatch-after"><a href="#6-2-GCD-延时执行方法：dispatch-after" class="headerlink" title="6.2 GCD 延时执行方法：dispatch_after"></a>6.2 GCD 延时执行方法：dispatch_after</h2><p>我们经常会遇到这样的需求：在指定时间（例如3秒）之后执行某个任务。可以用 GCD 的<code>dispatch_after</code>函数来实现。<br>需要注意的是：<code>dispatch_after</code>函数并不是在指定时间之后才开始执行处理，而是在指定时间之后将任务追加到主队列中。严格来说，这个时间并不是绝对准确的，但想要大致延迟执行任务，<code>dispatch_after</code>函数是很有效的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 延时执行方法 dispatch_after</span><br><span class="line"> */</span><br><span class="line">- (void)after &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    NSLog(@&quot;asyncMain---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        // 2.0秒后异步追加任务代码到主队列，并开始执行</span><br><span class="line">        NSLog(@&quot;after---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2018-02-23 20:53:08.713784+0800 YSC-GCD-demo[20282:5080295] currentThread—{number = 1, name = main}<br>2018-02-23 20:53:08.713962+0800 YSC-GCD-demo[20282:5080295] asyncMain—begin<br>2018-02-23 20:53:10.714283+0800 YSC-GCD-demo[20282:5080295] after—{number = 1, name = main}</p>
</blockquote>
<p>可以看出：在打印 <code>asyncMain---begin</code> 之后大约 2.0 秒的时间，打印了 <code>after---&lt;NSThread: 0x60000006ee00&gt;{number = 1, name = main}</code></p>
<h2 id="6-3-GCD-一次性代码（只执行一次）：dispatch-once"><a href="#6-3-GCD-一次性代码（只执行一次）：dispatch-once" class="headerlink" title="6.3 GCD 一次性代码（只执行一次）：dispatch_once"></a>6.3 GCD 一次性代码（只执行一次）：dispatch_once</h2><ul>
<li>我们在创建单例、或者有整个程序运行过程中只执行一次的代码时，我们就用到了 GCD 的 <code>dispatch_once</code> 函数。使用<br><code>dispatch_once</code> 函数能保证某段代码在程序运行过程中只被执行1次，并且即使在多线程的环境下，<code>dispatch_once</code>也可以保证线程安全。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 一次性代码（只执行一次）dispatch_once</span><br><span class="line"> */</span><br><span class="line">- (void)once &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        // 只执行1次的代码(这里面默认是线程安全的)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-4-GCD-快速迭代方法：dispatch-apply"><a href="#6-4-GCD-快速迭代方法：dispatch-apply" class="headerlink" title="6.4 GCD 快速迭代方法：dispatch_apply"></a>6.4 GCD 快速迭代方法：dispatch_apply</h2><ul>
<li>通常我们会用 for 循环遍历，但是 GCD 给我们提供了快速迭代的函数 <code>dispatch_apply</code>。<code>dispatch_apply</code> 按照指定的次数将指定的任务追加到指定的队列中，并等待全部队列执行结束。</li>
</ul>
<p>如果是在串行队列中使用 <code>dispatch_apply</code>，那么就和 for 循环一样，按顺序同步执行。可这样就体现不出快速迭代的意义了。<br>我们可以利用并发队列进行异步执行。比如说遍历 0~5 这6个数字，for 循环的做法是每次取出一个元素，逐个遍历。<code>dispatch_apply</code> 可以 在多个线程中同时（异步）遍历多个数字。<br>还有一点，无论是在串行队列，还是异步队列中，dispatch_apply 都会等待全部任务执行完毕，这点就像是同步操作，也像是队列组中的 <code>dispatch_group_wait</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 快速迭代方法 dispatch_apply</span><br><span class="line"> */</span><br><span class="line">- (void)apply &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;apply---begin&quot;);</span><br><span class="line">    dispatch_apply(6, queue, ^(size_t index) &#123;</span><br><span class="line">        NSLog(@&quot;%zd---%@&quot;,index, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;apply---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2018-02-23 22:03:18.475499+0800 YSC-GCD-demo[20470:5176805] apply—begin<br>2018-02-23 22:03:18.476672+0800 YSC-GCD-demo[20470:5177035] 1—{number = 3, name = (null)}<br>2018-02-23 22:03:18.476693+0800 YSC-GCD-demo[20470:5176805] 0—{number = 1, name = main}<br>2018-02-23 22:03:18.476704+0800 YSC-GCD-demo[20470:5177037] 2—{number = 4, name = (null)}<br>2018-02-23 22:03:18.476735+0800 YSC-GCD-demo[20470:5177036] 3—{number = 5, name = (null)}<br>2018-02-23 22:03:18.476867+0800 YSC-GCD-demo[20470:5177035] 4—{number = 3, name = (null)}<br>2018-02-23 22:03:18.476867+0800 YSC-GCD-demo[20470:5176805] 5—{number = 1, name = main}<br>2018-02-23 22:03:18.477038+0800 YSC-GCD-demo[20470:5176805] apply—end</p>
</blockquote>
<p>因为是在并发队列中异步队执行任务，所以各个任务的执行时间长短不定，最后结束顺序也不定。但是<code>apply---end</code>一定在最后执行。这是因为<code>dispatch_apply</code>函数会等待全部任务执行完毕。</p>
<h2 id="6-5-GCD-的队列组：dispatch-group"><a href="#6-5-GCD-的队列组：dispatch-group" class="headerlink" title="6.5 GCD 的队列组：dispatch_group"></a>6.5 GCD 的队列组：dispatch_group</h2><p>有时候我们会有这样的需求：分别异步执行2个耗时任务，然后当2个耗时任务都执行完毕后再回到主线程执行任务。这时候我们可以用到 GCD 的队列组。</p>
<ul>
<li>调用队列组的 <code>dispatch_group_async</code> 先把任务放到队列中，然后将队列放入队列组中。或者使用队列组的 <code>dispatch_group_enter、dispatch_group_leave</code> 组合 来实现<br><code>dispatch_group_async</code>。</li>
<li>调用队列组的 <code>dispatch_group_notify</code> 回到指定线程执行任务。或者使用 <code>dispatch_group_wait</code>回到当前线程继续向下执行（会阻塞当前线程）。</li>
</ul>
<h3 id="6-5-1-dispatch-group-notify"><a href="#6-5-1-dispatch-group-notify" class="headerlink" title="6.5.1 dispatch_group_notify"></a>6.5.1 dispatch_group_notify</h3><ul>
<li>监听 group 中任务的完成状态，当所有的任务都执行完成后，追加任务到 group 中，并执行任务。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 队列组 dispatch_group_notify</span><br><span class="line"> */</span><br><span class="line">- (void)groupNotify &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    NSLog(@&quot;group---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_t group =  dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        // 等前面的异步任务1、任务2都执行完毕后，回到主线程执行下边任务</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;group---end&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2018-02-23 22:05:03.790035+0800 YSC-GCD-demo[20494:5183349] currentThread—{number = 1, name = main}<br>2018-02-23 22:05:03.790237+0800 YSC-GCD-demo[20494:5183349] group—begin<br>2018-02-23 22:05:05.792721+0800 YSC-GCD-demo[20494:5183654] 1—{number = 4, name = (null)}<br>2018-02-23 22:05:05.792725+0800 YSC-GCD-demo[20494:5183656] 2—{number = 3, name = (null)}<br>2018-02-23 22:05:07.797408+0800 YSC-GCD-demo[20494:5183656] 2—{number = 3, name = (null)}<br>2018-02-23 22:05:07.797408+0800 YSC-GCD-demo[20494:5183654] 1—{number = 4, name = (null)}<br>2018-02-23 22:05:09.798717+0800 YSC-GCD-demo[20494:5183349] 3—{number = 1, name = main}<br>2018-02-23 22:05:11.799827+0800 YSC-GCD-demo[20494:5183349] 3—{number = 1, name = main}<br>2018-02-23 22:05:11.799977+0800 YSC-GCD-demo[20494:5183349] group—end</p>
</blockquote>
<p>从<code>dispatch_group_notify</code>相关代码运行输出结果可以看出：<br>当所有任务都执行完成之后，才执行<code>dispatch_group_notify</code> block 中的任务。</p>
<h3 id="6-5-2-dispatch-group-wait"><a href="#6-5-2-dispatch-group-wait" class="headerlink" title="6.5.2 dispatch_group_wait"></a>6.5.2 dispatch_group_wait</h3><ul>
<li>暂停当前线程（阻塞当前线程），等待指定的 group 中的任务执行完成后，才会往下继续执行。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 队列组 dispatch_group_wait</span><br><span class="line"> */</span><br><span class="line">- (void)groupWait &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    NSLog(@&quot;group---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_t group =  dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    // 等待上面的任务全部完成后，会往下继续执行（会阻塞当前线程）</span><br><span class="line">    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;group---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2018-02-23 22:10:16.939258+0800 YSC-GCD-demo[20538:5198871] currentThread—{number = 1, name = main}<br>2018-02-23 22:10:16.939455+0800 YSC-GCD-demo[20538:5198871] group—begin<br>2018-02-23 22:10:18.943862+0800 YSC-GCD-demo[20538:5199137] 2—{number = 4, name = (null)}<br>2018-02-23 22:10:18.943861+0800 YSC-GCD-demo[20538:5199138] 1—{number = 3, name = (null)}<br>2018-02-23 22:10:20.947787+0800 YSC-GCD-demo[20538:5199137] 2—{number = 4, name = (null)}<br>2018-02-23 22:10:20.947790+0800 YSC-GCD-demo[20538:5199138] 1—{number = 3, name = (null)}<br>2018-02-23 22:10:20.948134+0800 YSC-GCD-demo[20538:5198871] group—end</p>
</blockquote>
<p>从<code>dispatch_group_wait</code>相关代码运行输出结果可以看出：<br>当所有任务执行完成之后，才执行 <code>dispatch_group_wait</code> 之后的操作。但是，使用<code>dispatch_group_wait</code> 会阻塞当前线程。</p>
<h3 id="6-5-3-dispatch-group-enter、dispatch-group-leave"><a href="#6-5-3-dispatch-group-enter、dispatch-group-leave" class="headerlink" title="6.5.3 dispatch_group_enter、dispatch_group_leave"></a>6.5.3 dispatch_group_enter、dispatch_group_leave</h3><ul>
<li><code>dispatch_group_enter</code> 标志着一个任务追加到 group，执行一次，相当于 group 中未执行完毕任务数+1</li>
<li><code>dispatch_group_leave</code> 标志着一个任务离开了 group，执行一次，相当于 group 中未执行完毕任务数-1。</li>
<li>当 group 中未执行完毕任务数为0的时候，才会使<code>dispatch_group_wait</code>解除阻塞，以及执行追加到<code>dispatch_group_notify</code>中的任务。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 队列组 dispatch_group_enter、dispatch_group_leave</span><br><span class="line"> */</span><br><span class="line">- (void)groupEnterAndLeave</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    NSLog(@&quot;group---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        // 等前面的异步操作都执行完毕后，回到主线程.</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;group---end&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">//    // 等待上面的任务全部完成后，会往下继续执行（会阻塞当前线程）</span><br><span class="line">//    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">//</span><br><span class="line">//    NSLog(@&quot;group---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2018-02-23 22:14:17.997667+0800 YSC-GCD-demo[20592:5214830] currentThread—{number = 1, name = main}<br>2018-02-23 22:14:17.997839+0800 YSC-GCD-demo[20592:5214830] group—begin<br>2018-02-23 22:14:20.000298+0800 YSC-GCD-demo[20592:5215094] 1—{number = 4, name = (null)}<br>2018-02-23 22:14:20.000305+0800 YSC-GCD-demo[20592:5215095] 2—{number = 3, name = (null)}<br>2018-02-23 22:14:22.001323+0800 YSC-GCD-demo[20592:5215094] 1—{number = 4, name = (null)}<br>2018-02-23 22:14:22.001339+0800 YSC-GCD-demo[20592:5215095] 2—{number = 3, name = (null)}<br>2018-02-23 22:14:24.002321+0800 YSC-GCD-demo[20592:5214830] 3—{number = 1, name = main}<br>2018-02-23 22:14:26.002852+0800 YSC-GCD-demo[20592:5214830] 3—{number = 1, name = main}<br>2018-02-23 22:14:26.003116+0800 YSC-GCD-demo[20592:5214830] group—end</p>
</blockquote>
<p>从<code>dispatch_group_enter、dispatch_group_leave</code>相关代码运行结果中可以看出：当所有任务执行完成之后，才执行 dispatch_group_notify 中的任务。这里的<code>dispatch_group_enter、dispatch_group_leave</code>组合，其实等同于<code>dispatch_group_async</code>。</p>
<h2 id="6-6-GCD-信号量：dispatch-semaphore"><a href="#6-6-GCD-信号量：dispatch-semaphore" class="headerlink" title="6.6 GCD 信号量：dispatch_semaphore"></a>6.6 GCD 信号量：dispatch_semaphore</h2><p>GCD 中的信号量是指 <strong>Dispatch Semaphore</strong>，是持有计数的信号。类似于过高速路收费站的栏杆。可以通过时，打开栏杆，不可以通过时，关闭栏杆。在 <strong>Dispatch Semaphore</strong> 中，使用计数来完成这个功能，计数为0时等待，不可通过。计数为1或大于1时，计数减1且不等待，可通过。<br><strong>Dispatch Semaphore</strong> 提供了三个函数。</p>
<ul>
<li><code>dispatch_semaphore_create</code>：创建一个Semaphore并初始化信号的总量</li>
<li><code>dispatch_semaphore_signal</code>：发送一个信号，让信号总量加1</li>
<li><code>dispatch_semaphore_wait</code>：可以使总信号量减1，当信号总量为0时就会一直等待（阻塞所在线程），否则就可以正常执行。</li>
</ul>
<blockquote>
<p>注意：信号量的使用前提是：想清楚你需要处理哪个线程等待（阻塞），又要哪个线程继续执行，然后使用信号量。</p>
</blockquote>
<p>Dispatch Semaphore 在实际开发中主要用于：</p>
<ul>
<li>保持线程同步，将异步执行任务转换为同步执行任务</li>
<li>保证线程安全，为线程加锁</li>
</ul>
<h3 id="6-6-1-Dispatch-Semaphore-线程同步"><a href="#6-6-1-Dispatch-Semaphore-线程同步" class="headerlink" title="6.6.1 Dispatch Semaphore 线程同步"></a>6.6.1 Dispatch Semaphore 线程同步</h3><p>我们在开发中，会遇到这样的需求：异步执行耗时任务，并使用异步执行的结果进行一些额外的操作。换句话说，相当于，将将异步执行任务转换为同步执行任务。比如说：AFNetworking 中 AFURLSessionManager.m 里面的 <code>tasksForKeyPath:</code> 方法。通过引入信号量的方式，等待异步执行任务结果，获取到 tasks，然后再返回该 tasks。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (NSArray *)tasksForKeyPath:(NSString *)keyPath &#123;</span><br><span class="line">    __block NSArray *tasks = nil;</span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line">    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123;</span><br><span class="line">        if ([keyPath isEqualToString:NSStringFromSelector(@selector(dataTasks))]) &#123;</span><br><span class="line">            tasks = dataTasks;</span><br><span class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(uploadTasks))]) &#123;</span><br><span class="line">            tasks = uploadTasks;</span><br><span class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(downloadTasks))]) &#123;</span><br><span class="line">            tasks = downloadTasks;</span><br><span class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(tasks))]) &#123;</span><br><span class="line">            tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:@&quot;@unionOfArrays.self&quot;];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">    return tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面，我们来利用 Dispatch Semaphore 实现线程同步，将异步执行任务转换为同步执行任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * semaphore 线程同步</span><br><span class="line"> */</span><br><span class="line">- (void)semaphoreSync &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    NSLog(@&quot;semaphore---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line">    </span><br><span class="line">    __block int number = 0;</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        </span><br><span class="line">        number = 100;</span><br><span class="line">        </span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    NSLog(@&quot;semaphore---end,number = %zd&quot;,number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>2018-02-23 22:22:26.521665+0800 YSC-GCD-demo[20642:5246341] currentThread—{number = 1, name = main}<br>2018-02-23 22:22:26.521869+0800 YSC-GCD-demo[20642:5246341] semaphore—begin<br>2018-02-23 22:22:28.526841+0800 YSC-GCD-demo[20642:5246638] 1—{number = 3, name = (null)}<br>2018-02-23 22:22:28.527030+0800 YSC-GCD-demo[20642:5246341] semaphore—end,number = 100</p>
</blockquote>
<p>从 Dispatch Semaphore 实现线程同步的代码可以看到：</p>
<ul>
<li><code>semaphore---end</code> 是在执行完 <code>number = 100;</code> 之后才打印的。而且输出结果 number 为 100。<br>这是因为<code>异步执行</code>不会做任何等待，可以继续执行任务。<code>异步执行</code>将任务1追加到队列之后，不做等待，接着执行<code>dispatch_semaphore_wait</code>方法。此时 semaphore == 0，当前线程进入等待状态。然后，异步任务1开始执行。任务1执行到<code>dispatch_semaphore_signal</code>之后，总信号量，此时 semaphore == 1，<code>dispatch_semaphore_wait</code>方法使总信号量减1，正在被阻塞的线程（主线程）恢复继续执行。最后打印<code>semaphore---end,number = 100</code>。这样就实现了线程同步，将异步执行任务转换为同步执行任务。</li>
</ul>
<h3 id="6-6-2-Dispatch-Semaphore-线程安全和线程同步（为线程加锁）"><a href="#6-6-2-Dispatch-Semaphore-线程安全和线程同步（为线程加锁）" class="headerlink" title="6.6.2 Dispatch Semaphore 线程安全和线程同步（为线程加锁）"></a>6.6.2 Dispatch Semaphore 线程安全和线程同步（为线程加锁）</h3><p><strong>线程安全</strong>：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<p>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。</p>
<p><strong>线程同步</strong>：可理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。</p>
<p>举个简单例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清(操作冲突)。等一个人说完(一个线程结束操作)，另一个再说(另一个线程再开始操作)。</p>
<p>下面，我们模拟火车票售卖的方式，实现 NSThread 线程安全和解决线程同步问题。</p>
<p>场景：总共有50张火车票，有两个售卖火车票的窗口，一个是北京火车票售卖窗口，另一个是上海火车票售卖窗口。两个窗口同时售卖火车票，卖完为止。</p>
<h4 id="6-6-2-1-非线程安全（不使用-semaphore）"><a href="#6-6-2-1-非线程安全（不使用-semaphore）" class="headerlink" title="6.6.2.1 非线程安全（不使用 semaphore）"></a>6.6.2.1 非线程安全（不使用 semaphore）</h4><p>先来看看不考虑线程安全的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 非线程安全：不使用 semaphore</span><br><span class="line"> * 初始化火车票数量、卖票窗口(非线程安全)、并开始卖票</span><br><span class="line"> */</span><br><span class="line">- (void)initTicketStatusNotSave &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    NSLog(@&quot;semaphore---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    self.ticketSurplusCount = 50;</span><br><span class="line">    </span><br><span class="line">    // queue1 代表北京火车票售卖窗口</span><br><span class="line">    dispatch_queue_t queue1 = dispatch_queue_create(&quot;net.bujige.testQueue1&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    // queue2 代表上海火车票售卖窗口</span><br><span class="line">    dispatch_queue_t queue2 = dispatch_queue_create(&quot;net.bujige.testQueue2&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    dispatch_async(queue1, ^&#123;</span><br><span class="line">        [weakSelf saleTicketNotSafe];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue2, ^&#123;</span><br><span class="line">        [weakSelf saleTicketNotSafe];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 售卖火车票(非线程安全)</span><br><span class="line"> */</span><br><span class="line">- (void)saleTicketNotSafe &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        </span><br><span class="line">        if (self.ticketSurplusCount &gt; 0) &#123;  //如果还有票，继续售卖</span><br><span class="line">            self.ticketSurplusCount--;</span><br><span class="line">            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%d 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]);</span><br><span class="line">            [NSThread sleepForTimeInterval:0.2];</span><br><span class="line">        &#125; else &#123; //如果已卖完，关闭售票窗口</span><br><span class="line">            NSLog(@&quot;所有火车票均已售完&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果（部分）：<br>2018-02-23 22:25:35.789072+0800 YSC-GCD-demo[20712:5258914] currentThread—{number = 1, name = main}<br>2018-02-23 22:25:35.789260+0800 YSC-GCD-demo[20712:5258914] semaphore—begin<br>2018-02-23 22:25:35.789641+0800 YSC-GCD-demo[20712:5259176] 剩余票数：48 窗口：{number = 3, name = (null)}<br>2018-02-23 22:25:35.789646+0800 YSC-GCD-demo[20712:5259175] 剩余票数：49 窗口：{number = 4, name = (null)}<br>2018-02-23 22:25:35.994113+0800 YSC-GCD-demo[20712:5259175] 剩余票数：47 窗口：{number = 4, name = (null)}<br>2018-02-23 22:25:35.994129+0800 YSC-GCD-demo[20712:5259176] 剩余票数：46 窗口：{number = 3, name = (null)}<br>2018-02-23 22:25:36.198993+0800 YSC-GCD-demo[20712:5259176] 剩余票数：45 窗口：{number = 3, name = (null)}<br>…</p>
</blockquote>
<p>可以看到在不考虑线程安全，不使用 semaphore 的情况下，得到票数是错乱的，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。</p>
<h4 id="6-6-2-2-线程安全（使用-semaphore-加锁）"><a href="#6-6-2-2-线程安全（使用-semaphore-加锁）" class="headerlink" title="6.6.2.2 线程安全（使用 semaphore 加锁）"></a>6.6.2.2 线程安全（使用 semaphore 加锁）</h4><p>考虑线程安全的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线程安全：使用 semaphore 加锁</span><br><span class="line"> * 初始化火车票数量、卖票窗口(线程安全)、并开始卖票</span><br><span class="line"> */</span><br><span class="line">- (void)initTicketStatusSave &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    NSLog(@&quot;semaphore---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    semaphoreLock = dispatch_semaphore_create(1);</span><br><span class="line">    </span><br><span class="line">    self.ticketSurplusCount = 50;</span><br><span class="line">    </span><br><span class="line">    // queue1 代表北京火车票售卖窗口</span><br><span class="line">    dispatch_queue_t queue1 = dispatch_queue_create(&quot;net.bujige.testQueue1&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    // queue2 代表上海火车票售卖窗口</span><br><span class="line">    dispatch_queue_t queue2 = dispatch_queue_create(&quot;net.bujige.testQueue2&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    dispatch_async(queue1, ^&#123;</span><br><span class="line">        [weakSelf saleTicketSafe];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue2, ^&#123;</span><br><span class="line">        [weakSelf saleTicketSafe];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 售卖火车票(线程安全)</span><br><span class="line"> */</span><br><span class="line">- (void)saleTicketSafe &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        // 相当于加锁</span><br><span class="line">        dispatch_semaphore_wait(semaphoreLock, DISPATCH_TIME_FOREVER);</span><br><span class="line">        </span><br><span class="line">        if (self.ticketSurplusCount &gt; 0) &#123;  //如果还有票，继续售卖</span><br><span class="line">            self.ticketSurplusCount--;</span><br><span class="line">            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%d 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]);</span><br><span class="line">            [NSThread sleepForTimeInterval:0.2];</span><br><span class="line">        &#125; else &#123; //如果已卖完，关闭售票窗口</span><br><span class="line">            NSLog(@&quot;所有火车票均已售完&quot;);</span><br><span class="line">            </span><br><span class="line">            // 相当于解锁</span><br><span class="line">            dispatch_semaphore_signal(semaphoreLock);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 相当于解锁</span><br><span class="line">        dispatch_semaphore_signal(semaphoreLock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果为：<br>2018-02-23 22:32:19.814232+0800 YSC-GCD-demo[20862:5290531] currentThread—{number = 1, name = main}<br>2018-02-23 22:32:19.814412+0800 YSC-GCD-demo[20862:5290531] semaphore—begin<br>2018-02-23 22:32:19.814837+0800 YSC-GCD-demo[20862:5290687] 剩余票数：49 窗口：{number = 3, name = (null)}<br>2018-02-23 22:32:20.017745+0800 YSC-GCD-demo[20862:5290689] 剩余票数：48 窗口：{number = 4, name = (null)}<br>2018-02-23 22:32:20.222039+0800 YSC-GCD-demo[20862:5290687] 剩余票数：47 窗口：{number = 3, name = (null)}<br>…<br>2018-02-23 22:32:29.024817+0800 YSC-GCD-demo[20862:5290689] 剩余票数：4 窗口：{number = 4, name = (null)}<br>2018-02-23 22:32:29.230110+0800 YSC-GCD-demo[20862:5290687] 剩余票数：3 窗口：{number = 3, name = (null)}<br>2018-02-23 22:32:29.433615+0800 YSC-GCD-demo[20862:5290689] 剩余票数：2 窗口：{number = 4, name = (null)}<br>2018-02-23 22:32:29.637572+0800 YSC-GCD-demo[20862:5290687] 剩余票数：1 窗口：{number = 3, name = (null)}<br>2018-02-23 22:32:29.840234+0800 YSC-GCD-demo[20862:5290689] 剩余票数：0 窗口：{number = 4, name = (null)}<br>2018-02-23 22:32:30.044960+0800 YSC-GCD-demo[20862:5290687] 所有火车票均已售完<br>2018-02-23 22:32:30.045260+0800 YSC-GCD-demo[20862:5290689] 所有火车票均已售完</p>
</blockquote>
<p>可以看出，在考虑了线程安全的情况下，使用 <code>dispatch_semaphore</code><br>机制之后，得到的票数是正确的，没有出现混乱的情况。我们也就解决了多个线程同步的问题。</p>
<hr>
<p>参考资料：</p>
<ul>
<li><a href="https://blog.csdn.net/liuyang11908/article/details/70757534" target="_blank" rel="noopener">iOS GCD之dispatch_semaphore（信号量）</a></li>
</ul>
<hr>
<p>iOS多线程详尽总结系列文章：</p>
<ul>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-pthread-and-NSThread.html" target="_blank" rel="noopener">iOS多线程：『pthread、NSThread』详尽总结</a></li>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-GCD.html" target="_blank" rel="noopener">iOS多线程：『GCD』详解总结</a></li>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-NSOperation.html" target="_blank" rel="noopener">iOS多线程：『NSOperation』详解总结</a></li>
<li><a href="https://bujige.net/blog/iOS-Complete-learning-RunLoop.html" target="_blank" rel="noopener">iOS多线程：『RunLoop』详解总结</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/iOS-Block用法和实现原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/iOS-Block用法和实现原理/" itemprop="url">
                  iOS Block用法和实现原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 11:49:27 / 修改时间：11:55:19" itemprop="dateCreated datePublished" datetime="2018-09-17T11:49:27+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Block/" itemprop="url" rel="index"><span itemprop="name">Block</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>《Objective-C高级编程》是一本有趣又难懂的书，全书就讲了引用计数、Block、GCD三个概念，有趣是因为讲原理、实现的部分是其它iOS专业书籍里少有的。然而每个章节不读个三五遍还是比较难理解贯通的。本文针对其中的Block部分做些简单的笔记记录，讲述Block的用法和部分实现原理，详细解说从原书中寻。</p>
<h2 id="Block概要"><a href="#Block概要" class="headerlink" title="Block概要"></a>Block概要</h2><p><strong>Block</strong>：带有<strong>自动变量</strong>的<strong>匿名函数</strong>。<br><strong>匿名函数</strong>：没有函数名的函数，一对{}包裹的内容是匿名函数的作用域。<br><strong>自动变量</strong>：栈上声明的一个变量不是静态变量和全局变量，是不可以在这个栈内声明的匿名函数中使用的，但在Block中却可以。<br>虽然使用Block不用声明类，但是Block提供了类似Objective-C的类一样可以通过成员变量来<strong>保存作用域外变量值</strong>的方法，那些在Block的一对{}里使用到但却是在{}作用域以外声明的变量，就是Block截获的自动变量。</p>
<h2 id="Block常规概念"><a href="#Block常规概念" class="headerlink" title="Block常规概念"></a>Block常规概念</h2><h3 id="Block语法"><a href="#Block语法" class="headerlink" title="Block语法"></a>Block语法</h3><p>Block表达式语法：</p>
<blockquote>
<p>^ 返回值类型 (参数列表) {表达式}</p>
</blockquote>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^ int (int count) &#123;</span><br><span class="line">    return count + 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，可省略部分有：</p>
<ul>
<li>返回类型，例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^ (int count) &#123;</span><br><span class="line">    return count + 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数列表为空，则可省略，例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^ &#123;</span><br><span class="line">    NSLog(@&quot;No Parameter&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>即最简模式语法为：</p>
<blockquote>
<p>^ {表达式}</p>
</blockquote>
<h3 id="Block类型变量"><a href="#Block类型变量" class="headerlink" title="Block类型变量"></a>Block类型变量</h3><p>声明Block类型变量语法：</p>
<blockquote>
<p>返回值类型 (^变量名)(参数列表) = Block表达式</p>
</blockquote>
<p>例如，如下声明了一个变量名为blk的Block：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int (^blk)(int) = ^(int count) &#123;</span><br><span class="line">    return count + 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当Block类型变量作为函数的参数时，写作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)func:(int (^)(int))blk &#123;</span><br><span class="line">    NSLog(@&quot;Param:%@&quot;, blk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>借助typedef可简写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef int (^blk_k)(int);</span><br><span class="line"></span><br><span class="line">- (void)func:(blk_k)blk &#123;</span><br><span class="line">    NSLog(@&quot;Param:%@&quot;, blk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Block类型变量作返回值时，写作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (int (^)(int))funcR &#123;</span><br><span class="line">    return ^(int count) &#123;</span><br><span class="line">        return count ++;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>借助typedef简写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef int (^blk_k)(int);</span><br><span class="line"></span><br><span class="line">- (blk_k)funcR &#123;</span><br><span class="line">    return ^(int count) &#123;</span><br><span class="line">        return count ++;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="截获自动变量值"><a href="#截获自动变量值" class="headerlink" title="截获自动变量值"></a>截获自动变量值</h3><p>Block表达式可截获所使用的自动变量的值。<br><strong>截获</strong>：保存自动变量的<strong>瞬间值</strong>。<br>因为是“瞬间值”，所以声明Block之后，即便在Block外修改自动变量的值，也不会对Block内截获的自动变量值产生影响。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int i = 10;</span><br><span class="line">void (^blk)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;In block, i = %d&quot;, i);</span><br><span class="line">&#125;;</span><br><span class="line">i = 20;//Block外修改变量i，也不影响Block内的自动变量</span><br><span class="line">blk();//i修改为20后才执行，打印: In block, i = 10</span><br><span class="line">NSLog(@&quot;i = %d&quot;, i);//打印：i = 20</span><br></pre></td></tr></table></figure>
<h3 id="block说明符号"><a href="#block说明符号" class="headerlink" title="__block说明符号"></a>__block说明符号</h3><p>自动变量截获的值为Block声明时刻的瞬间值，保存后就不能改写该值，如需对自动变量进行重新赋值，需要在变量声明前附加<strong>block说明符，这时该变量称为</strong>block变量。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__block int i = 10;//i为__block变量，可在block中重新赋值</span><br><span class="line">void (^blk)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;In block, i = %d&quot;, i);</span><br><span class="line">&#125;;</span><br><span class="line">i = 20;</span><br><span class="line">blk();//打印: In block, i = 20</span><br><span class="line">NSLog(@&quot;i = %d&quot;, i);//打印：i = 20</span><br></pre></td></tr></table></figure>
<h3 id="自动变量值为一个对象情况"><a href="#自动变量值为一个对象情况" class="headerlink" title="自动变量值为一个对象情况"></a>自动变量值为一个对象情况</h3><p>当自动变量为一个类的<strong>对象</strong>，且没有使用__block修饰时，虽然不可以在Block内对该变量进行重新赋值，但可以修改该对象的属性。<br>如果该对象是个Mutable的对象，例如NSMutableArray，则还可以在Block内对NSMutableArray进行元素的增删：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *array = [[NSMutableArray alloc] initWithObjects:@&quot;1&quot;, @&quot;2&quot;,nil ];</span><br><span class="line">NSLog(@&quot;Array Count:%ld&quot;, array.count);//打印Array Count:2</span><br><span class="line">void (^blk)(void) = ^&#123;</span><br><span class="line">    [array removeObjectAtIndex:0];//Ok</span><br><span class="line">    //array = [NSNSMutableArray new];//没有__block修饰，编译失败！</span><br><span class="line">&#125;;</span><br><span class="line">blk();</span><br><span class="line">NSLog(@&quot;Array Count:%ld&quot;, array.count);//打印Array Count:1</span><br></pre></td></tr></table></figure>
<h2 id="Block实现原理"><a href="#Block实现原理" class="headerlink" title="Block实现原理"></a>Block实现原理</h2><h3 id="使用Clang"><a href="#使用Clang" class="headerlink" title="使用Clang"></a>使用Clang</h3><p>Block实际上是作为极普通的<strong>C语言源码</strong>来处理的：含有Block语法的源码首先被转换<strong>成C语言编译器能处理的源码</strong>，再作为普通的C源代码<strong>进行编译</strong>。<br>使用LLVM编译器的clang命令可将含有Block的Objective-C代码转换成C++的源代码，以探查其具体实现方式：</p>
<blockquote>
<p>clang -rewrite-objc 源码文件名</p>
</blockquote>
<p>注：如果使用该命令报错：<em>’UIKit/UIKit.h’ file not found</em>，可参考<a href="https://www.jianshu.com/p/43a09727eb2c" target="_blank" rel="noopener">《Objective-C编译成C++代码报错》</a>解决。</p>
<h3 id="Block结构"><a href="#Block结构" class="headerlink" title="Block结构"></a>Block结构</h3><p>使用Block的时候，编译器对Block语法进行了怎样的转换？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    int count = 10;</span><br><span class="line">    void (^ blk)() = ^()&#123;</span><br><span class="line">        NSLog(@&quot;In Block:%d&quot;, count);</span><br><span class="line">    &#125;;</span><br><span class="line">    blk();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示的最简单的Block使用代码，经clang转换后，可得到以下几个部分（有代码删减和注释添加）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void __main_block_func_0(</span><br><span class="line">    struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    int count = __cself-&gt;count; // bound by copy</span><br><span class="line">    </span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_64_vf2p_jz52yz7x4xtcx55yv0r0000gn_T_main_d2f8d2_mi_0, </span><br><span class="line">    count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个函数的实现，对应Block中{}内的内容，这些内容被当做了C语言函数来处理，函数参数中的<strong>__cself</strong>相当于Objective-C中的self。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc; //描述Block大小、版本等信息</span><br><span class="line">  int count;</span><br><span class="line">  //构造函数函数</span><br><span class="line">  __main_block_impl_0(void *fp,</span><br><span class="line">          struct __main_block_desc_0 *desc,</span><br><span class="line">          int _count,</span><br><span class="line">          int flags=0) : count(_count) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock; //在函数栈上声明，则为_NSConcreteStackBlock</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>__main_block_impl_0</strong>即为<strong>main()函数栈上的Block结构体</strong>，其中的__block_impl结构体声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct __block_impl &#123;</span><br><span class="line">  void *isa;//指明对象的Class</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>__block_impl</strong>结构体，即为Block的结构体，可理解为<strong>Block的类结构</strong>。<br>再看下main()函数翻译的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    int count = 10;</span><br><span class="line">    void (* blk)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, count));</span><br><span class="line">    </span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>去除掉复杂的类型转化，可简写为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    int count = 10;</span><br><span class="line">    sturct __main_block_impl_0 *blk = &amp;__main_block_impl_0(__main_block_func_0,         //函数指针</span><br><span class="line">                                                           &amp;__main_block_desc_0_DATA)); //Block大小、版本等信息</span><br><span class="line">    </span><br><span class="line">    (*blk-&gt;FuncPtr)(blk);   //调用FuncPtr指向的函数，并将blk自己作为参数传入</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此，可以看出，<strong>Block也是Objective-C中的对象</strong>。<br>Block有三种类（即__block_impl的<strong>isa</strong>指针指向的值，isa说明参考<a href="https://www.jianshu.com/p/41735c66dccb" target="_blank" rel="noopener">《Objective-C isa 指针 与 runtime 机制》</a>），根据Block对象创建时<strong>所处数据区不同</strong>而进行区别：</p>
<ul>
<li><strong>_NSConcreteStackBlock</strong>：在栈上创建的Block对象</li>
<li><strong>_NSConcreteMallocBlock</strong>：在堆上创建的Block对象</li>
<li><strong>_NSConcreteGlobalBlock</strong>：全局数据区的Block对象</li>
</ul>
<h3 id="如何截获自动变量"><a href="#如何截获自动变量" class="headerlink" title="如何截获自动变量"></a>如何截获自动变量</h3><p>上部分介绍了<strong>Block的结构</strong>，和<strong>作为匿名函数的调用机制</strong>，那<strong>自动变量截获</strong>是发生在什么时候呢？<br>观察上节代码中<strong>__main_block_impl_0</strong>结构体（main栈上Block的结构体）的构造函数可以看到，栈上的变量count以参数的形式传入到了这个构造函数中，此处即为<strong>变量的自动截获</strong>。<br>因此可以这样理解：<strong>__block_impl</strong>结构体已经可以代表Block类了，但在栈上又声明了<strong>__main_block_impl_0</strong>结构体，对<strong>__block_impl</strong>进行<strong>封装</strong>后才来表示栈上的<strong>Block类</strong>，就是为了获取Block中使用到的栈上声明的变量（<strong>栈上没在Block中使用的变量不会被捕获</strong>），变量被保存在Block的结构体实例中。<br>所以在blk()执行之前，栈上简单数据类型的count无论发生什么变化，都不会影响到Block以参数形式传入而捕获的值。但这个变量是指向对象的指针时，是可以修改这个对象的属性的，只是不能为变量重新赋值。</p>
<h3 id="Block的存储域"><a href="#Block的存储域" class="headerlink" title="Block的存储域"></a>Block的存储域</h3><p>上文已提到，根据Block创建的位置不同，Block有三种类型，创建的Block对象分别会存储到栈、堆、全局数据区域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void (^blk)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;Global Block&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    blk();</span><br><span class="line">    NSLog(@&quot;%@&quot;,[blk class]);//打印：__NSGlobalBlock__</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面代码块中的全局blk自然是存储在全局数据区，但注意在<strong>函数栈上</strong>创建的blk，如果<strong>没有截获自动变量</strong>，Block的结构实例还是会被设置在程序的<strong>全局数据区，而非栈上</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    void (^blk)(void) = ^&#123;//没有截获自动变量的Block</span><br><span class="line">        NSLog(@&quot;Stack Block&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    blk();</span><br><span class="line">    NSLog(@&quot;%@&quot;,[blk class]);//打印:__NSGlobalBlock__</span><br><span class="line">    </span><br><span class="line">    int i = 1;</span><br><span class="line">    void (^captureBlk)(void) = ^&#123;//截获自动变量i的Block</span><br><span class="line">        NSLog(@&quot;Capture:%d&quot;, i);</span><br><span class="line">    &#125;;</span><br><span class="line">    captureBlk();</span><br><span class="line">    NSLog(@&quot;%@&quot;,[captureBlk class]);//打印：__NSMallocBlock__</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到截获了自动变量的Block打印的类是<strong>NSGlobalBlock</strong>，表示存储在全局数据区。<br>但为什么捕获自动变量的Block打印的类却是设置在堆上的<strong>NSMallocBlock</strong>，而非栈上的<strong>NSStackBlock</strong>?这个问题稍后解释。</p>
<h3 id="Block复制"><a href="#Block复制" class="headerlink" title="Block复制"></a>Block复制</h3><p>配置在栈上的Block，如果其所属的栈作用域结束，该Block就会被废弃，对于超出Block作用域仍需使用Block的情况，Block提供了<strong>将Block从栈上复制到堆上的方法</strong>来解决这种问题，即便Block栈作用域已结束，但被拷贝到堆上的Block还可以继续存在。<br>复制到堆上的Block，<strong>将_NSConcreteMallocBlock</strong>类对象写入Block结构体实例的成员变量isa：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">impl.isa = &amp;_NSConcreteMallocBlock;</span><br></pre></td></tr></table></figure>
<p>在ARC有效时，大多数情况下编译器会进行判断，自动生成将Block从栈上复制到堆上的代码，以下几种情况<strong>栈上的Block会自动复制到堆上</strong>：</p>
<ul>
<li>调用Block的copy方法</li>
<li>将Block作为函数返回值时</li>
<li>将Block赋值给__strong修改的变量时</li>
<li>向Cocoa框架含有usingBlock的方法或者GCD的API传递Block参数时</li>
</ul>
<p>其它时候向方法的参数中传递Block时，需要手动调用copy方法复制Block。<br>上一节的栈上截获了自动变量i的Block之所以在栈上创建，却是<em>NSMallocBlock<strong>类，就是因为这个Block对象赋值给了</strong></em>_strong修饰的变量<strong>captureBlk（_strong是ARC下对象的默认修饰符）。<br>因为上面四条规则，在ARC下其实很少见到_NSConcreteStackBlock类的Block，大多数情况编译器都保证了Block是在堆上创建的，如下代码所示，仅最后一行代码直接使用一个不赋值给变量的Block，它的类才是</strong>NSStackBlock**：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int count = 0;</span><br><span class="line">blk_t blk = ^()&#123;</span><br><span class="line">    NSLog(@&quot;In Stack:%d&quot;, count);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;blk&apos;s Class:%@&quot;, [blk class]);//打印：blk&apos;s Class:__NSMallocBlock__</span><br><span class="line">NSLog(@&quot;Global Block:%@&quot;, [^&#123;NSLog(@&quot;Global Block&quot;);&#125; class]);//打印：Global Block:__NSGlobalBlock__</span><br><span class="line">NSLog(@&quot;Copy Block:%@&quot;, [[^&#123;NSLog(@&quot;Copy Block:%d&quot;,count);&#125; copy] class]);//打印：Copy Block:__NSMallocBlock__</span><br><span class="line">NSLog(@&quot;Stack Block:%@&quot;, [^&#123;NSLog(@&quot;Stack Block:%d&quot;,count);&#125; class]);//打印：Stack Block:__NSStackBlock__</span><br></pre></td></tr></table></figure>
<p>关于ARC下和MRC下Block自动copy的区别，查看<a href="https://link.jianshu.com/?t=https://www.zybuluo.com/MicroCai/note/49713" target="_blank" rel="noopener">《Block 小测验》</a>里几道题目就能区分了。<br>另外，原书存在ARC和MRC混合讲解、区分不明的情况，比如书中几个使用到栈上对象导致Crash的例子是MRC条件下才会发生的，但书中没做特殊说明。</p>
<h3 id="使用-block发生了什么"><a href="#使用-block发生了什么" class="headerlink" title="使用__block发生了什么"></a>使用__block发生了什么</h3><p>Block捕获的自动变量添加<strong>block说明符，就可在Block内读和写该变量，也可以在原来的栈上读写该变量。<br><strong>自动变量的截获</strong>保证了栈上的自动变量被销毁后，Block内仍可使用该变量。<br>**</strong>block<strong>保证了栈上和Block内（通常在堆上）可以访问和修改</strong>“同一个变量”**，__block是如何实现这一功能的？</p>
<p><strong>block发挥作用的<strong>原理</strong>：将栈上用</strong>block修饰的自动变量<strong>封装成一个结构体</strong>，让其在堆上创建，以方便从栈上或堆上访问和修改同一份数据。</p>
<p><strong>验证过程</strong>：<br>现在对刚才的代码段，加上__block说明符，并在block内外读写变量count。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    __block int count = 10;</span><br><span class="line">    void (^ blk)() = ^()&#123;</span><br><span class="line">        count = 20;</span><br><span class="line">        NSLog(@&quot;In Block:%d&quot;, count);//打印：In Block:20</span><br><span class="line">    &#125;;</span><br><span class="line">    count ++;</span><br><span class="line">    NSLog(@&quot;Out Block:%d&quot;, count);//打印：Out Block:11</span><br><span class="line">    </span><br><span class="line">    blk();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上面的代码段clang，发现Block的结构体<strong>__main_block_impl_0</strong>结构如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_count_0 *count; // by ref</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_count_0 *_count, int flags=0) : count(_count-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最大的变化就是count变量不再是int类型了，count变成了一个指向<strong>__Block_byref_count_0</strong>结构体的指针，<strong>__Block_byref_count_0</strong>结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_count_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_count_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它保存了int count变量，还有一个指向<strong>__Block_byref_count_0</strong>实例的指针<strong>__forwarding</strong>，通过下面两段代码<strong>__forwarding</strong>指针的用法可以知道，该指针其实指向的是对象自身：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Block的执行函数</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_count_0 *count = __cself-&gt;count; // bound by ref</span><br><span class="line"></span><br><span class="line">        (count-&gt;__forwarding-&gt;count) = 20;//对应count = 20;</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_64_vf2p_jz52yz7x4xtcx55yv0r0000gn_T_main_fafeeb_mi_0, </span><br><span class="line">        (count-&gt;__forwarding-&gt;count));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//main函数</span><br><span class="line">int main() &#123;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_count_0 count = &#123;(void*)0,</span><br><span class="line">    (__Block_byref_count_0 *)&amp;count, </span><br><span class="line">    0, </span><br><span class="line">    sizeof(__Block_byref_count_0), </span><br><span class="line">    10&#125;;</span><br><span class="line">    </span><br><span class="line">    void (* blk)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, </span><br><span class="line">    &amp;__main_block_desc_0_DATA, </span><br><span class="line">    (__Block_byref_count_0 *)&amp;count, </span><br><span class="line">    570425344));</span><br><span class="line">    </span><br><span class="line">    (count.__forwarding-&gt;count) ++;//对应count ++;</span><br><span class="line">    </span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_64_vf2p_jz52yz7x4xtcx55yv0r0000gn_T_main_fafeeb_mi_1, </span><br><span class="line">    (count.__forwarding-&gt;count));</span><br><span class="line">    </span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要通过<strong>forwarding指针完成对count变量的读写修改？<br>为了保证无论是在栈上还是在堆上，都能通过都</strong>forwarding指针找到在堆上创建的count这个<strong>main_block_func_0结构体，以完成对count-&gt;count（第一个count是</strong>main_block_func_0对象，第二个count是int类型变量）的访问和修改。<br>示意图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2814-c2c1c0ffeda6ad43.jpg_s?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<h3 id="Block的循环引用"><a href="#Block的循环引用" class="headerlink" title="Block的循环引用"></a>Block的循环引用</h3><p>Block的循环引用原理和解决方法大家都比较熟悉，此处将结合上文的介绍，介绍一种不常用的解决Block循环引用的方法和一种借助Block参数解决该问题的方法。<br>Block循环引用<strong>原因</strong>：一个对象A有Block类型的属性，从而持有这个Block，如果Block的代码块中使用到这个对象A，或者仅仅是用用到A对象的属性，会使Block也持有A对象，导致两者互相持有，不能在作用域结束后正常释放。<br><strong>解决原理</strong>：对象A照常持有Block，但Block不能强引用持有对象A以打破循环。<br><strong>解决方法</strong>：<br><strong>方法一：</strong>对Block内要使用的对象A使用_<strong>_weak</strong>进行修饰，Block对对象A弱引用打破循环。</p>
<p>有三种常用形式：</p>
<ul>
<li>使用__weak ClassName</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__block XXViewController* weakSelf = self;</span><br><span class="line">self.blk = ^&#123;</span><br><span class="line">    NSLog(@&quot;In Block : %@&quot;,weakSelf);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用__weak typeof(self)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">self.blk = ^&#123;</span><br><span class="line">    NSLog(@&quot;In Block : %@&quot;,weakSelf);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>Reactive Cocoa中的@weakify和@strongify</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@weakify(self);</span><br><span class="line">self.blk = ^&#123;</span><br><span class="line">    @strongify(self);</span><br><span class="line">    NSLog(@&quot;In Block : %@&quot;,self);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其原理参考<a href="https://www.jianshu.com/p/3d6c4416db5e" target="_blank" rel="noopener">《@weakify, @strongify》</a>，自己简便实现参考<a href="https://link.jianshu.com/?t=http://blog.csdn.net/u014773226/article/details/54617716" target="_blank" rel="noopener">《@weak - @strong 宏的实现》</a></p>
<p><strong>方法二：</strong>对Block内要使用的对象A使用<strong>__block</strong>进行修饰，并在代码块内，使用完__block变量后将其设为nil，并且该block必须至少执行一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__block XXController *blkSelf = self;</span><br><span class="line">self.blk = ^&#123;</span><br><span class="line">    NSLog(@&quot;In Block : %@&quot;,blkSelf);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意上述代码仍<strong>存在内存泄露</strong>，因为：</p>
<ul>
<li>XXController对象持有Block对象blk</li>
<li>blk对象持有__block变量blkSelf</li>
<li>__block变量blkSelf持有XXController对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__block XXController *blkSelf = self;</span><br><span class="line">self.blk = ^&#123;</span><br><span class="line">    NSLog(@&quot;In Block : %@&quot;,blkSelf);</span><br><span class="line">    blkSelf = nil;//不能省略</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">self.blk();//该block必须执行一次，否则还是内存泄露</span><br></pre></td></tr></table></figure>
<p>在block代码块内，使用完使用完__block变量后将其设为nil，并且该block必须至少执行一次后，<strong>不存在内存泄露</strong>，因为此时：</p>
<ul>
<li>XXController对象持有Block对象blk</li>
<li>blk对象持有__block变量blkSelf(类型为编译器创建的结构体)</li>
<li><strong>block变量blkSelf在执行blk()之后被设置为nil（</strong>block变量结构体的__forwarding指针指向了nil），不再持有XXController对象，打破循环</li>
</ul>
<p>第二种使用__block打破循环的方法，<strong>优点</strong>是：</p>
<ul>
<li>可通过<strong>block变量动态控制持有XXController对象的时间，运行时决定是否将nil或其他变量赋值给</strong>block变量</li>
<li>不能使用<strong>weak的系统中，使用</strong>unsafe_unretained来替代<strong>weak打破循环可能有野指针问题，使用</strong>block则可避免该问题</li>
</ul>
<p>其<strong>缺点</strong>也明显：</p>
<ul>
<li>必须手动保证__block变量最后设置为nil</li>
<li>block必须执行一次，否则__block不为nil循环应用仍存在</li>
</ul>
<p>因此，还是避免使用第二种不常用方式，直接使用<strong>weak打破Block循环引用。<br><strong>方法三</strong>：将在Block内要使用到的对象（一般为self对象），以Block参数的形式传入，Block就不会捕获该对象，而将其作为参数使用，其生命周期系统的栈自动管理，不造成内存泄露。<br>即原来使用</strong>weak的写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">self.blk = ^&#123;</span><br><span class="line">    __strong typeof(self) strongSelf = weakSelf;</span><br><span class="line">    NSLog(@&quot;Use Property:%@&quot;, strongSelf.name);</span><br><span class="line">    //……</span><br><span class="line">&#125;;</span><br><span class="line">self.blk();</span><br></pre></td></tr></table></figure>
<p>改为Block传参写法后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.blk = ^(UIViewController *vc) &#123;</span><br><span class="line">    NSLog(@&quot;Use Property:%@&quot;, vc.name);</span><br><span class="line">&#125;;</span><br><span class="line">self.blk(self);</span><br></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>简化了两行代码，更优雅</li>
<li>更明确的API设计：告诉API使用者，该方法的Block直接使用传进来的参数对象，不会造成循环引用，不用调用者再使用weak避免循环</li>
</ul>
<p>该种用法的详细思路，和clang后的数据结构，可参考<a href="https://link.jianshu.com/?t=https://github.com/ChenYilong/iOSBlog/blob/master/Tips/Heap-Stack%20Dance/Heap-Stack%20Dance.md" target="_blank" rel="noopener">《Heap-Stack Dance》</a>。</p>
<p><a href="https://www.jianshu.com/p/d28a5633b963" target="_blank" rel="noopener">转自 [<a href="https://www.jianshu.com/u/AqMpQK" target="_blank" rel="noopener">kamous</a>]</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/Block技巧与底层解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/Block技巧与底层解析/" itemprop="url">
                  Block技巧与底层解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 11:49:12 / 修改时间：11:51:58" itemprop="dateCreated datePublished" datetime="2018-09-17T11:49:12+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Block/" itemprop="url" rel="index"><span itemprop="name">Block</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li>Block底层解析<ul>
<li>什么是block？<ul>
<li>block编译转换结构</li>
<li>block实际结构</li>
</ul>
</li>
<li>block的类型<ul>
<li>NSConcreteGlobalBlock和NSConcreteStackBlock</li>
<li>NSConcreteMallocBlock</li>
</ul>
</li>
<li>捕捉变量对block结构的影响<ul>
<li>局部变量</li>
<li>全局变量</li>
<li>局部静态变量</li>
<li>__block修饰的变量</li>
<li>self隐式循环引用</li>
</ul>
</li>
<li>不同类型block的复制<ul>
<li>栈block</li>
<li>堆block</li>
<li>全局block</li>
</ul>
</li>
<li>block辅助函数<ul>
<li>__block修饰的基本类型的辅助函数</li>
<li>对象的辅助函数</li>
</ul>
</li>
<li>ARC中block的工作<ul>
<li>block试验</li>
<li>block作为参数传递</li>
<li>block作为返回值</li>
<li>block属性</li>
</ul>
</li>
</ul>
</li>
<li>参考博文</li>
</ul>
<h1 id="Block底层解析"><a href="#Block底层解析" class="headerlink" title="Block底层解析"></a>Block底层解析</h1><p>最近看了一些block的资料，并动手做了一些实践，摘录并添加了一些结论。</p>
<h2 id="什么是block？"><a href="#什么是block？" class="headerlink" title="什么是block？"></a>什么是block？</h2><p>首先，看一个极简的block：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">        ^&#123; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="block编译转换结构"><a href="#block编译转换结构" class="headerlink" title="block编译转换结构"></a>block编译转换结构</h6><p>对其执行<code>clang -rewrite-objc</code>编译转换成C++实现，得到以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">struct __block_impl &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    int Flags;</span><br><span class="line">    int Reserved;</span><br><span class="line">    void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">        (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不难看出其中的<code>__main_block_impl_0</code>就是block的一个C++的实现(最后面的<code>_0</code>代表是main中的第几个block)，也就是说也是一个<code>结构体</code>。<br>其中<code>__block_impl</code>的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct __block_impl &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其结构体成员如下：</p>
<ul>
<li>isa，指向所属类的指针，也就是block的类型</li>
<li>flags，标志变量，在实现block的内部操作时会用到</li>
<li>Reserved，保留变量</li>
<li>FuncPtr，block执行时调用的函数指针<br>可以看出，它包含了isa指针（包含isa指针的皆为对象），也就是说block也是一个<code>对象</code>(runtime里面，对象和类都是用结构体表示)。</li>
</ul>
<p><code>__main_block_desc_0</code>的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure>
<p>其结构成员含义如下：</p>
<ul>
<li>reserved：保留字段</li>
<li>Block_size：block大小(sizeof(struct __main_block_impl_0))</li>
</ul>
<p>以上代码在定义<code>__main_block_desc_0</code>结构体时，同时创建了<code>__main_block_desc_0_DATA</code>，并给它赋值，以供在<code>main</code>函数中对<code>__main_block_impl_0</code>进行初始化。<br><code>__main_block_impl_0</code>定义了显式的构造函数，其函数体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</span><br><span class="line">  impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">  impl.Flags = flags;</span><br><span class="line">  impl.FuncPtr = fp;</span><br><span class="line">  Desc = desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，</p>
<ul>
<li><code>__main_block_impl_0</code>的<code>isa</code>指针指向了<code>_NSConcreteStackBlock</code>，</li>
<li>从<code>main</code>函数中看， <code>__main_block_impl_0</code>的<code>FuncPtr</code>指向了函数<code>__main_block_func_0</code></li>
<li><code>__main_block_impl_0</code>的<code>Desc</code>也指向了定义<code>__main_block_desc_0</code>时就创建的<code>__main_block_desc_0_DATA</code>，其中纪录了block结构体大小等信息。</li>
</ul>
<p>以上就是根据编译转换的结果，对一个简单block的解析，后面会将block操作<code>不同类型的外部变量</code>，对block结构的影响进行相应的说明。</p>
<h6 id="block实际结构"><a href="#block实际结构" class="headerlink" title="block实际结构"></a>block实际结构</h6><p>接下来观察下<code>Block_private.h</code>文件中对block的相关结构体的真实定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* Revised new layout. */</span><br><span class="line">struct Block_descriptor &#123;</span><br><span class="line">    unsigned long int reserved;</span><br><span class="line">    unsigned long int size;</span><br><span class="line">    void (*copy)(void *dst, void *src);</span><br><span class="line">    void (*dispose)(void *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct Block_layout &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    int flags;</span><br><span class="line">    int reserved;</span><br><span class="line">    void (*invoke)(void *, ...);</span><br><span class="line">    struct Block_descriptor *descriptor;</span><br><span class="line">    /* Imported variables. */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有了上文对编译转换的分析，这里只针对略微不同的成员进行分析：</p>
<ul>
<li><p>invoke，同上文的FuncPtr，block执行时调用的函数指针，block定义时内部的执行代码都在这个函数中</p>
</li>
<li><p>Block_descriptor，block的详细描述</p>
<p>​</p>
<ul>
<li>copy/dispose，辅助拷贝/销毁函数，处理block范围外的变量时使用</li>
</ul>
</li>
</ul>
<p>总体来说，block就是一个里面存储了指向<code>函数体中包含定义block时的代码块</code>的函数指针，以及<code>block外部上下文</code>变量等信息的结构体。</p>
<h2 id="block的类型"><a href="#block的类型" class="headerlink" title="block的类型"></a>block的类型</h2><p>block的常见类型有3种：</p>
<ul>
<li>_NSConcreteGlobalBlock（全局）</li>
<li>_NSConcreteStackBlock（栈）</li>
<li>_NSConcreteMallocBlock（堆）</li>
</ul>
<p>附上APUE的进程虚拟内存段分布图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/608238-2393520e3fec4271.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/707" alt="img"></p>
<p>进程虚拟内存空间分布</p>
<p>其中前2种在<code>Block.h</code>种声明，后1种在<code>Block_private.h</code>中声明，所以最后1种基本不会在源码中出现。<br>由于无法直接创建<code>_NSConcreteMallocBlock</code>类型的block，所以这里只对前面2种进行手动创建分析，最后1种通过源代码分析。</p>
<h6 id="NSConcreteGlobalBlock和NSConcreteStackBlock"><a href="#NSConcreteGlobalBlock和NSConcreteStackBlock" class="headerlink" title="NSConcreteGlobalBlock和NSConcreteStackBlock"></a>NSConcreteGlobalBlock和NSConcreteStackBlock</h6><p>首先，根据前面两种类型，编写以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void (^globalBlock)() = ^&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        void (^stackBlock1)() = ^&#123;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对其进行编译转换后得到以下缩略代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// globalBlock</span><br><span class="line">struct __globalBlock_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __globalBlock_block_desc_0* Desc;</span><br><span class="line">  __globalBlock_block_impl_0(void *fp, struct __globalBlock_block_desc_0 *desc, int flags=0) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteGlobalBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// stackBlock</span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">        void (*stackBlock)() = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出<code>globalBlock</code>的isa指向了<code>_NSConcreteGlobalBlock</code>，即在全局区域创建，编译时具体的代码就已经确定在上图中的代码段中了，block变量存储在全局数据存储区；<code>stackBlock</code>的isa指向了<code>_NSConcreteStackBlock</code>，即在栈区创建。</p>
<h6 id="NSConcreteMallocBlock"><a href="#NSConcreteMallocBlock" class="headerlink" title="NSConcreteMallocBlock"></a>NSConcreteMallocBlock</h6><p>接下来是在堆中的block，堆中的block无法直接创建，其需要由<code>_NSConcreteStackBlock</code>类型的block拷贝而来(也就是说<code>block需要执行copy之后才能存放到堆中</code>)。由于block的拷贝最终都会调用<code>_Block_copy_internal</code>函数，所以观察这个函数就可以知道堆中block是如何被创建的了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static void *_Block_copy_internal(const void *arg, const int flags) &#123;</span><br><span class="line">    struct Block_layout *aBlock;</span><br><span class="line">    ...</span><br><span class="line">    aBlock = (struct Block_layout *)arg;</span><br><span class="line">    ...</span><br><span class="line">    // Its a stack block.  Make a copy.</span><br><span class="line">    if (!isGC) &#123;</span><br><span class="line">        // 申请block的堆内存</span><br><span class="line">        struct Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size);</span><br><span class="line">        if (!result) return (void *)0;</span><br><span class="line">        // 拷贝栈中block到刚申请的堆内存中</span><br><span class="line">        memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first</span><br><span class="line">        // reset refcount</span><br><span class="line">        result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK);    // XXX not needed</span><br><span class="line">        result-&gt;flags |= BLOCK_NEEDS_FREE | 1;</span><br><span class="line">        // 改变isa指向_NSConcreteMallocBlock，即堆block类型</span><br><span class="line">        result-&gt;isa = _NSConcreteMallocBlock;</span><br><span class="line">        if (result-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) &#123;</span><br><span class="line">            //printf(&quot;calling block copy helper %p(%p, %p)...\n&quot;, aBlock-&gt;descriptor-&gt;copy, result, aBlock);</span><br><span class="line">            (*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上代码以及注释可以很清楚的看出，函数通过<code>memmove</code>将栈中的block的内容拷贝到了堆中，并使isa指向了<code>_NSConcreteMallocBlock</code>。<br>block主要的一些学问就出在栈中block向堆中block的转移过程中了。</p>
<h2 id="捕捉变量对block结构的影响"><a href="#捕捉变量对block结构的影响" class="headerlink" title="捕捉变量对block结构的影响"></a>捕捉变量对block结构的影响</h2><p>接下来会编译转换捕捉不同变量类型的block，以对比它们的区别。</p>
<h6 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h6><p>前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    ^&#123;a;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct __Person__test_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __Person__test_block_desc_0* Desc;</span><br><span class="line">  int a;</span><br><span class="line">  // a(_a)是构造函数的参数列表初始化形式，相当于a = _a。从_I_Person_test看，传入的就是a</span><br><span class="line">  __Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, int _a, int flags=0) : a(_a) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) &#123;</span><br><span class="line">  int a = __cself-&gt;a; // bound by copy</span><br><span class="line">a;&#125;</span><br><span class="line"></span><br><span class="line">static struct __Person__test_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __Person__test_block_desc_0_DATA = &#123; 0, sizeof(struct __Person__test_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line">static void _I_Person_test(Person * self, SEL _cmd) &#123;</span><br><span class="line">    int a;</span><br><span class="line">    (void (*)())&amp;__Person__test_block_impl_0((void *)__Person__test_block_func_0, &amp;__Person__test_block_desc_0_DATA, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，block相对于文章开头增加了一个int类型的成员变量，他就是用来存储外部变量a的。可以看出，这次拷贝只是一次<code>值传递</code>。并且当我们想在block中进行以下操作时，将会发生错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^&#123;a = 10;&#125;;</span><br></pre></td></tr></table></figure>
<p>编译器会提示</p>
<p><img src="http://upload-images.jianshu.io/upload_images/608238-712f1c798d842cbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/299" alt="img"></p>
<p>错误提示</p>
<p>。因为_I_Person_test函数中的a和<strong>Person</strong>test_block_func_0函数中的a并没有在同一个作用域，所以在block对a进行赋值是没有意义的，所以编译器给出了错误。我们可以通过地址传递来消除以上错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">    int a = 0;</span><br><span class="line">    // 利用指针p存储a的地址</span><br><span class="line">    int *p = &amp;a;</span><br><span class="line"></span><br><span class="line">    ^&#123;</span><br><span class="line">        // 通过a的地址设置a的值</span><br><span class="line">        *p = 10;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是变量a的生命周期是和方法test的栈相关联的，当test运行结束，栈随之销毁，那么变量a就会被销毁，p也就成为了野指针。如果block是作为参数或者返回值，这些类型都是跨栈的，也就是说再次调用会造成野指针错误。</p>
<h6 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h6><p>前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 全局静态</span><br><span class="line">static int a;</span><br><span class="line">// 全局</span><br><span class="line">int b;</span><br><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ^&#123;</span><br><span class="line">        a = 10;</span><br><span class="line">        b = 10;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static int a;</span><br><span class="line">int b;</span><br><span class="line"></span><br><span class="line">struct __Person__test_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __Person__test_block_desc_0* Desc;</span><br><span class="line">  __Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, int flags=0) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">        a = 10;</span><br><span class="line">        b = 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">static struct __Person__test_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __Person__test_block_desc_0_DATA = &#123; 0, sizeof(struct __Person__test_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line">static void _I_Person_test(Person * self, SEL _cmd) &#123;</span><br><span class="line"></span><br><span class="line">    (void (*)())&amp;__Person__test_block_impl_0((void *)__Person__test_block_func_0, &amp;__Person__test_block_desc_0_DATA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，因为全局变量都是在<code>静态数据存储区</code>，在程序结束前不会被销毁，所以block直接访问了对应的变量，而没有在<strong>Person</strong>test_block_impl_0结构体中给变量预留位置。</p>
<h6 id="局部静态变量"><a href="#局部静态变量" class="headerlink" title="局部静态变量"></a>局部静态变量</h6><p>前</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">    static int a;</span><br><span class="line">    ^&#123;</span><br><span class="line">        a = 10;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct __Person__test_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __Person__test_block_desc_0* Desc;</span><br><span class="line">  int *a;</span><br><span class="line">  __Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, int *_a, int flags=0) : a(_a) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) &#123;</span><br><span class="line">  int *a = __cself-&gt;a; // bound by copy</span><br><span class="line">        // 这里通过局部静态变量a的地址来对其进行修改</span><br><span class="line">        (*a) = 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">static struct __Person__test_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __Person__test_block_desc_0_DATA = &#123; 0, sizeof(struct __Person__test_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line">static void _I_Person_test(Person * self, SEL _cmd) &#123;</span><br><span class="line">    static int a;</span><br><span class="line">    // 传入a的地址</span><br><span class="line">    (void (*)())&amp;__Person__test_block_impl_0((void *)__Person__test_block_func_0, &amp;__Person__test_block_desc_0_DATA, &amp;a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意一点的是静态局部变量是存储在静态数据存储区域的，也就是和程序拥有一样的<code>生命周期</code>，也就是说在程序运行时，都能够保证block访问到一个有效的变量。但是其<code>作用范围</code>还是局限于定义它的函数中，所以只能在block通过静态局部变量的<code>地址</code>来进行访问。<br>关于变量的存储我原来的这篇博客有提及：<a href="https://link.jianshu.com/?t=http://blog.csdn.net/triplecc/article/details/24808417" target="_blank" rel="noopener">c语言臆想–全局—局部变量</a></p>
<h6 id="block修饰的变量"><a href="#block修饰的变量" class="headerlink" title="__block修饰的变量"></a>__block修饰的变量</h6><p>前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">   __block int a;</span><br><span class="line">    ^&#123;</span><br><span class="line">        a = 10;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_a_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_a_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __Person__test_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __Person__test_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_a_0 *a; // by ref</span><br><span class="line">  __Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_a_0 *a = __cself-&gt;a; // bound by ref</span><br><span class="line">        // 注意，这里的_forwarding用来保证操作的始终是堆中的拷贝a，而不是栈中的a</span><br><span class="line">        (a-&gt;__forwarding-&gt;a) = 10;</span><br><span class="line">    &#125;</span><br><span class="line">static void __Person__test_block_copy_0(struct __Person__test_block_impl_0*dst, struct __Person__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</span><br><span class="line"></span><br><span class="line">static void __Person__test_block_dispose_0(struct __Person__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</span><br><span class="line"></span><br><span class="line">static struct __Person__test_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __Person__test_block_impl_0*, struct __Person__test_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __Person__test_block_impl_0*);</span><br><span class="line">&#125; __Person__test_block_desc_0_DATA = &#123; 0, sizeof(struct __Person__test_block_impl_0), __Person__test_block_copy_0, __Person__test_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line">static void _I_Person_test(Person * self, SEL _cmd) &#123;</span><br><span class="line">    // __block将a包装成了一个对象</span><br><span class="line">   __attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(void*)0,(__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0)&#125;;</span><br><span class="line">;</span><br><span class="line">    (void (*)())&amp;__Person__test_block_impl_0((void *)__Person__test_block_func_0, &amp;__Person__test_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，对比上面的结果，明显多了<code>__Block_byref_a_0</code>结构体，这个结构体中含有<code>isa</code>指针，所以也是一个对象，它是用来包装局部变量a的。当block被copy到堆中时，<code>__Person__test_block_impl_0</code>的拷贝辅助函数<code>__Person__test_block_copy_0</code>会将<code>__Block_byref_a_0</code>拷贝至堆中，所以即使局部变量所在堆被销毁，block依然能对堆中的局部变量进行操作。其中<code>__Block_byref_a_0</code>成员指针<code>__forwarding</code>用来指向它在堆中的拷贝，其依据源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void _Block_byref_assign_copy(void *dest, const void *arg, const int flags) &#123;</span><br><span class="line">    struct Block_byref **destp = (struct Block_byref **)dest;</span><br><span class="line">    struct Block_byref *src = (struct Block_byref *)arg;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    // 堆中拷贝的forwarding指向它自己</span><br><span class="line">    copy-&gt;forwarding = copy; // patch heap copy to point to itself (skip write-barrier)</span><br><span class="line">    // 栈中的forwarding指向堆中的拷贝</span><br><span class="line">    src-&gt;forwarding = copy;  // patch stack to point to heap copy</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做是为了保证操作的值始终是堆中的拷贝，而不是栈中的值。（处理在局部变量所在栈还没销毁，就调用block来改变局部变量值的情况，如果没有__forwarding指针，则修改无效）<br>至于block如何实现对局部变量的拷贝，下面会详细说明。</p>
<h6 id="self隐式循环引用"><a href="#self隐式循环引用" class="headerlink" title="self隐式循环引用"></a>self隐式循环引用</h6><p>前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@implementation Person</span><br><span class="line">&#123;</span><br><span class="line">    int _a;</span><br><span class="line">    void (^_block)();</span><br><span class="line">&#125;</span><br><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">  void (^_block)() = ^&#123;</span><br><span class="line">        _a = 10;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">struct __Person__test_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __Person__test_block_desc_0* Desc;</span><br><span class="line">  // 可以看到，block强引用了self</span><br><span class="line">  Person *self;</span><br><span class="line">  __Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, Person *_self, int flags=0) : self(_self) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) &#123;</span><br><span class="line">  Person *self = __cself-&gt;self; // bound by copy</span><br><span class="line"></span><br><span class="line">        (*(int *)((char *)self + OBJC_IVAR_$_Person$_a)) = 10;</span><br><span class="line">    &#125;</span><br><span class="line">static void __Person__test_block_copy_0(struct __Person__test_block_impl_0*dst, struct __Person__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;self, (void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static void __Person__test_block_dispose_0(struct __Person__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static struct __Person__test_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __Person__test_block_impl_0*, struct __Person__test_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __Person__test_block_impl_0*);</span><br><span class="line">&#125; __Person__test_block_desc_0_DATA = &#123; 0, sizeof(struct __Person__test_block_impl_0), __Person__test_block_copy_0, __Person__test_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line">static void _I_Person_test(Person * self, SEL _cmd) &#123;</span><br><span class="line">  void (*_block)() = (void (*)())&amp;__Person__test_block_impl_0((void *)__Person__test_block_func_0, &amp;__Person__test_block_desc_0_DATA, self, 570425344);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在编译转换前，将<code>_a</code>改成<code>self.a</code>，能很明显地看出是产生了循环引用(self强引用block，block强引用self)。那么使用<code>_a</code>呢？经过编译转换后，依然可以在<code>__Person__test_block_impl_0</code>看见<code>self</code>的身影。且在函数<code>_I_Person_test</code>中，传入的参数也是<code>self</code>。通过以下语句，可以看出，不管是用什么形式访问实例变量，最终都会转换成<code>self+变量内存偏移的形式</code>。所以在上面例子中使用<code>_a</code>也会造成循环引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) &#123;</span><br><span class="line">  Person *self = __cself-&gt;self; // bound by copy</span><br><span class="line">        // self＋实例变量a的偏移值</span><br><span class="line">        (*(int *)((char *)self + OBJC_IVAR_$_Person$_a)) = 10;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="不同类型block的复制"><a href="#不同类型block的复制" class="headerlink" title="不同类型block的复制"></a>不同类型block的复制</h2><p><code>block</code>的复制代码在<code>_Block_copy_internal</code>函数中。</p>
<h6 id="栈block"><a href="#栈block" class="headerlink" title="栈block"></a>栈block</h6><p>从以下代码可以看出，栈block的复制不仅仅复制了其内容，还添加了一些额外的东西</p>
<ul>
<li>1、往flags中并入了<code>BLOCK_NEEDS_FREE</code>（这个标志表明block需要释放，在<code>release</code>以及<code>再次拷贝</code>时会用到）</li>
<li>2、如果有辅助copy函数（<code>BLOCK_HAS_COPY_DISPOSE</code>），那么就调用（这个辅助copy函数是用来<code>拷贝block捕获的变量</code>的）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">struct Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size);</span><br><span class="line">      if (!result) return (void *)0;</span><br><span class="line">      memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first</span><br><span class="line">      // reset refcount</span><br><span class="line">      result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK);    // XXX not needed</span><br><span class="line">      result-&gt;flags |= BLOCK_NEEDS_FREE | 1;</span><br><span class="line">      result-&gt;isa = _NSConcreteMallocBlock;</span><br><span class="line">      if (result-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) &#123;</span><br><span class="line">          //printf(&quot;calling block copy helper %p(%p, %p)...\n&quot;, aBlock-&gt;descriptor-&gt;copy, result, aBlock);</span><br><span class="line">          (*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup</span><br><span class="line">      &#125;</span><br><span class="line">      return result;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h6 id="堆block"><a href="#堆block" class="headerlink" title="堆block"></a>堆block</h6><p>从以下代码看出，如果block的flags中有<code>BLOCK_NEEDS_FREE</code>标志（block从栈中拷贝到堆时添加的标志），就执行<code>latching_incr_int</code>操作，其功能就是让block的引用计数加1。所以堆中block的拷贝只是单纯地改变了引用计数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) &#123;</span><br><span class="line">      // latches on high</span><br><span class="line">      latching_incr_int(&amp;aBlock-&gt;flags);</span><br><span class="line">      return aBlock;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h6 id="全局block"><a href="#全局block" class="headerlink" title="全局block"></a>全局block</h6><p>从以下代码看出，对于全局block，函数没有做任何操作，直接返回了传入的block</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">else if (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) &#123;</span><br><span class="line">      return aBlock;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="block辅助函数"><a href="#block辅助函数" class="headerlink" title="block辅助函数"></a>block辅助函数</h2><p>上文提及到了block辅助copy与dispose处理函数，这里分析下这两个函数的内部实现。在捕获变量为<code>__block</code>修饰的<code>基本类型</code>，或者为<code>对象</code>时，block才会有这两个辅助函数。<br>block<code>捕捉变量</code>拷贝函数为<code>_Block_object_assign</code>。在调用复制block的函数_Block_copy_internal时，会根据block有无辅助函数来对<code>捕捉变量</code>拷贝函数<code>_Block_object_assign</code>进行调用。而在<code>_Block_object_assign</code>函数中，也会判断<code>捕捉变量</code>包装而成的对象(Block_byref结构体)是否有辅助函数，来进行调用。</p>
<h6 id="block修饰的基本类型的辅助函数"><a href="#block修饰的基本类型的辅助函数" class="headerlink" title="__block修饰的基本类型的辅助函数"></a><code>__block</code>修饰的基本类型的辅助函数</h6><p>编写以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^Block)();</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        __block int a;</span><br><span class="line">        Block block = ^ &#123;</span><br><span class="line">            a;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换成C++代码后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">typedef void(*Block)();</span><br><span class="line">// __block int a</span><br><span class="line">struct __Block_byref_a_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_a_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// block</span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_a_0 *a; // by ref</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// block函数体</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_a_0 *a = __cself-&gt;a; // bound by ref</span><br><span class="line"></span><br><span class="line">            (a-&gt;__forwarding-&gt;a);</span><br><span class="line">        &#125;</span><br><span class="line">// 辅助copy函数</span><br><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</span><br><span class="line"></span><br><span class="line">// 辅助dispose函数</span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">        // 这里创建了，并将a的flags设置为0</span><br><span class="line">        __attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(void*)0,(__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0)&#125;;</span><br><span class="line">;</span><br><span class="line">        Block block = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码中，被<code>__block</code>修饰的a变量变为了<code>__Block_byref_a_0</code>类型，根据这个格式，从源码中查看得到相似的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">struct Block_byref &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    struct Block_byref *forwarding;</span><br><span class="line">    int flags; /* refcount; */</span><br><span class="line">    int size;</span><br><span class="line">    void (*byref_keep)(struct Block_byref *dst, struct Block_byref *src);</span><br><span class="line">    void (*byref_destroy)(struct Block_byref *);</span><br><span class="line">    /* long shared[0]; */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 做下对比</span><br><span class="line">struct __Block_byref_a_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_a_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// flags/_flags类型</span><br><span class="line">enum &#123;</span><br><span class="line">        /* See function implementation for a more complete description of these fields and combinations */</span><br><span class="line">        // 是一个对象</span><br><span class="line">        BLOCK_FIELD_IS_OBJECT   =  3,  /* id, NSObject, __attribute__((NSObject)), block, ... */</span><br><span class="line">        // 是一个block</span><br><span class="line">        BLOCK_FIELD_IS_BLOCK    =  7,  /* a block variable */</span><br><span class="line">        // 被__block修饰的变量</span><br><span class="line">        BLOCK_FIELD_IS_BYREF    =  8,  /* the on stack structure holding the __block variable */</span><br><span class="line">        // 被__weak修饰的变量，只能被辅助copy函数使用</span><br><span class="line">        BLOCK_FIELD_IS_WEAK     = 16,  /* declared __weak, only used in byref copy helpers */</span><br><span class="line">        // block辅助函数调用（告诉内部实现不要进行retain或者copy）</span><br><span class="line">        BLOCK_BYREF_CALLER      = 128  /* called from __block (byref) copy/dispose support routines. */</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>可以看出，<code>__block</code>将原来的基本类型包装成了<code>对象</code>。因为以上两个结构体的前4个成员的类型都是一样的，内存空间排列一致，所以可以进行以下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 转换成C++代码</span><br><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</span><br><span class="line"></span><br><span class="line">// _Block_object_assign源码</span><br><span class="line">void _Block_object_assign(void *destAddr, const void *object, const int flags) &#123;</span><br><span class="line">...</span><br><span class="line">    else if ((flags &amp; BLOCK_FIELD_IS_BYREF) == BLOCK_FIELD_IS_BYREF)  &#123;</span><br><span class="line">        // copying a __block reference from the stack Block to the heap</span><br><span class="line">        // flags will indicate if it holds a __weak reference and needs a special isa</span><br><span class="line">        _Block_byref_assign_copy(destAddr, object, flags);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// _Block_byref_assign_copy源码</span><br><span class="line">static void _Block_byref_assign_copy(void *dest, const void *arg, const int flags) &#123;</span><br><span class="line">    // 这里因为前面4个成员的内存分布一样，所以直接转换后，使用Block_byref的成员变量名，能访问到__Block_byref_a_0的前面4个成员</span><br><span class="line">    struct Block_byref **destp = (struct Block_byref **)dest;</span><br><span class="line">    struct Block_byref *src = (struct Block_byref *)arg;</span><br><span class="line">...</span><br><span class="line">    else if ((src-&gt;forwarding-&gt;flags &amp; BLOCK_REFCOUNT_MASK) == 0) &#123;</span><br><span class="line">        // 从main函数对__Block_byref_a_0的初始化，可以看到初始化时将flags赋值为0</span><br><span class="line">        // 这里表示第一次拷贝，会进行复制操作，并修改原来flags的值</span><br><span class="line">        // static int _Byref_flag_initial_value = BLOCK_NEEDS_FREE | 2;</span><br><span class="line">        // 可以看出，复制后，会并入BLOCK_NEEDS_FREE，后面的2是block的初始引用计数</span><br><span class="line">        ...</span><br><span class="line">        copy-&gt;flags = src-&gt;flags | _Byref_flag_initial_value;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    // 已经拷贝到堆了，只增加引用计数</span><br><span class="line">    else if ((src-&gt;forwarding-&gt;flags &amp; BLOCK_NEEDS_FREE) == BLOCK_NEEDS_FREE) &#123;</span><br><span class="line">        latching_incr_int(&amp;src-&gt;forwarding-&gt;flags);</span><br><span class="line">    &#125;</span><br><span class="line">    // 普通的赋值，里面最底层就*destptr = value;这句表达式</span><br><span class="line">    _Block_assign(src-&gt;forwarding, (void **)destp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要操作都在代码注释中了，总体来说，<code>__block</code>修饰的基本类型会被包装为对象，并且只在最初block拷贝时复制一次，后面的拷贝只会增加这个捕获变量的引用计数。</p>
<h6 id="对象的辅助函数"><a href="#对象的辅助函数" class="headerlink" title="对象的辅助函数"></a>对象的辅助函数</h6><ul>
<li>没有<code>__block</code>修饰</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^Block)();</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSObject *a = [[NSObject alloc] init];</span><br><span class="line">        Block block = ^ &#123;</span><br><span class="line">            a;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，在没有<code>__block</code>修饰时，对象编译转换的结果如下，删除了一些变化不大的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  NSObject *a = __cself-&gt;a; // bound by copy</span><br><span class="line">            a;</span><br><span class="line">        &#125;</span><br><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;a, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0),</span><br></pre></td></tr></table></figure>
<p>对象在没有<code>__block</code>修饰时，并没有产生<code>__Block_byref_a_0</code>结构体，只是将标志位修改为<code>BLOCK_FIELD_IS_OBJECT</code>。而在<code>_Block_object_assign</code>中对应的判断分支代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">else if ((flags &amp; BLOCK_FIELD_IS_OBJECT) == BLOCK_FIELD_IS_OBJECT) &#123;</span><br><span class="line">    _Block_retain_object(object);</span><br><span class="line">    _Block_assign((void *)object, destAddr);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看到，block复制时，会retain捕捉对象，以增加其引用计数。</p>
<ul>
<li>有<code>__block</code>修饰</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^Block)();</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        __block NSObject *a = [[NSObject alloc] init];</span><br><span class="line">        Block block = ^ &#123;</span><br><span class="line">            a;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，编译转换的部分结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_a_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_a_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> void (*__Block_byref_id_object_copy)(void*, void*);</span><br><span class="line"> void (*__Block_byref_id_object_dispose)(void*);</span><br><span class="line"> NSObject *a;</span><br><span class="line">&#125;;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(void*)0,(__Block_byref_a_0 *)&amp;a, 33554432, sizeof(__Block_byref_a_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131,....&#125;;</span><br><span class="line">Block block = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 以下的40表示__Block_byref_a_0对象a的位移（4个指针(32字节)＋2个int变量(8字节)＝40字节）</span><br><span class="line">static void __Block_byref_id_object_copy_131(void *dst, void *src) &#123;</span><br><span class="line"> _Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);</span><br><span class="line">&#125;</span><br><span class="line">static void __Block_byref_id_object_dispose_131(void *src) &#123;</span><br><span class="line"> _Block_object_dispose(*(void * *) ((char*)src + 40), 131);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，对于对象，<code>__Block_byref_a_0</code>另外增加了两个辅助函数<code>__Block_byref_id_object_copy</code>、<code>__Block_byref_id_object_dispose</code>,以实现对对象内存的管理。其中两者的最后一个参数<code>131</code>表示<code>BLOCK_BYREF_CALLER</code>|<code>BLOCK_FIELD_IS_OBJECT</code>，BLOCK_BYREF_CALLER表示在内部实现中不对a对象进行retain或copy；以下为相关源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if ((flags &amp; BLOCK_BYREF_CALLER) == BLOCK_BYREF_CALLER) &#123;</span><br><span class="line">    ...</span><br><span class="line">    else &#123;</span><br><span class="line">        // do *not* retain or *copy* __block variables whatever they are</span><br><span class="line">        _Block_assign((void *)object, destAddr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_Block_byref_assign_copy</code>函数的以下代码会对上面的辅助函数（__Block_byref_id_object_copy_131）进行调用；<code>570425344</code>表示<code>BLOCK_HAS_COPY_DISPOSE</code>|<code>BLOCK_HAS_DESCRIPTOR</code>，所以会执行以下相关源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (src-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) &#123;</span><br><span class="line">    // Trust copy helper to copy everything of interest</span><br><span class="line">    // If more than one field shows up in a byref block this is wrong XXX</span><br><span class="line">    copy-&gt;byref_keep = src-&gt;byref_keep;</span><br><span class="line">    copy-&gt;byref_destroy = src-&gt;byref_destroy;</span><br><span class="line">    (*src-&gt;byref_keep)(copy, src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ARC中block的工作"><a href="#ARC中block的工作" class="headerlink" title="ARC中block的工作"></a>ARC中block的工作</h2><p><img src="http://upload-images.jianshu.io/upload_images/608238-0fbaf756460d459f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>苹果说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_NSConcreteStackBlock</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_NSConcreteMallocBlock</span><br></pre></td></tr></table></figure>
<h6 id="block试验"><a href="#block试验" class="headerlink" title="block试验"></a>block试验</h6><p>下面对block做点实验：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        int i = 10;</span><br><span class="line">        void (^block)() = ^&#123;i;&#125;;</span><br><span class="line"></span><br><span class="line">        __weak void (^weakBlock)() = ^&#123;i;&#125;;</span><br><span class="line"></span><br><span class="line">        void (^stackBlock)() = ^&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        // ARC情况下</span><br><span class="line"></span><br><span class="line">        // 创建时，都会在栈中</span><br><span class="line">        // &lt;__NSStackBlock__: 0x7fff5fbff730&gt;</span><br><span class="line">        NSLog(@&quot;%@&quot;, ^&#123;i;&#125;);</span><br><span class="line"></span><br><span class="line">        // 因为block为strong类型，且捕获了外部变量，所以赋值时，自动进行了copy</span><br><span class="line">        // &lt;__NSMallocBlock__: 0x100206920&gt;</span><br><span class="line">        NSLog(@&quot;%@&quot;, block);</span><br><span class="line"></span><br><span class="line">        // 如果是weak类型的block，依然不会自动进行copy</span><br><span class="line">        // &lt;__NSStackBlock__: 0x7fff5fbff728&gt;</span><br><span class="line">        NSLog(@&quot;%@&quot;, weakBlock);</span><br><span class="line"></span><br><span class="line">        // 如果block是strong类型，并且没有捕获外部变量，那么就会转换成__NSGlobalBlock__</span><br><span class="line">        // &lt;__NSGlobalBlock__: 0x100001110&gt;</span><br><span class="line">        NSLog(@&quot;%@&quot;, stackBlock);</span><br><span class="line"></span><br><span class="line">        // 在非ARC情况下，产生以下输出</span><br><span class="line">        // &lt;__NSStackBlock__: 0x7fff5fbff6d0&gt;</span><br><span class="line">        // &lt;__NSStackBlock__: 0x7fff5fbff730&gt;</span><br><span class="line">        // &lt;__NSStackBlock__: 0x7fff5fbff700&gt;</span><br><span class="line">        // &lt;__NSGlobalBlock__: 0x1000010d0&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，ARC对<code>类型为strong</code>且<code>捕获了外部变量</code>的block进行了copy。并且当block<code>类型为strong</code>，但是创建时<code>没有捕获外部变量</code>，block最终会变成<code>__NSGlobalBlock__</code>类型（这里可能因为block中的代码没有捕获外部变量，所以不需要在栈中开辟变量，也就是说，在<code>编译</code>时，这个block的<code>所有内容已经在代码段中生成了</code>，所以就把block的类型转换为全局类型）</p>
<h6 id="block作为参数传递"><a href="#block作为参数传递" class="headerlink" title="block作为参数传递"></a>block作为参数传递</h6><p>再来看下使用在栈中的block需要注意的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *arrayM;</span><br><span class="line">void myBlock()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 5;</span><br><span class="line">    Block block = ^ &#123;</span><br><span class="line">        NSLog(@&quot;%d&quot;, a);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    [arrayM addObject:block];</span><br><span class="line">    NSLog(@&quot;%@&quot;, block);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        arrayM = @[].mutableCopy;</span><br><span class="line"></span><br><span class="line">        myBlock();</span><br><span class="line"></span><br><span class="line">        Block block = [arrayM firstObject];</span><br><span class="line">        // 非ARC这里崩溃</span><br><span class="line">        block();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">// ARC情况下输出</span><br><span class="line">// &lt;__NSMallocBlock__: 0x100214480&gt;</span><br><span class="line"></span><br><span class="line">// 非ARC情况下输出</span><br><span class="line">// &lt;__NSStackBlock__: 0x7fff5fbff738&gt;</span><br><span class="line">// 崩溃，野指针错误</span><br></pre></td></tr></table></figure>
<p>可以看到，ARC情况下因为自动执行了copy，所以返回类型为<code>__NSMallocBlock__</code>，在函数结束后依然可以访问；而非ARC情况下，需要我们手动调用<code>[block copy]</code>来将block拷贝到堆中，否则因为栈中的block生命周期和函数中的栈生命周期关联，当函数退出后，相应的堆被销毁，block也就不存在了。<br>如果把block的以下代码删除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%d&quot;, a);</span><br></pre></td></tr></table></figure>
<p>那么block就会变成全局类型，在main中访问也不会出崩溃。</p>
<h6 id="block作为返回值"><a href="#block作为返回值" class="headerlink" title="block作为返回值"></a>block作为返回值</h6><p>在非ARC情况下，如果返回值是block，则一般这样操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return [[block copy] autorelease];</span><br></pre></td></tr></table></figure>
<p>对于外部要使用的block，更趋向于把它拷贝到堆中，使其脱离栈生命周期的约束。</p>
<h6 id="block属性"><a href="#block属性" class="headerlink" title="block属性"></a>block属性</h6><p>这里还有一点关于block类型的ARC属性。上文也说明了，ARC会自动帮<code>strong类型</code>且<code>捕获外部变量</code>的block进行copy，所以在定义block类型的属性时也可以使用strong，不一定使用copy。也就是以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/** 假如有栈block赋给以下两个属性 **/</span><br><span class="line"></span><br><span class="line">// 这里因为ARC，当栈block中会捕获外部变量时，这个block会被copy进堆中</span><br><span class="line">// 如果没有捕获外部变量，这个block会变为全局类型</span><br><span class="line">// 不管怎么样，它都脱离了栈生命周期的约束</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic) Block *strongBlock;</span><br><span class="line"></span><br><span class="line">// 这里都会被copy进堆中</span><br><span class="line">@property (copy, nonatomic) Block *copyBlock;</span><br></pre></td></tr></table></figure>
<h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p><a href="https://link.jianshu.com/?t=http://blog.devtang.com/blog/2013/07/28/a-look-inside-blocks/" target="_blank" rel="noopener">谈Objective-C Block的实现</a><br><a href="https://link.jianshu.com/?t=http://blog.csdn.net/jasonblog/article/details/7756763" target="_blank" rel="noopener">iOS中block实现的探究</a><br><a href="https://link.jianshu.com/?t=http://www.galloway.me.uk/2013/05/a-look-inside-blocks-episode-3-block-copy/" target="_blank" rel="noopener">A look inside blocks: Episode 3</a><br><a href="https://link.jianshu.com/?t=http://llvm.org/svn/llvm-project/compiler-rt/trunk/lib/BlocksRuntime/runtime.c" target="_blank" rel="noopener">runtime.c</a><br><a href="https://link.jianshu.com/?t=http://llvm.org/svn/llvm-project/compiler-rt/trunk/lib/BlocksRuntime/Block_private.h" target="_blank" rel="noopener">Block_private.h</a></p>
<h2 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h2><p><a href="https://link.jianshu.com/?t=http://clang.llvm.org/docs/Block-ABI-Apple.html" target="_blank" rel="noopener">llvm对于Block的编译规则</a><br><a href="https://link.jianshu.com/?t=https://github.com/EmbeddedSources/BlockRuntime" target="_blank" rel="noopener">ESBlockRuntime</a></p>
<p><a href="https://www.jianshu.com/p/51d04b7639f1" target="_blank" rel="noopener">转自 [<a href="https://www.jianshu.com/u/97e39e95c2cc" target="_blank" rel="noopener">tripleCC</a>]</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/14/NSString的内存问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/14/NSString的内存问题/" itemprop="url">
                  NSString的内存问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-14 14:43:42 / 修改时间：14:50:14" itemprop="dateCreated datePublished" datetime="2018-09-14T14:43:42+08:00">2018-09-14</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/内存管理/" itemprop="url" rel="index"><span itemprop="name">内存管理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>NSString 在 OC 的内存管理策略中是一个特殊的存在，因为其在编译和运行中做了一些优化处理，不同于普通对象的存在，看看下面代码打印情况（此代码测试环境为MRC，可以在ARC工程下，设置当前测试代码文件为手动内存管理，找到路径Build Phases—-&gt;Compile Sources—-&gt;XXX.m，将XXX.m的Compiler Flags设置为”-fno-objc-arc”.）：</p>
<p>//宏定义</p>
<p>#define XWLog(_var) ({ NSString *name = @#_var; NSLog(@”变量名=%@，类型=%@， 地址=%p，值=%@，引用计数=%d”, name, [_var class], _var, _var, (int)[_var retainCount]); })<br>//测试代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NSString *a = @&quot;string&quot;;</span><br><span class="line"></span><br><span class="line">NSString *b = [[NSString alloc]init];</span><br><span class="line"></span><br><span class="line">NSString *c = [[NSString alloc]initWithString:@&quot;string&quot;];</span><br><span class="line"></span><br><span class="line">NSString *d = [[NSString alloc]initWithFormat:@&quot;string&quot;];</span><br><span class="line"></span><br><span class="line">NSString *e = [NSString stringWithFormat:@&quot;string&quot;];</span><br><span class="line"></span><br><span class="line">NSString *f = [NSString stringWithFormat:@&quot;123456789&quot;];</span><br><span class="line"></span><br><span class="line">NSString *g = [NSString stringWithFormat:@&quot;1234567890&quot;];</span><br><span class="line"></span><br><span class="line">XWLog(a); XWLog(b); XWLog(c); XWLog(d); XWLog(e); XWLog(f); XWLog(g);</span><br></pre></td></tr></table></figure>
<p>//打印结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">变量名=a，类型=__NSCFConstantString， 地址=0x1015f3120，值=string，引用计数=-1</span><br><span class="line"></span><br><span class="line">变量名=b，类型=__NSCFConstantString， 地址=0x1019808d0，值=，引用计数=-1</span><br><span class="line"></span><br><span class="line">变量名=c，类型=__NSCFConstantString， 地址=0x1015f3120，值=string，引用计数=-1</span><br><span class="line"></span><br><span class="line">变量名=d，类型=NSTaggedPointerString， 地址=0xa00676e697274736，值=string，引用计数=-1</span><br><span class="line"></span><br><span class="line">变量名=e，类型=NSTaggedPointerString， 地址=0xa00676e697274736，值=string，引用计数=-1</span><br><span class="line"></span><br><span class="line">变量名=f，类型=NSTaggedPointerString， 地址=0xa1ea1f72bb30ab19，值=123456789，引用计数=-1</span><br><span class="line"></span><br><span class="line">变量名=g，类型=__NSCFString， 地址=0x60800002b580，值=1234567890，引用计数=1</span><br></pre></td></tr></table></figure>
<p>从打印结果看出，变量 b 到 f 的引用计数为-1，若是无符号格式输出，应该是一个很大的数字，与我们理解的对象初始化后引用计数为 1 所不同，不同的创建方式，字符串的类型不同，引用计数也有区别，创建的字符串有三种类型：</p>
<p><strong>NSCFConstantString
</strong>NSCFString<br>NSTaggedPointerString<br>造成这种情况是由于 OC 对 NSString 的内存优化产生的。</p>
<p><strong>NSCFConstantString<br>从字面就可以看出，这是一个常量字符串，该类型的字符串是以字面量创建的，是在编译期创建的，保存在常量区。通过 a 与 c 的打印结果看出，当创建的字符串变量值在常量区存在时，变量会指向那个字符串，这是编译期做的优化，c 指向同一字符串 @”string”，地址与a相同。<br>文字常量区存放常量字符串，程序结束后由系统释放，也就是说指向常量表的指针不受引用计数管理。所以对于NSCFConstantString类型的变量，OC 的内存管理策略对其无效。
</strong>NSCFString<br>表示这是一个对象类型的字符串，在运行时创建，存储在堆区，服从OC 的对象内存管理策略。该类型的字符串由 Format 创建，无论是实例方法还是类方法且其长度不能太小（内容若包含中文字符，不论长度大小，都是NSCFString），否则创建的是NSTaggedPointerString类型，例如上例的变量 f 与 g。</p>
<p>NSTaggedPointerString<br>对于64位程序，为了节省内存和提高运行速度，苹果引入了 Tagged Point 技术。NSTaggedPointerString是对NSCFString优化后的存在，在运行时创建时对字符串的内容和长度做出判断，若字符串内容是由ASCII字符构成且长度较小（大概十个字符以内），这时候创建的字符串就是NSTaggedPointerString类型，字符串直接存储在指针里，引用计数同样为-1，不适用对象的内存管理策略。</p>
<p>Tagged Pointer指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，OC 对象的内存管理方式对其无效。<br>现在，我们在看看这道题：</p>
<p>在MRC下，会不会造成内存泄漏？会不会奔溃？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = [[NSString alloc] initWithString:@&quot;ABC&quot;];</span><br><span class="line"></span><br><span class="line">str = @&quot;123&quot;;</span><br><span class="line"></span><br><span class="line">[str release];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;.str);</span><br></pre></td></tr></table></figure>
<p>一目了然，str指向字符串常量，对象的内存管理方式对其无效，程序结束时，系统才会销毁常量区的值。所以不会造成内存泄漏更不会奔溃。</p>
<p>接下来我们再看看NSArray的平时注意不到的问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NSArray *a1 = @[@&quot;1&quot;,@&quot;2&quot;];</span><br><span class="line"></span><br><span class="line">NSArray *a2 = [[NSArray alloc]init];</span><br><span class="line"></span><br><span class="line">NSArray *a3 = [[NSArray alloc]initWithObjects:@&quot;1&quot;, nil];</span><br><span class="line"></span><br><span class="line">NSArray *a4 = [[NSArray alloc]initWithArray:@[@&quot;a&quot;,@&quot;b&quot;]];</span><br><span class="line"></span><br><span class="line">NSArray *a5 = [NSArray arrayWithObjects:@&quot;m&quot;,@&quot;n&quot;, nil];</span><br><span class="line"></span><br><span class="line">NSArray *a6 = [[NSArray alloc]init];</span><br><span class="line"></span><br><span class="line">NSArray *a7 = @[];</span><br><span class="line"></span><br><span class="line">XWLog(a1); XWLog(a2); XWLog(a3); XWLog(a4); XWLog(a5); XWLog(a6);XWLog(a7);</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">变量名=a1，类型=__NSArrayI， 地址=0x608000029400，值=(1,2)，引用计数=1</span><br><span class="line"></span><br><span class="line">变量名=a2，类型=__NSArray0， 地址=0x618000012490，值=()，引用计数=-1</span><br><span class="line"></span><br><span class="line">变量名=a3，类型=__NSSingleObjectArrayI， 地址=0x608000012890，值=(1)，引用计数=1</span><br><span class="line"></span><br><span class="line">变量名=a4，类型=__NSArrayI， 地址=0x608000029440，值=(a,b)，引用计数=1</span><br><span class="line"></span><br><span class="line">变量名=a5，类型=__NSArrayI， 地址=0x608000029460，值=(m,n)，引用计数=1</span><br><span class="line"></span><br><span class="line">变量名=a6，类型=__NSArray0， 地址=0x618000012490，值=()，引用计数=-1</span><br><span class="line"></span><br><span class="line">变量名=a7，类型=__NSArray0， 地址=0x618000012490，值=()，引用计数=-1</span><br></pre></td></tr></table></figure>
<p>从结果看出，只有a2 a6 a7这三个的引用计数为-1，其他变量的引用计数为1，显示正常。我们仔细发现，这三个的地址相同，这就是说三个变量指向了同一块内存，说明a2 a6 a7三个创建方式创建的空实例是一个特殊值的存在，其应该存储在常量静态区。我们可以猜测，OC为了优化内存，在常量静态区创建一个空值的特殊存在，应该是静态常量对象，无论什么方式创建的空实例，其都指向静态区这个空值的。</p>
<p>不仅是NSArray，Foundation中如NSString, NSDictionary, NSSet等区分可变和不可变版本的类，空实例都是静态对象（NSString的空实例对象是常量区的@””）,对象的内存管理策略对其无效。<br>参考</p>
<p>深入理解Tagged Pointer<br>NSString内存管理<br>从NSArray看类簇</p>
<p><a href="https://www.jianshu.com/p/462adf281fde" target="_blank" rel="noopener">转自 简书<a href="https://www.jianshu.com/u/292ed4eda0e2" target="_blank" rel="noopener">懒癌重症者</a></a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/14/自动释放池/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/14/自动释放池/" itemprop="url">
                  自动释放池
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-14 14:13:09 / 修改时间：14:14:17" itemprop="dateCreated datePublished" datetime="2018-09-14T14:13:09+08:00">2018-09-14</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/内存管理/" itemprop="url" rel="index"><span itemprop="name">内存管理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="我是前言"><a href="#我是前言" class="headerlink" title="我是前言"></a>我是前言</h1><p>Autorelease机制是iOS开发者管理对象内存的好伙伴，MRC中，调用<code>[obj autorelease]</code>来延迟内存的释放是一件简单自然的事，ARC下，我们甚至可以完全不知道Autorelease就能管理好内存。而在这背后，objc和编译器都帮我们做了哪些事呢，它们是如何协作来正确管理内存的呢？刨根问底，一起来探究下黑幕背后的Autorelease机制。</p>
<h1 id="Autorelease对象什么时候释放？"><a href="#Autorelease对象什么时候释放？" class="headerlink" title="Autorelease对象什么时候释放？"></a>Autorelease对象什么时候释放？</h1><p>这个问题拿来做面试题，问过很多人，没有几个能答对的。很多答案都是“当前作用域大括号结束时释放”，显然木有正确理解Autorelease机制。<br>在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的<code>runloop</code>迭代结束时释放的，而它能够释放的原因是<strong>系统在每个runloop迭代中都加入了自动释放池Push和Pop</strong></p>
<h2 id="小实验"><a href="#小实验" class="headerlink" title="小实验"></a>小实验</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__weak id reference = nil;</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    NSString *str = [NSString stringWithFormat:@&quot;sunnyxx&quot;];</span><br><span class="line">    // str是一个autorelease对象，设置一个weak的引用来观察它</span><br><span class="line">    reference = str;</span><br><span class="line">&#125;</span><br><span class="line">- (void)viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">    [super viewWillAppear:animated];</span><br><span class="line">    NSLog(@&quot;%@&quot;, reference); // Console: sunnyxx</span><br><span class="line">&#125;</span><br><span class="line">- (void)viewDidAppear:(BOOL)animated &#123;</span><br><span class="line">    [super viewDidAppear:animated];</span><br><span class="line">    NSLog(@&quot;%@&quot;, reference); // Console: (null)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>这个实验同时也证明了<code>viewDidLoad</code>和<code>viewWillAppear</code>是在同一个runloop调用的，而<code>viewDidAppear</code>是在之后的某个runloop调用的。</del><br>由于这个vc在loadView之后便add到了window层级上，所以<code>viewDidLoad</code>和<code>viewWillAppear</code>是在同一个runloop调用的，因此在<code>viewWillAppear</code>中，这个autorelease的变量依然有值。 </p>
<p>当然，我们也可以手动干预Autorelease对象的释放时机：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSString *str = [NSString stringWithFormat:@&quot;sunnyxx&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;%@&quot;, str); // Console: (null)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Autorelease原理"><a href="#Autorelease原理" class="headerlink" title="Autorelease原理"></a>Autorelease原理</h1><h2 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h2><p>ARC下，我们使用<code>@autoreleasepool{}</code>来使用一个AutoreleasePool，随后编译器将其改写成下面的样子： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void *context = objc_autoreleasePoolPush();</span><br><span class="line">// &#123;&#125;中的代码</span><br><span class="line">objc_autoreleasePoolPop(context);</span><br></pre></td></tr></table></figure>
<p>而这两个函数都是对<code>AutoreleasePoolPage</code>的简单封装，所以自动释放机制的核心就在于这个类。 </p>
<p>AutoreleasePoolPage是一个C++实现的类</p>
<p><img src="http://ww2.sinaimg.cn/mw690/51530583gw1elj2ugt21wj20f109m3zl.jpg" alt="img"></p>
<ul>
<li>AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以<code>双向链表</code>的形式组合而成（分别对应结构中的parent指针和child指针）</li>
<li>AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程）</li>
<li>AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址</li>
<li>上面的<code>id *next</code>指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置</li>
<li>一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入</li>
</ul>
<p>所以，若当前线程中只有一个AutoreleasePoolPage对象，并记录了很多autorelease对象地址时内存如下图：</p>
<p><img src="http://ww2.sinaimg.cn/mw690/51530583gw1elj5gvphtqj20dy0cx756.jpg" alt="img"></p>
<p>图中的情况，这一页再加入一个autorelease对象就要满了（也就是next指针马上指向栈顶），这时就要执行上面说的操作，建立下一页page对象，与这一页链表连接完成后，新page的<code>next</code>指针被初始化在栈底（begin的位置），然后继续向栈顶添加新对象。</p>
<p><strong>所以，向一个对象发送- autorelease消息，就是将这个对象加入到当前AutoreleasePoolPage的栈顶next指针指向的位置</strong></p>
<h2 id="释放时刻"><a href="#释放时刻" class="headerlink" title="释放时刻"></a>释放时刻</h2><p>每当进行一次<code>objc_autoreleasePoolPush</code>调用时，runtime向当前的AutoreleasePoolPage中add进一个<code>哨兵对象</code>，值为0（也就是个nil），那么这一个page就变成了下面的样子： </p>
<p><img src="http://ww2.sinaimg.cn/large/51530583gw1elj5z7hawej20ji0dewff.jpg" alt="img"></p>
<p><code>objc_autoreleasePoolPush</code>的返回值正是这个哨兵对象的地址，被<code>objc_autoreleasePoolPop(哨兵对象)</code>作为入参，于是：</p>
<ol>
<li>根据传入的哨兵对象地址找到哨兵对象所处的page</li>
<li>在当前page中，将晚于哨兵对象插入的所有autorelease对象都发送一次<code>- release</code>消息，并向回移动<code>next</code>指针到正确位置</li>
<li>补充2：从最新加入的对象一直向前清理，可以向前跨越若干个page，直到哨兵所在的page</li>
</ol>
<p>刚才的objc_autoreleasePoolPop执行后，最终变成了下面的样子： </p>
<p><img src="http://ww3.sinaimg.cn/mw690/51530583gw1elj6u2i3fyj20dz0bqdgi.jpg" alt="img"></p>
<h2 id="嵌套的AutoreleasePool"><a href="#嵌套的AutoreleasePool" class="headerlink" title="嵌套的AutoreleasePool"></a>嵌套的AutoreleasePool</h2><p>知道了上面的原理，嵌套的AutoreleasePool就非常简单了，pop的时候总会释放到上次push的位置为止，多层的pool就是多个哨兵对象而已，就像剥洋葱一样，每次一层，互不影响。</p>
<hr>
<p>【附加内容】</p>
<h1 id="Autorelease返回值的快速释放机制"><a href="#Autorelease返回值的快速释放机制" class="headerlink" title="Autorelease返回值的快速释放机制"></a>Autorelease返回值的快速释放机制</h1><p>值得一提的是，ARC下，runtime有一套对autorelease返回值的优化策略。<br>比如一个工厂方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)createSark &#123;</span><br><span class="line">    return [self new];</span><br><span class="line">&#125;</span><br><span class="line">// caller</span><br><span class="line">Sark *sark = [Sark createSark];</span><br></pre></td></tr></table></figure>
<p>秉着谁创建谁释放的原则，返回值需要是一个autorelease对象才能配合调用方正确管理内存，于是乎编译器改写成了形如下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)createSark &#123;</span><br><span class="line">    id tmp = [self new];</span><br><span class="line">    return objc_autoreleaseReturnValue(tmp); // 代替我们调用autorelease</span><br><span class="line">&#125;</span><br><span class="line">// caller</span><br><span class="line">id tmp = objc_retainAutoreleasedReturnValue([Sark createSark]) // 代替我们调用retain</span><br><span class="line">Sark *sark = tmp;</span><br><span class="line">objc_storeStrong(&amp;sark, nil); // 相当于代替我们调用了release</span><br></pre></td></tr></table></figure>
<p>一切看上去都很好，不过既然编译器知道了这么多信息，干嘛还要劳烦autorelease这个开销不小的机制呢？于是乎，runtime使用了一些黑魔法将这个问题解决了。</p>
<h2 id="黑魔法之Thread-Local-Storage"><a href="#黑魔法之Thread-Local-Storage" class="headerlink" title="黑魔法之Thread Local Storage"></a>黑魔法之Thread Local Storage</h2><p>Thread Local Storage（TLS）线程局部存储，目的很简单，将一块内存作为某个线程专有的存储，以key-value的形式进行读写，比如在非arm架构下，使用pthread提供的方法实现： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void* pthread_getspecific(pthread_key_t);</span><br><span class="line">int pthread_setspecific(pthread_key_t , const void *);</span><br></pre></td></tr></table></figure>
<p>说它是黑魔法可能被懂pthread的笑话- - </p>
<p>在返回值身上调用<code>objc_autoreleaseReturnValue</code>方法时，runtime将这个返回值object储存在TLS中，然后直接返回这个object（不调用autorelease）；同时，在外部接收这个返回值的<code>objc_retainAutoreleasedReturnValue</code>里，发现TLS中正好存了这个对象，那么直接返回这个object（不调用retain）。<br>于是乎，调用方和被调方利用TLS做中转，很有默契的免去了对返回值的内存管理。 </p>
<p>于是问题又来了，假如被调方和主调方只有一边是ARC环境编译的该咋办？（比如我们在ARC环境下用了非ARC编译的第三方库，或者反之）<br>只能动用更高级的黑魔法。 </p>
<h2 id="黑魔法之-builtin-return-address"><a href="#黑魔法之-builtin-return-address" class="headerlink" title="黑魔法之__builtin_return_address"></a>黑魔法之__builtin_return_address</h2><p>这个内建函数原型是<code>char *__builtin_return_address(int level)</code>，作用是得到函数的返回地址，参数表示层数，如__builtin_return_address(0)表示当前函数体返回地址，传1是调用这个函数的外层函数的返回值地址，以此类推。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (int)foo &#123;</span><br><span class="line">    NSLog(@&quot;%p&quot;, __builtin_return_address(0)); // 根据这个地址能找到下面ret的地址</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">// caller</span><br><span class="line">int ret = [sark foo];</span><br></pre></td></tr></table></figure>
<p>看上去也没啥厉害的，不过要知道，函数的返回值地址，也就对应着调用者结束这次调用的地址（或者相差某个固定的偏移量，根据编译器决定）<br>也就是说，被调用的函数也有翻身做地主的机会了，可以反过来对主调方干点坏事。<br>回到上面的问题，<strong>如果一个函数返回前知道调用方是ARC还是非ARC，就有机会对于不同情况做不同的处理</strong></p>
<h2 id="黑魔法之反查汇编指令"><a href="#黑魔法之反查汇编指令" class="headerlink" title="黑魔法之反查汇编指令"></a>黑魔法之反查汇编指令</h2><p>通过上面的__builtin_return_address加某些偏移量，被调方可以定位到主调方在返回值后面的<code>汇编指令</code>： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// caller</span><br><span class="line">int ret = [sark foo];</span><br><span class="line">// 内存中接下来的汇编指令（x86，我不懂汇编，瞎写的）</span><br><span class="line">movq ??? ???</span><br><span class="line">callq ???</span><br></pre></td></tr></table></figure>
<p>而这些汇编指令在内存中的值是固定的，比如movq对应着0x48。<br>于是乎，就有了下面的这个函数，入参是调用方__builtin_return_address传入值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static bool callerAcceptsFastAutorelease(const void * const ra0) &#123;</span><br><span class="line">    const uint8_t *ra1 = (const uint8_t *)ra0;</span><br><span class="line">    const uint16_t *ra2;</span><br><span class="line">    const uint32_t *ra4 = (const uint32_t *)ra1;</span><br><span class="line">    const void **sym;</span><br><span class="line">    // 48 89 c7    movq  %rax,%rdi</span><br><span class="line">    // e8          callq symbol</span><br><span class="line">    if (*ra4 != 0xe8c78948) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    ra1 += (long)*(const int32_t *)(ra1 + 4) + 8l;</span><br><span class="line">    ra2 = (const uint16_t *)ra1;</span><br><span class="line">    // ff 25       jmpq *symbol@DYLDMAGIC(%rip)</span><br><span class="line">    if (*ra2 != 0x25ff) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    ra1 += 6l + (long)*(const int32_t *)(ra1 + 2);</span><br><span class="line">    sym = (const void **)ra1;</span><br><span class="line">    if (*sym != objc_retainAutoreleasedReturnValue)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它检验了主调方在返回值之后是否紧接着调用了<code>objc_retainAutoreleasedReturnValue</code>，如果是，就知道了外部是ARC环境，反之就走没被优化的老逻辑。</p>
<h1 id="其他Autorelease相关知识点"><a href="#其他Autorelease相关知识点" class="headerlink" title="其他Autorelease相关知识点"></a>其他Autorelease相关知识点</h1><p>使用容器的block版本的枚举器时，内部会自动添加一个AutoreleasePool： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123;</span><br><span class="line">    // 这里被一个局部@autoreleasepool包围着</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>当然，在普通for循环和for in循环中没有，所以，还是新版的block版本枚举器更加方便。for循环中遍历产生大量autorelease变量时，就需要手加局部AutoreleasePool咯。</p>
<p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">转自</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Sun Lei</p>
              <p class="site-description motion-element" itemprop="description">只有用心才能看清楚·真正重要的东西·用眼睛是看不见的</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sun Lei</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.4.4</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Muse</a> v6.4.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.1"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
