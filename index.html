<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.1" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.1">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.4.1',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
<meta property="og:type" content="website">
<meta property="og:title" content="Man Tou Pu&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/iOS面试/index.html">
<meta property="og:site_name" content="Man Tou Pu&#39;s Blog">
<meta property="og:description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Man Tou Pu&#39;s Blog">
<meta name="twitter:description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">






  <link rel="canonical" href="http://yoursite.com/iOS面试/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Man Tou Pu's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Man Tou Pu's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">技术、生活个人博客</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/iOS-Block用法和实现原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/iOS-Block用法和实现原理/" itemprop="url">
                  iOS Block用法和实现原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 11:49:27 / 修改时间：11:55:19" itemprop="dateCreated datePublished" datetime="2018-09-17T11:49:27+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Block/" itemprop="url" rel="index"><span itemprop="name">Block</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>《Objective-C高级编程》是一本有趣又难懂的书，全书就讲了引用计数、Block、GCD三个概念，有趣是因为讲原理、实现的部分是其它iOS专业书籍里少有的。然而每个章节不读个三五遍还是比较难理解贯通的。本文针对其中的Block部分做些简单的笔记记录，讲述Block的用法和部分实现原理，详细解说从原书中寻。</p>
<h2 id="Block概要"><a href="#Block概要" class="headerlink" title="Block概要"></a>Block概要</h2><p><strong>Block</strong>：带有<strong>自动变量</strong>的<strong>匿名函数</strong>。<br><strong>匿名函数</strong>：没有函数名的函数，一对{}包裹的内容是匿名函数的作用域。<br><strong>自动变量</strong>：栈上声明的一个变量不是静态变量和全局变量，是不可以在这个栈内声明的匿名函数中使用的，但在Block中却可以。<br>虽然使用Block不用声明类，但是Block提供了类似Objective-C的类一样可以通过成员变量来<strong>保存作用域外变量值</strong>的方法，那些在Block的一对{}里使用到但却是在{}作用域以外声明的变量，就是Block截获的自动变量。</p>
<h2 id="Block常规概念"><a href="#Block常规概念" class="headerlink" title="Block常规概念"></a>Block常规概念</h2><h3 id="Block语法"><a href="#Block语法" class="headerlink" title="Block语法"></a>Block语法</h3><p>Block表达式语法：</p>
<blockquote>
<p>^ 返回值类型 (参数列表) {表达式}</p>
</blockquote>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^ int (int count) &#123;</span><br><span class="line">    return count + 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，可省略部分有：</p>
<ul>
<li>返回类型，例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^ (int count) &#123;</span><br><span class="line">    return count + 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数列表为空，则可省略，例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^ &#123;</span><br><span class="line">    NSLog(@&quot;No Parameter&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>即最简模式语法为：</p>
<blockquote>
<p>^ {表达式}</p>
</blockquote>
<h3 id="Block类型变量"><a href="#Block类型变量" class="headerlink" title="Block类型变量"></a>Block类型变量</h3><p>声明Block类型变量语法：</p>
<blockquote>
<p>返回值类型 (^变量名)(参数列表) = Block表达式</p>
</blockquote>
<p>例如，如下声明了一个变量名为blk的Block：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int (^blk)(int) = ^(int count) &#123;</span><br><span class="line">    return count + 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当Block类型变量作为函数的参数时，写作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)func:(int (^)(int))blk &#123;</span><br><span class="line">    NSLog(@&quot;Param:%@&quot;, blk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>借助typedef可简写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef int (^blk_k)(int);</span><br><span class="line"></span><br><span class="line">- (void)func:(blk_k)blk &#123;</span><br><span class="line">    NSLog(@&quot;Param:%@&quot;, blk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Block类型变量作返回值时，写作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (int (^)(int))funcR &#123;</span><br><span class="line">    return ^(int count) &#123;</span><br><span class="line">        return count ++;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>借助typedef简写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef int (^blk_k)(int);</span><br><span class="line"></span><br><span class="line">- (blk_k)funcR &#123;</span><br><span class="line">    return ^(int count) &#123;</span><br><span class="line">        return count ++;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="截获自动变量值"><a href="#截获自动变量值" class="headerlink" title="截获自动变量值"></a>截获自动变量值</h3><p>Block表达式可截获所使用的自动变量的值。<br><strong>截获</strong>：保存自动变量的<strong>瞬间值</strong>。<br>因为是“瞬间值”，所以声明Block之后，即便在Block外修改自动变量的值，也不会对Block内截获的自动变量值产生影响。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int i = 10;</span><br><span class="line">void (^blk)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;In block, i = %d&quot;, i);</span><br><span class="line">&#125;;</span><br><span class="line">i = 20;//Block外修改变量i，也不影响Block内的自动变量</span><br><span class="line">blk();//i修改为20后才执行，打印: In block, i = 10</span><br><span class="line">NSLog(@&quot;i = %d&quot;, i);//打印：i = 20</span><br></pre></td></tr></table></figure>
<h3 id="block说明符号"><a href="#block说明符号" class="headerlink" title="__block说明符号"></a>__block说明符号</h3><p>自动变量截获的值为Block声明时刻的瞬间值，保存后就不能改写该值，如需对自动变量进行重新赋值，需要在变量声明前附加<strong>block说明符，这时该变量称为</strong>block变量。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__block int i = 10;//i为__block变量，可在block中重新赋值</span><br><span class="line">void (^blk)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;In block, i = %d&quot;, i);</span><br><span class="line">&#125;;</span><br><span class="line">i = 20;</span><br><span class="line">blk();//打印: In block, i = 20</span><br><span class="line">NSLog(@&quot;i = %d&quot;, i);//打印：i = 20</span><br></pre></td></tr></table></figure>
<h3 id="自动变量值为一个对象情况"><a href="#自动变量值为一个对象情况" class="headerlink" title="自动变量值为一个对象情况"></a>自动变量值为一个对象情况</h3><p>当自动变量为一个类的<strong>对象</strong>，且没有使用__block修饰时，虽然不可以在Block内对该变量进行重新赋值，但可以修改该对象的属性。<br>如果该对象是个Mutable的对象，例如NSMutableArray，则还可以在Block内对NSMutableArray进行元素的增删：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *array = [[NSMutableArray alloc] initWithObjects:@&quot;1&quot;, @&quot;2&quot;,nil ];</span><br><span class="line">NSLog(@&quot;Array Count:%ld&quot;, array.count);//打印Array Count:2</span><br><span class="line">void (^blk)(void) = ^&#123;</span><br><span class="line">    [array removeObjectAtIndex:0];//Ok</span><br><span class="line">    //array = [NSNSMutableArray new];//没有__block修饰，编译失败！</span><br><span class="line">&#125;;</span><br><span class="line">blk();</span><br><span class="line">NSLog(@&quot;Array Count:%ld&quot;, array.count);//打印Array Count:1</span><br></pre></td></tr></table></figure>
<h2 id="Block实现原理"><a href="#Block实现原理" class="headerlink" title="Block实现原理"></a>Block实现原理</h2><h3 id="使用Clang"><a href="#使用Clang" class="headerlink" title="使用Clang"></a>使用Clang</h3><p>Block实际上是作为极普通的<strong>C语言源码</strong>来处理的：含有Block语法的源码首先被转换<strong>成C语言编译器能处理的源码</strong>，再作为普通的C源代码<strong>进行编译</strong>。<br>使用LLVM编译器的clang命令可将含有Block的Objective-C代码转换成C++的源代码，以探查其具体实现方式：</p>
<blockquote>
<p>clang -rewrite-objc 源码文件名</p>
</blockquote>
<p>注：如果使用该命令报错：<em>’UIKit/UIKit.h’ file not found</em>，可参考<a href="https://www.jianshu.com/p/43a09727eb2c" target="_blank" rel="noopener">《Objective-C编译成C++代码报错》</a>解决。</p>
<h3 id="Block结构"><a href="#Block结构" class="headerlink" title="Block结构"></a>Block结构</h3><p>使用Block的时候，编译器对Block语法进行了怎样的转换？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    int count = 10;</span><br><span class="line">    void (^ blk)() = ^()&#123;</span><br><span class="line">        NSLog(@&quot;In Block:%d&quot;, count);</span><br><span class="line">    &#125;;</span><br><span class="line">    blk();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示的最简单的Block使用代码，经clang转换后，可得到以下几个部分（有代码删减和注释添加）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void __main_block_func_0(</span><br><span class="line">    struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    int count = __cself-&gt;count; // bound by copy</span><br><span class="line">    </span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_64_vf2p_jz52yz7x4xtcx55yv0r0000gn_T_main_d2f8d2_mi_0, </span><br><span class="line">    count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个函数的实现，对应Block中{}内的内容，这些内容被当做了C语言函数来处理，函数参数中的<strong>__cself</strong>相当于Objective-C中的self。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc; //描述Block大小、版本等信息</span><br><span class="line">  int count;</span><br><span class="line">  //构造函数函数</span><br><span class="line">  __main_block_impl_0(void *fp,</span><br><span class="line">          struct __main_block_desc_0 *desc,</span><br><span class="line">          int _count,</span><br><span class="line">          int flags=0) : count(_count) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock; //在函数栈上声明，则为_NSConcreteStackBlock</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>__main_block_impl_0</strong>即为<strong>main()函数栈上的Block结构体</strong>，其中的__block_impl结构体声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct __block_impl &#123;</span><br><span class="line">  void *isa;//指明对象的Class</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>__block_impl</strong>结构体，即为Block的结构体，可理解为<strong>Block的类结构</strong>。<br>再看下main()函数翻译的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    int count = 10;</span><br><span class="line">    void (* blk)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, count));</span><br><span class="line">    </span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>去除掉复杂的类型转化，可简写为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    int count = 10;</span><br><span class="line">    sturct __main_block_impl_0 *blk = &amp;__main_block_impl_0(__main_block_func_0,         //函数指针</span><br><span class="line">                                                           &amp;__main_block_desc_0_DATA)); //Block大小、版本等信息</span><br><span class="line">    </span><br><span class="line">    (*blk-&gt;FuncPtr)(blk);   //调用FuncPtr指向的函数，并将blk自己作为参数传入</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此，可以看出，<strong>Block也是Objective-C中的对象</strong>。<br>Block有三种类（即__block_impl的<strong>isa</strong>指针指向的值，isa说明参考<a href="https://www.jianshu.com/p/41735c66dccb" target="_blank" rel="noopener">《Objective-C isa 指针 与 runtime 机制》</a>），根据Block对象创建时<strong>所处数据区不同</strong>而进行区别：</p>
<ul>
<li><strong>_NSConcreteStackBlock</strong>：在栈上创建的Block对象</li>
<li><strong>_NSConcreteMallocBlock</strong>：在堆上创建的Block对象</li>
<li><strong>_NSConcreteGlobalBlock</strong>：全局数据区的Block对象</li>
</ul>
<h3 id="如何截获自动变量"><a href="#如何截获自动变量" class="headerlink" title="如何截获自动变量"></a>如何截获自动变量</h3><p>上部分介绍了<strong>Block的结构</strong>，和<strong>作为匿名函数的调用机制</strong>，那<strong>自动变量截获</strong>是发生在什么时候呢？<br>观察上节代码中<strong>__main_block_impl_0</strong>结构体（main栈上Block的结构体）的构造函数可以看到，栈上的变量count以参数的形式传入到了这个构造函数中，此处即为<strong>变量的自动截获</strong>。<br>因此可以这样理解：<strong>__block_impl</strong>结构体已经可以代表Block类了，但在栈上又声明了<strong>__main_block_impl_0</strong>结构体，对<strong>__block_impl</strong>进行<strong>封装</strong>后才来表示栈上的<strong>Block类</strong>，就是为了获取Block中使用到的栈上声明的变量（<strong>栈上没在Block中使用的变量不会被捕获</strong>），变量被保存在Block的结构体实例中。<br>所以在blk()执行之前，栈上简单数据类型的count无论发生什么变化，都不会影响到Block以参数形式传入而捕获的值。但这个变量是指向对象的指针时，是可以修改这个对象的属性的，只是不能为变量重新赋值。</p>
<h3 id="Block的存储域"><a href="#Block的存储域" class="headerlink" title="Block的存储域"></a>Block的存储域</h3><p>上文已提到，根据Block创建的位置不同，Block有三种类型，创建的Block对象分别会存储到栈、堆、全局数据区域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void (^blk)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;Global Block&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    blk();</span><br><span class="line">    NSLog(@&quot;%@&quot;,[blk class]);//打印：__NSGlobalBlock__</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面代码块中的全局blk自然是存储在全局数据区，但注意在<strong>函数栈上</strong>创建的blk，如果<strong>没有截获自动变量</strong>，Block的结构实例还是会被设置在程序的<strong>全局数据区，而非栈上</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    void (^blk)(void) = ^&#123;//没有截获自动变量的Block</span><br><span class="line">        NSLog(@&quot;Stack Block&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    blk();</span><br><span class="line">    NSLog(@&quot;%@&quot;,[blk class]);//打印:__NSGlobalBlock__</span><br><span class="line">    </span><br><span class="line">    int i = 1;</span><br><span class="line">    void (^captureBlk)(void) = ^&#123;//截获自动变量i的Block</span><br><span class="line">        NSLog(@&quot;Capture:%d&quot;, i);</span><br><span class="line">    &#125;;</span><br><span class="line">    captureBlk();</span><br><span class="line">    NSLog(@&quot;%@&quot;,[captureBlk class]);//打印：__NSMallocBlock__</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到截获了自动变量的Block打印的类是<strong>NSGlobalBlock</strong>，表示存储在全局数据区。<br>但为什么捕获自动变量的Block打印的类却是设置在堆上的<strong>NSMallocBlock</strong>，而非栈上的<strong>NSStackBlock</strong>?这个问题稍后解释。</p>
<h3 id="Block复制"><a href="#Block复制" class="headerlink" title="Block复制"></a>Block复制</h3><p>配置在栈上的Block，如果其所属的栈作用域结束，该Block就会被废弃，对于超出Block作用域仍需使用Block的情况，Block提供了<strong>将Block从栈上复制到堆上的方法</strong>来解决这种问题，即便Block栈作用域已结束，但被拷贝到堆上的Block还可以继续存在。<br>复制到堆上的Block，<strong>将_NSConcreteMallocBlock</strong>类对象写入Block结构体实例的成员变量isa：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">impl.isa = &amp;_NSConcreteMallocBlock;</span><br></pre></td></tr></table></figure>
<p>在ARC有效时，大多数情况下编译器会进行判断，自动生成将Block从栈上复制到堆上的代码，以下几种情况<strong>栈上的Block会自动复制到堆上</strong>：</p>
<ul>
<li>调用Block的copy方法</li>
<li>将Block作为函数返回值时</li>
<li>将Block赋值给__strong修改的变量时</li>
<li>向Cocoa框架含有usingBlock的方法或者GCD的API传递Block参数时</li>
</ul>
<p>其它时候向方法的参数中传递Block时，需要手动调用copy方法复制Block。<br>上一节的栈上截获了自动变量i的Block之所以在栈上创建，却是<em>NSMallocBlock<strong>类，就是因为这个Block对象赋值给了</strong></em>_strong修饰的变量<strong>captureBlk（_strong是ARC下对象的默认修饰符）。<br>因为上面四条规则，在ARC下其实很少见到_NSConcreteStackBlock类的Block，大多数情况编译器都保证了Block是在堆上创建的，如下代码所示，仅最后一行代码直接使用一个不赋值给变量的Block，它的类才是</strong>NSStackBlock**：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int count = 0;</span><br><span class="line">blk_t blk = ^()&#123;</span><br><span class="line">    NSLog(@&quot;In Stack:%d&quot;, count);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;blk&apos;s Class:%@&quot;, [blk class]);//打印：blk&apos;s Class:__NSMallocBlock__</span><br><span class="line">NSLog(@&quot;Global Block:%@&quot;, [^&#123;NSLog(@&quot;Global Block&quot;);&#125; class]);//打印：Global Block:__NSGlobalBlock__</span><br><span class="line">NSLog(@&quot;Copy Block:%@&quot;, [[^&#123;NSLog(@&quot;Copy Block:%d&quot;,count);&#125; copy] class]);//打印：Copy Block:__NSMallocBlock__</span><br><span class="line">NSLog(@&quot;Stack Block:%@&quot;, [^&#123;NSLog(@&quot;Stack Block:%d&quot;,count);&#125; class]);//打印：Stack Block:__NSStackBlock__</span><br></pre></td></tr></table></figure>
<p>关于ARC下和MRC下Block自动copy的区别，查看<a href="https://link.jianshu.com/?t=https://www.zybuluo.com/MicroCai/note/49713" target="_blank" rel="noopener">《Block 小测验》</a>里几道题目就能区分了。<br>另外，原书存在ARC和MRC混合讲解、区分不明的情况，比如书中几个使用到栈上对象导致Crash的例子是MRC条件下才会发生的，但书中没做特殊说明。</p>
<h3 id="使用-block发生了什么"><a href="#使用-block发生了什么" class="headerlink" title="使用__block发生了什么"></a>使用__block发生了什么</h3><p>Block捕获的自动变量添加<strong>block说明符，就可在Block内读和写该变量，也可以在原来的栈上读写该变量。<br><strong>自动变量的截获</strong>保证了栈上的自动变量被销毁后，Block内仍可使用该变量。<br>**</strong>block<strong>保证了栈上和Block内（通常在堆上）可以访问和修改</strong>“同一个变量”**，__block是如何实现这一功能的？</p>
<p><strong>block发挥作用的<strong>原理</strong>：将栈上用</strong>block修饰的自动变量<strong>封装成一个结构体</strong>，让其在堆上创建，以方便从栈上或堆上访问和修改同一份数据。</p>
<p><strong>验证过程</strong>：<br>现在对刚才的代码段，加上__block说明符，并在block内外读写变量count。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    __block int count = 10;</span><br><span class="line">    void (^ blk)() = ^()&#123;</span><br><span class="line">        count = 20;</span><br><span class="line">        NSLog(@&quot;In Block:%d&quot;, count);//打印：In Block:20</span><br><span class="line">    &#125;;</span><br><span class="line">    count ++;</span><br><span class="line">    NSLog(@&quot;Out Block:%d&quot;, count);//打印：Out Block:11</span><br><span class="line">    </span><br><span class="line">    blk();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上面的代码段clang，发现Block的结构体<strong>__main_block_impl_0</strong>结构如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_count_0 *count; // by ref</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_count_0 *_count, int flags=0) : count(_count-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最大的变化就是count变量不再是int类型了，count变成了一个指向<strong>__Block_byref_count_0</strong>结构体的指针，<strong>__Block_byref_count_0</strong>结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_count_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_count_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它保存了int count变量，还有一个指向<strong>__Block_byref_count_0</strong>实例的指针<strong>__forwarding</strong>，通过下面两段代码<strong>__forwarding</strong>指针的用法可以知道，该指针其实指向的是对象自身：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Block的执行函数</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_count_0 *count = __cself-&gt;count; // bound by ref</span><br><span class="line"></span><br><span class="line">        (count-&gt;__forwarding-&gt;count) = 20;//对应count = 20;</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_64_vf2p_jz52yz7x4xtcx55yv0r0000gn_T_main_fafeeb_mi_0, </span><br><span class="line">        (count-&gt;__forwarding-&gt;count));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//main函数</span><br><span class="line">int main() &#123;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_count_0 count = &#123;(void*)0,</span><br><span class="line">    (__Block_byref_count_0 *)&amp;count, </span><br><span class="line">    0, </span><br><span class="line">    sizeof(__Block_byref_count_0), </span><br><span class="line">    10&#125;;</span><br><span class="line">    </span><br><span class="line">    void (* blk)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, </span><br><span class="line">    &amp;__main_block_desc_0_DATA, </span><br><span class="line">    (__Block_byref_count_0 *)&amp;count, </span><br><span class="line">    570425344));</span><br><span class="line">    </span><br><span class="line">    (count.__forwarding-&gt;count) ++;//对应count ++;</span><br><span class="line">    </span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_64_vf2p_jz52yz7x4xtcx55yv0r0000gn_T_main_fafeeb_mi_1, </span><br><span class="line">    (count.__forwarding-&gt;count));</span><br><span class="line">    </span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要通过<strong>forwarding指针完成对count变量的读写修改？<br>为了保证无论是在栈上还是在堆上，都能通过都</strong>forwarding指针找到在堆上创建的count这个<strong>main_block_func_0结构体，以完成对count-&gt;count（第一个count是</strong>main_block_func_0对象，第二个count是int类型变量）的访问和修改。<br>示意图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2814-c2c1c0ffeda6ad43.jpg_s?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<h3 id="Block的循环引用"><a href="#Block的循环引用" class="headerlink" title="Block的循环引用"></a>Block的循环引用</h3><p>Block的循环引用原理和解决方法大家都比较熟悉，此处将结合上文的介绍，介绍一种不常用的解决Block循环引用的方法和一种借助Block参数解决该问题的方法。<br>Block循环引用<strong>原因</strong>：一个对象A有Block类型的属性，从而持有这个Block，如果Block的代码块中使用到这个对象A，或者仅仅是用用到A对象的属性，会使Block也持有A对象，导致两者互相持有，不能在作用域结束后正常释放。<br><strong>解决原理</strong>：对象A照常持有Block，但Block不能强引用持有对象A以打破循环。<br><strong>解决方法</strong>：<br><strong>方法一：</strong>对Block内要使用的对象A使用_<strong>_weak</strong>进行修饰，Block对对象A弱引用打破循环。</p>
<p>有三种常用形式：</p>
<ul>
<li>使用__weak ClassName</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__block XXViewController* weakSelf = self;</span><br><span class="line">self.blk = ^&#123;</span><br><span class="line">    NSLog(@&quot;In Block : %@&quot;,weakSelf);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用__weak typeof(self)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">self.blk = ^&#123;</span><br><span class="line">    NSLog(@&quot;In Block : %@&quot;,weakSelf);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>Reactive Cocoa中的@weakify和@strongify</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@weakify(self);</span><br><span class="line">self.blk = ^&#123;</span><br><span class="line">    @strongify(self);</span><br><span class="line">    NSLog(@&quot;In Block : %@&quot;,self);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其原理参考<a href="https://www.jianshu.com/p/3d6c4416db5e" target="_blank" rel="noopener">《@weakify, @strongify》</a>，自己简便实现参考<a href="https://link.jianshu.com/?t=http://blog.csdn.net/u014773226/article/details/54617716" target="_blank" rel="noopener">《@weak - @strong 宏的实现》</a></p>
<p><strong>方法二：</strong>对Block内要使用的对象A使用<strong>__block</strong>进行修饰，并在代码块内，使用完__block变量后将其设为nil，并且该block必须至少执行一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__block XXController *blkSelf = self;</span><br><span class="line">self.blk = ^&#123;</span><br><span class="line">    NSLog(@&quot;In Block : %@&quot;,blkSelf);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意上述代码仍<strong>存在内存泄露</strong>，因为：</p>
<ul>
<li>XXController对象持有Block对象blk</li>
<li>blk对象持有__block变量blkSelf</li>
<li>__block变量blkSelf持有XXController对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__block XXController *blkSelf = self;</span><br><span class="line">self.blk = ^&#123;</span><br><span class="line">    NSLog(@&quot;In Block : %@&quot;,blkSelf);</span><br><span class="line">    blkSelf = nil;//不能省略</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">self.blk();//该block必须执行一次，否则还是内存泄露</span><br></pre></td></tr></table></figure>
<p>在block代码块内，使用完使用完__block变量后将其设为nil，并且该block必须至少执行一次后，<strong>不存在内存泄露</strong>，因为此时：</p>
<ul>
<li>XXController对象持有Block对象blk</li>
<li>blk对象持有__block变量blkSelf(类型为编译器创建的结构体)</li>
<li><strong>block变量blkSelf在执行blk()之后被设置为nil（</strong>block变量结构体的__forwarding指针指向了nil），不再持有XXController对象，打破循环</li>
</ul>
<p>第二种使用__block打破循环的方法，<strong>优点</strong>是：</p>
<ul>
<li>可通过<strong>block变量动态控制持有XXController对象的时间，运行时决定是否将nil或其他变量赋值给</strong>block变量</li>
<li>不能使用<strong>weak的系统中，使用</strong>unsafe_unretained来替代<strong>weak打破循环可能有野指针问题，使用</strong>block则可避免该问题</li>
</ul>
<p>其<strong>缺点</strong>也明显：</p>
<ul>
<li>必须手动保证__block变量最后设置为nil</li>
<li>block必须执行一次，否则__block不为nil循环应用仍存在</li>
</ul>
<p>因此，还是避免使用第二种不常用方式，直接使用<strong>weak打破Block循环引用。<br><strong>方法三</strong>：将在Block内要使用到的对象（一般为self对象），以Block参数的形式传入，Block就不会捕获该对象，而将其作为参数使用，其生命周期系统的栈自动管理，不造成内存泄露。<br>即原来使用</strong>weak的写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">self.blk = ^&#123;</span><br><span class="line">    __strong typeof(self) strongSelf = weakSelf;</span><br><span class="line">    NSLog(@&quot;Use Property:%@&quot;, strongSelf.name);</span><br><span class="line">    //……</span><br><span class="line">&#125;;</span><br><span class="line">self.blk();</span><br></pre></td></tr></table></figure>
<p>改为Block传参写法后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.blk = ^(UIViewController *vc) &#123;</span><br><span class="line">    NSLog(@&quot;Use Property:%@&quot;, vc.name);</span><br><span class="line">&#125;;</span><br><span class="line">self.blk(self);</span><br></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>简化了两行代码，更优雅</li>
<li>更明确的API设计：告诉API使用者，该方法的Block直接使用传进来的参数对象，不会造成循环引用，不用调用者再使用weak避免循环</li>
</ul>
<p>该种用法的详细思路，和clang后的数据结构，可参考<a href="https://link.jianshu.com/?t=https://github.com/ChenYilong/iOSBlog/blob/master/Tips/Heap-Stack%20Dance/Heap-Stack%20Dance.md" target="_blank" rel="noopener">《Heap-Stack Dance》</a>。</p>
<p><a href="https://www.jianshu.com/p/d28a5633b963" target="_blank" rel="noopener">转自 [<a href="https://www.jianshu.com/u/AqMpQK" target="_blank" rel="noopener">kamous</a>]</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/Block技巧与底层解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/Block技巧与底层解析/" itemprop="url">
                  Block技巧与底层解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 11:49:12 / 修改时间：11:51:58" itemprop="dateCreated datePublished" datetime="2018-09-17T11:49:12+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Block/" itemprop="url" rel="index"><span itemprop="name">Block</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li>Block底层解析<ul>
<li>什么是block？<ul>
<li>block编译转换结构</li>
<li>block实际结构</li>
</ul>
</li>
<li>block的类型<ul>
<li>NSConcreteGlobalBlock和NSConcreteStackBlock</li>
<li>NSConcreteMallocBlock</li>
</ul>
</li>
<li>捕捉变量对block结构的影响<ul>
<li>局部变量</li>
<li>全局变量</li>
<li>局部静态变量</li>
<li>__block修饰的变量</li>
<li>self隐式循环引用</li>
</ul>
</li>
<li>不同类型block的复制<ul>
<li>栈block</li>
<li>堆block</li>
<li>全局block</li>
</ul>
</li>
<li>block辅助函数<ul>
<li>__block修饰的基本类型的辅助函数</li>
<li>对象的辅助函数</li>
</ul>
</li>
<li>ARC中block的工作<ul>
<li>block试验</li>
<li>block作为参数传递</li>
<li>block作为返回值</li>
<li>block属性</li>
</ul>
</li>
</ul>
</li>
<li>参考博文</li>
</ul>
<h1 id="Block底层解析"><a href="#Block底层解析" class="headerlink" title="Block底层解析"></a>Block底层解析</h1><p>最近看了一些block的资料，并动手做了一些实践，摘录并添加了一些结论。</p>
<h2 id="什么是block？"><a href="#什么是block？" class="headerlink" title="什么是block？"></a>什么是block？</h2><p>首先，看一个极简的block：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">        ^&#123; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="block编译转换结构"><a href="#block编译转换结构" class="headerlink" title="block编译转换结构"></a>block编译转换结构</h6><p>对其执行<code>clang -rewrite-objc</code>编译转换成C++实现，得到以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">struct __block_impl &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    int Flags;</span><br><span class="line">    int Reserved;</span><br><span class="line">    void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">        (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不难看出其中的<code>__main_block_impl_0</code>就是block的一个C++的实现(最后面的<code>_0</code>代表是main中的第几个block)，也就是说也是一个<code>结构体</code>。<br>其中<code>__block_impl</code>的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct __block_impl &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其结构体成员如下：</p>
<ul>
<li>isa，指向所属类的指针，也就是block的类型</li>
<li>flags，标志变量，在实现block的内部操作时会用到</li>
<li>Reserved，保留变量</li>
<li>FuncPtr，block执行时调用的函数指针<br>可以看出，它包含了isa指针（包含isa指针的皆为对象），也就是说block也是一个<code>对象</code>(runtime里面，对象和类都是用结构体表示)。</li>
</ul>
<p><code>__main_block_desc_0</code>的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure>
<p>其结构成员含义如下：</p>
<ul>
<li>reserved：保留字段</li>
<li>Block_size：block大小(sizeof(struct __main_block_impl_0))</li>
</ul>
<p>以上代码在定义<code>__main_block_desc_0</code>结构体时，同时创建了<code>__main_block_desc_0_DATA</code>，并给它赋值，以供在<code>main</code>函数中对<code>__main_block_impl_0</code>进行初始化。<br><code>__main_block_impl_0</code>定义了显式的构造函数，其函数体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</span><br><span class="line">  impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">  impl.Flags = flags;</span><br><span class="line">  impl.FuncPtr = fp;</span><br><span class="line">  Desc = desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，</p>
<ul>
<li><code>__main_block_impl_0</code>的<code>isa</code>指针指向了<code>_NSConcreteStackBlock</code>，</li>
<li>从<code>main</code>函数中看， <code>__main_block_impl_0</code>的<code>FuncPtr</code>指向了函数<code>__main_block_func_0</code></li>
<li><code>__main_block_impl_0</code>的<code>Desc</code>也指向了定义<code>__main_block_desc_0</code>时就创建的<code>__main_block_desc_0_DATA</code>，其中纪录了block结构体大小等信息。</li>
</ul>
<p>以上就是根据编译转换的结果，对一个简单block的解析，后面会将block操作<code>不同类型的外部变量</code>，对block结构的影响进行相应的说明。</p>
<h6 id="block实际结构"><a href="#block实际结构" class="headerlink" title="block实际结构"></a>block实际结构</h6><p>接下来观察下<code>Block_private.h</code>文件中对block的相关结构体的真实定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* Revised new layout. */</span><br><span class="line">struct Block_descriptor &#123;</span><br><span class="line">    unsigned long int reserved;</span><br><span class="line">    unsigned long int size;</span><br><span class="line">    void (*copy)(void *dst, void *src);</span><br><span class="line">    void (*dispose)(void *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct Block_layout &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    int flags;</span><br><span class="line">    int reserved;</span><br><span class="line">    void (*invoke)(void *, ...);</span><br><span class="line">    struct Block_descriptor *descriptor;</span><br><span class="line">    /* Imported variables. */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有了上文对编译转换的分析，这里只针对略微不同的成员进行分析：</p>
<ul>
<li><p>invoke，同上文的FuncPtr，block执行时调用的函数指针，block定义时内部的执行代码都在这个函数中</p>
</li>
<li><p>Block_descriptor，block的详细描述</p>
<p>​</p>
<ul>
<li>copy/dispose，辅助拷贝/销毁函数，处理block范围外的变量时使用</li>
</ul>
</li>
</ul>
<p>总体来说，block就是一个里面存储了指向<code>函数体中包含定义block时的代码块</code>的函数指针，以及<code>block外部上下文</code>变量等信息的结构体。</p>
<h2 id="block的类型"><a href="#block的类型" class="headerlink" title="block的类型"></a>block的类型</h2><p>block的常见类型有3种：</p>
<ul>
<li>_NSConcreteGlobalBlock（全局）</li>
<li>_NSConcreteStackBlock（栈）</li>
<li>_NSConcreteMallocBlock（堆）</li>
</ul>
<p>附上APUE的进程虚拟内存段分布图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/608238-2393520e3fec4271.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/707" alt="img"></p>
<p>进程虚拟内存空间分布</p>
<p>其中前2种在<code>Block.h</code>种声明，后1种在<code>Block_private.h</code>中声明，所以最后1种基本不会在源码中出现。<br>由于无法直接创建<code>_NSConcreteMallocBlock</code>类型的block，所以这里只对前面2种进行手动创建分析，最后1种通过源代码分析。</p>
<h6 id="NSConcreteGlobalBlock和NSConcreteStackBlock"><a href="#NSConcreteGlobalBlock和NSConcreteStackBlock" class="headerlink" title="NSConcreteGlobalBlock和NSConcreteStackBlock"></a>NSConcreteGlobalBlock和NSConcreteStackBlock</h6><p>首先，根据前面两种类型，编写以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void (^globalBlock)() = ^&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        void (^stackBlock1)() = ^&#123;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对其进行编译转换后得到以下缩略代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// globalBlock</span><br><span class="line">struct __globalBlock_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __globalBlock_block_desc_0* Desc;</span><br><span class="line">  __globalBlock_block_impl_0(void *fp, struct __globalBlock_block_desc_0 *desc, int flags=0) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteGlobalBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// stackBlock</span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">        void (*stackBlock)() = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出<code>globalBlock</code>的isa指向了<code>_NSConcreteGlobalBlock</code>，即在全局区域创建，编译时具体的代码就已经确定在上图中的代码段中了，block变量存储在全局数据存储区；<code>stackBlock</code>的isa指向了<code>_NSConcreteStackBlock</code>，即在栈区创建。</p>
<h6 id="NSConcreteMallocBlock"><a href="#NSConcreteMallocBlock" class="headerlink" title="NSConcreteMallocBlock"></a>NSConcreteMallocBlock</h6><p>接下来是在堆中的block，堆中的block无法直接创建，其需要由<code>_NSConcreteStackBlock</code>类型的block拷贝而来(也就是说<code>block需要执行copy之后才能存放到堆中</code>)。由于block的拷贝最终都会调用<code>_Block_copy_internal</code>函数，所以观察这个函数就可以知道堆中block是如何被创建的了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static void *_Block_copy_internal(const void *arg, const int flags) &#123;</span><br><span class="line">    struct Block_layout *aBlock;</span><br><span class="line">    ...</span><br><span class="line">    aBlock = (struct Block_layout *)arg;</span><br><span class="line">    ...</span><br><span class="line">    // Its a stack block.  Make a copy.</span><br><span class="line">    if (!isGC) &#123;</span><br><span class="line">        // 申请block的堆内存</span><br><span class="line">        struct Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size);</span><br><span class="line">        if (!result) return (void *)0;</span><br><span class="line">        // 拷贝栈中block到刚申请的堆内存中</span><br><span class="line">        memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first</span><br><span class="line">        // reset refcount</span><br><span class="line">        result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK);    // XXX not needed</span><br><span class="line">        result-&gt;flags |= BLOCK_NEEDS_FREE | 1;</span><br><span class="line">        // 改变isa指向_NSConcreteMallocBlock，即堆block类型</span><br><span class="line">        result-&gt;isa = _NSConcreteMallocBlock;</span><br><span class="line">        if (result-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) &#123;</span><br><span class="line">            //printf(&quot;calling block copy helper %p(%p, %p)...\n&quot;, aBlock-&gt;descriptor-&gt;copy, result, aBlock);</span><br><span class="line">            (*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上代码以及注释可以很清楚的看出，函数通过<code>memmove</code>将栈中的block的内容拷贝到了堆中，并使isa指向了<code>_NSConcreteMallocBlock</code>。<br>block主要的一些学问就出在栈中block向堆中block的转移过程中了。</p>
<h2 id="捕捉变量对block结构的影响"><a href="#捕捉变量对block结构的影响" class="headerlink" title="捕捉变量对block结构的影响"></a>捕捉变量对block结构的影响</h2><p>接下来会编译转换捕捉不同变量类型的block，以对比它们的区别。</p>
<h6 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h6><p>前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    ^&#123;a;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct __Person__test_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __Person__test_block_desc_0* Desc;</span><br><span class="line">  int a;</span><br><span class="line">  // a(_a)是构造函数的参数列表初始化形式，相当于a = _a。从_I_Person_test看，传入的就是a</span><br><span class="line">  __Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, int _a, int flags=0) : a(_a) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) &#123;</span><br><span class="line">  int a = __cself-&gt;a; // bound by copy</span><br><span class="line">a;&#125;</span><br><span class="line"></span><br><span class="line">static struct __Person__test_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __Person__test_block_desc_0_DATA = &#123; 0, sizeof(struct __Person__test_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line">static void _I_Person_test(Person * self, SEL _cmd) &#123;</span><br><span class="line">    int a;</span><br><span class="line">    (void (*)())&amp;__Person__test_block_impl_0((void *)__Person__test_block_func_0, &amp;__Person__test_block_desc_0_DATA, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，block相对于文章开头增加了一个int类型的成员变量，他就是用来存储外部变量a的。可以看出，这次拷贝只是一次<code>值传递</code>。并且当我们想在block中进行以下操作时，将会发生错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^&#123;a = 10;&#125;;</span><br></pre></td></tr></table></figure>
<p>编译器会提示</p>
<p><img src="http://upload-images.jianshu.io/upload_images/608238-712f1c798d842cbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/299" alt="img"></p>
<p>错误提示</p>
<p>。因为_I_Person_test函数中的a和<strong>Person</strong>test_block_func_0函数中的a并没有在同一个作用域，所以在block对a进行赋值是没有意义的，所以编译器给出了错误。我们可以通过地址传递来消除以上错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">    int a = 0;</span><br><span class="line">    // 利用指针p存储a的地址</span><br><span class="line">    int *p = &amp;a;</span><br><span class="line"></span><br><span class="line">    ^&#123;</span><br><span class="line">        // 通过a的地址设置a的值</span><br><span class="line">        *p = 10;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是变量a的生命周期是和方法test的栈相关联的，当test运行结束，栈随之销毁，那么变量a就会被销毁，p也就成为了野指针。如果block是作为参数或者返回值，这些类型都是跨栈的，也就是说再次调用会造成野指针错误。</p>
<h6 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h6><p>前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 全局静态</span><br><span class="line">static int a;</span><br><span class="line">// 全局</span><br><span class="line">int b;</span><br><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ^&#123;</span><br><span class="line">        a = 10;</span><br><span class="line">        b = 10;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static int a;</span><br><span class="line">int b;</span><br><span class="line"></span><br><span class="line">struct __Person__test_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __Person__test_block_desc_0* Desc;</span><br><span class="line">  __Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, int flags=0) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">        a = 10;</span><br><span class="line">        b = 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">static struct __Person__test_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __Person__test_block_desc_0_DATA = &#123; 0, sizeof(struct __Person__test_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line">static void _I_Person_test(Person * self, SEL _cmd) &#123;</span><br><span class="line"></span><br><span class="line">    (void (*)())&amp;__Person__test_block_impl_0((void *)__Person__test_block_func_0, &amp;__Person__test_block_desc_0_DATA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，因为全局变量都是在<code>静态数据存储区</code>，在程序结束前不会被销毁，所以block直接访问了对应的变量，而没有在<strong>Person</strong>test_block_impl_0结构体中给变量预留位置。</p>
<h6 id="局部静态变量"><a href="#局部静态变量" class="headerlink" title="局部静态变量"></a>局部静态变量</h6><p>前</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">    static int a;</span><br><span class="line">    ^&#123;</span><br><span class="line">        a = 10;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct __Person__test_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __Person__test_block_desc_0* Desc;</span><br><span class="line">  int *a;</span><br><span class="line">  __Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, int *_a, int flags=0) : a(_a) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) &#123;</span><br><span class="line">  int *a = __cself-&gt;a; // bound by copy</span><br><span class="line">        // 这里通过局部静态变量a的地址来对其进行修改</span><br><span class="line">        (*a) = 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">static struct __Person__test_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __Person__test_block_desc_0_DATA = &#123; 0, sizeof(struct __Person__test_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line">static void _I_Person_test(Person * self, SEL _cmd) &#123;</span><br><span class="line">    static int a;</span><br><span class="line">    // 传入a的地址</span><br><span class="line">    (void (*)())&amp;__Person__test_block_impl_0((void *)__Person__test_block_func_0, &amp;__Person__test_block_desc_0_DATA, &amp;a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意一点的是静态局部变量是存储在静态数据存储区域的，也就是和程序拥有一样的<code>生命周期</code>，也就是说在程序运行时，都能够保证block访问到一个有效的变量。但是其<code>作用范围</code>还是局限于定义它的函数中，所以只能在block通过静态局部变量的<code>地址</code>来进行访问。<br>关于变量的存储我原来的这篇博客有提及：<a href="https://link.jianshu.com/?t=http://blog.csdn.net/triplecc/article/details/24808417" target="_blank" rel="noopener">c语言臆想–全局—局部变量</a></p>
<h6 id="block修饰的变量"><a href="#block修饰的变量" class="headerlink" title="__block修饰的变量"></a>__block修饰的变量</h6><p>前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">   __block int a;</span><br><span class="line">    ^&#123;</span><br><span class="line">        a = 10;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_a_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_a_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __Person__test_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __Person__test_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_a_0 *a; // by ref</span><br><span class="line">  __Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_a_0 *a = __cself-&gt;a; // bound by ref</span><br><span class="line">        // 注意，这里的_forwarding用来保证操作的始终是堆中的拷贝a，而不是栈中的a</span><br><span class="line">        (a-&gt;__forwarding-&gt;a) = 10;</span><br><span class="line">    &#125;</span><br><span class="line">static void __Person__test_block_copy_0(struct __Person__test_block_impl_0*dst, struct __Person__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</span><br><span class="line"></span><br><span class="line">static void __Person__test_block_dispose_0(struct __Person__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</span><br><span class="line"></span><br><span class="line">static struct __Person__test_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __Person__test_block_impl_0*, struct __Person__test_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __Person__test_block_impl_0*);</span><br><span class="line">&#125; __Person__test_block_desc_0_DATA = &#123; 0, sizeof(struct __Person__test_block_impl_0), __Person__test_block_copy_0, __Person__test_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line">static void _I_Person_test(Person * self, SEL _cmd) &#123;</span><br><span class="line">    // __block将a包装成了一个对象</span><br><span class="line">   __attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(void*)0,(__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0)&#125;;</span><br><span class="line">;</span><br><span class="line">    (void (*)())&amp;__Person__test_block_impl_0((void *)__Person__test_block_func_0, &amp;__Person__test_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，对比上面的结果，明显多了<code>__Block_byref_a_0</code>结构体，这个结构体中含有<code>isa</code>指针，所以也是一个对象，它是用来包装局部变量a的。当block被copy到堆中时，<code>__Person__test_block_impl_0</code>的拷贝辅助函数<code>__Person__test_block_copy_0</code>会将<code>__Block_byref_a_0</code>拷贝至堆中，所以即使局部变量所在堆被销毁，block依然能对堆中的局部变量进行操作。其中<code>__Block_byref_a_0</code>成员指针<code>__forwarding</code>用来指向它在堆中的拷贝，其依据源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void _Block_byref_assign_copy(void *dest, const void *arg, const int flags) &#123;</span><br><span class="line">    struct Block_byref **destp = (struct Block_byref **)dest;</span><br><span class="line">    struct Block_byref *src = (struct Block_byref *)arg;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    // 堆中拷贝的forwarding指向它自己</span><br><span class="line">    copy-&gt;forwarding = copy; // patch heap copy to point to itself (skip write-barrier)</span><br><span class="line">    // 栈中的forwarding指向堆中的拷贝</span><br><span class="line">    src-&gt;forwarding = copy;  // patch stack to point to heap copy</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做是为了保证操作的值始终是堆中的拷贝，而不是栈中的值。（处理在局部变量所在栈还没销毁，就调用block来改变局部变量值的情况，如果没有__forwarding指针，则修改无效）<br>至于block如何实现对局部变量的拷贝，下面会详细说明。</p>
<h6 id="self隐式循环引用"><a href="#self隐式循环引用" class="headerlink" title="self隐式循环引用"></a>self隐式循环引用</h6><p>前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@implementation Person</span><br><span class="line">&#123;</span><br><span class="line">    int _a;</span><br><span class="line">    void (^_block)();</span><br><span class="line">&#125;</span><br><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">  void (^_block)() = ^&#123;</span><br><span class="line">        _a = 10;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">struct __Person__test_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __Person__test_block_desc_0* Desc;</span><br><span class="line">  // 可以看到，block强引用了self</span><br><span class="line">  Person *self;</span><br><span class="line">  __Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, Person *_self, int flags=0) : self(_self) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) &#123;</span><br><span class="line">  Person *self = __cself-&gt;self; // bound by copy</span><br><span class="line"></span><br><span class="line">        (*(int *)((char *)self + OBJC_IVAR_$_Person$_a)) = 10;</span><br><span class="line">    &#125;</span><br><span class="line">static void __Person__test_block_copy_0(struct __Person__test_block_impl_0*dst, struct __Person__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;self, (void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static void __Person__test_block_dispose_0(struct __Person__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static struct __Person__test_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __Person__test_block_impl_0*, struct __Person__test_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __Person__test_block_impl_0*);</span><br><span class="line">&#125; __Person__test_block_desc_0_DATA = &#123; 0, sizeof(struct __Person__test_block_impl_0), __Person__test_block_copy_0, __Person__test_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line">static void _I_Person_test(Person * self, SEL _cmd) &#123;</span><br><span class="line">  void (*_block)() = (void (*)())&amp;__Person__test_block_impl_0((void *)__Person__test_block_func_0, &amp;__Person__test_block_desc_0_DATA, self, 570425344);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在编译转换前，将<code>_a</code>改成<code>self.a</code>，能很明显地看出是产生了循环引用(self强引用block，block强引用self)。那么使用<code>_a</code>呢？经过编译转换后，依然可以在<code>__Person__test_block_impl_0</code>看见<code>self</code>的身影。且在函数<code>_I_Person_test</code>中，传入的参数也是<code>self</code>。通过以下语句，可以看出，不管是用什么形式访问实例变量，最终都会转换成<code>self+变量内存偏移的形式</code>。所以在上面例子中使用<code>_a</code>也会造成循环引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) &#123;</span><br><span class="line">  Person *self = __cself-&gt;self; // bound by copy</span><br><span class="line">        // self＋实例变量a的偏移值</span><br><span class="line">        (*(int *)((char *)self + OBJC_IVAR_$_Person$_a)) = 10;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="不同类型block的复制"><a href="#不同类型block的复制" class="headerlink" title="不同类型block的复制"></a>不同类型block的复制</h2><p><code>block</code>的复制代码在<code>_Block_copy_internal</code>函数中。</p>
<h6 id="栈block"><a href="#栈block" class="headerlink" title="栈block"></a>栈block</h6><p>从以下代码可以看出，栈block的复制不仅仅复制了其内容，还添加了一些额外的东西</p>
<ul>
<li>1、往flags中并入了<code>BLOCK_NEEDS_FREE</code>（这个标志表明block需要释放，在<code>release</code>以及<code>再次拷贝</code>时会用到）</li>
<li>2、如果有辅助copy函数（<code>BLOCK_HAS_COPY_DISPOSE</code>），那么就调用（这个辅助copy函数是用来<code>拷贝block捕获的变量</code>的）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">struct Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size);</span><br><span class="line">      if (!result) return (void *)0;</span><br><span class="line">      memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first</span><br><span class="line">      // reset refcount</span><br><span class="line">      result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK);    // XXX not needed</span><br><span class="line">      result-&gt;flags |= BLOCK_NEEDS_FREE | 1;</span><br><span class="line">      result-&gt;isa = _NSConcreteMallocBlock;</span><br><span class="line">      if (result-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) &#123;</span><br><span class="line">          //printf(&quot;calling block copy helper %p(%p, %p)...\n&quot;, aBlock-&gt;descriptor-&gt;copy, result, aBlock);</span><br><span class="line">          (*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup</span><br><span class="line">      &#125;</span><br><span class="line">      return result;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h6 id="堆block"><a href="#堆block" class="headerlink" title="堆block"></a>堆block</h6><p>从以下代码看出，如果block的flags中有<code>BLOCK_NEEDS_FREE</code>标志（block从栈中拷贝到堆时添加的标志），就执行<code>latching_incr_int</code>操作，其功能就是让block的引用计数加1。所以堆中block的拷贝只是单纯地改变了引用计数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) &#123;</span><br><span class="line">      // latches on high</span><br><span class="line">      latching_incr_int(&amp;aBlock-&gt;flags);</span><br><span class="line">      return aBlock;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h6 id="全局block"><a href="#全局block" class="headerlink" title="全局block"></a>全局block</h6><p>从以下代码看出，对于全局block，函数没有做任何操作，直接返回了传入的block</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">else if (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) &#123;</span><br><span class="line">      return aBlock;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="block辅助函数"><a href="#block辅助函数" class="headerlink" title="block辅助函数"></a>block辅助函数</h2><p>上文提及到了block辅助copy与dispose处理函数，这里分析下这两个函数的内部实现。在捕获变量为<code>__block</code>修饰的<code>基本类型</code>，或者为<code>对象</code>时，block才会有这两个辅助函数。<br>block<code>捕捉变量</code>拷贝函数为<code>_Block_object_assign</code>。在调用复制block的函数_Block_copy_internal时，会根据block有无辅助函数来对<code>捕捉变量</code>拷贝函数<code>_Block_object_assign</code>进行调用。而在<code>_Block_object_assign</code>函数中，也会判断<code>捕捉变量</code>包装而成的对象(Block_byref结构体)是否有辅助函数，来进行调用。</p>
<h6 id="block修饰的基本类型的辅助函数"><a href="#block修饰的基本类型的辅助函数" class="headerlink" title="__block修饰的基本类型的辅助函数"></a><code>__block</code>修饰的基本类型的辅助函数</h6><p>编写以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^Block)();</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        __block int a;</span><br><span class="line">        Block block = ^ &#123;</span><br><span class="line">            a;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换成C++代码后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">typedef void(*Block)();</span><br><span class="line">// __block int a</span><br><span class="line">struct __Block_byref_a_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_a_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// block</span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_a_0 *a; // by ref</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// block函数体</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_a_0 *a = __cself-&gt;a; // bound by ref</span><br><span class="line"></span><br><span class="line">            (a-&gt;__forwarding-&gt;a);</span><br><span class="line">        &#125;</span><br><span class="line">// 辅助copy函数</span><br><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</span><br><span class="line"></span><br><span class="line">// 辅助dispose函数</span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">        // 这里创建了，并将a的flags设置为0</span><br><span class="line">        __attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(void*)0,(__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0)&#125;;</span><br><span class="line">;</span><br><span class="line">        Block block = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码中，被<code>__block</code>修饰的a变量变为了<code>__Block_byref_a_0</code>类型，根据这个格式，从源码中查看得到相似的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">struct Block_byref &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    struct Block_byref *forwarding;</span><br><span class="line">    int flags; /* refcount; */</span><br><span class="line">    int size;</span><br><span class="line">    void (*byref_keep)(struct Block_byref *dst, struct Block_byref *src);</span><br><span class="line">    void (*byref_destroy)(struct Block_byref *);</span><br><span class="line">    /* long shared[0]; */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 做下对比</span><br><span class="line">struct __Block_byref_a_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_a_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// flags/_flags类型</span><br><span class="line">enum &#123;</span><br><span class="line">        /* See function implementation for a more complete description of these fields and combinations */</span><br><span class="line">        // 是一个对象</span><br><span class="line">        BLOCK_FIELD_IS_OBJECT   =  3,  /* id, NSObject, __attribute__((NSObject)), block, ... */</span><br><span class="line">        // 是一个block</span><br><span class="line">        BLOCK_FIELD_IS_BLOCK    =  7,  /* a block variable */</span><br><span class="line">        // 被__block修饰的变量</span><br><span class="line">        BLOCK_FIELD_IS_BYREF    =  8,  /* the on stack structure holding the __block variable */</span><br><span class="line">        // 被__weak修饰的变量，只能被辅助copy函数使用</span><br><span class="line">        BLOCK_FIELD_IS_WEAK     = 16,  /* declared __weak, only used in byref copy helpers */</span><br><span class="line">        // block辅助函数调用（告诉内部实现不要进行retain或者copy）</span><br><span class="line">        BLOCK_BYREF_CALLER      = 128  /* called from __block (byref) copy/dispose support routines. */</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>可以看出，<code>__block</code>将原来的基本类型包装成了<code>对象</code>。因为以上两个结构体的前4个成员的类型都是一样的，内存空间排列一致，所以可以进行以下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 转换成C++代码</span><br><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</span><br><span class="line"></span><br><span class="line">// _Block_object_assign源码</span><br><span class="line">void _Block_object_assign(void *destAddr, const void *object, const int flags) &#123;</span><br><span class="line">...</span><br><span class="line">    else if ((flags &amp; BLOCK_FIELD_IS_BYREF) == BLOCK_FIELD_IS_BYREF)  &#123;</span><br><span class="line">        // copying a __block reference from the stack Block to the heap</span><br><span class="line">        // flags will indicate if it holds a __weak reference and needs a special isa</span><br><span class="line">        _Block_byref_assign_copy(destAddr, object, flags);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// _Block_byref_assign_copy源码</span><br><span class="line">static void _Block_byref_assign_copy(void *dest, const void *arg, const int flags) &#123;</span><br><span class="line">    // 这里因为前面4个成员的内存分布一样，所以直接转换后，使用Block_byref的成员变量名，能访问到__Block_byref_a_0的前面4个成员</span><br><span class="line">    struct Block_byref **destp = (struct Block_byref **)dest;</span><br><span class="line">    struct Block_byref *src = (struct Block_byref *)arg;</span><br><span class="line">...</span><br><span class="line">    else if ((src-&gt;forwarding-&gt;flags &amp; BLOCK_REFCOUNT_MASK) == 0) &#123;</span><br><span class="line">        // 从main函数对__Block_byref_a_0的初始化，可以看到初始化时将flags赋值为0</span><br><span class="line">        // 这里表示第一次拷贝，会进行复制操作，并修改原来flags的值</span><br><span class="line">        // static int _Byref_flag_initial_value = BLOCK_NEEDS_FREE | 2;</span><br><span class="line">        // 可以看出，复制后，会并入BLOCK_NEEDS_FREE，后面的2是block的初始引用计数</span><br><span class="line">        ...</span><br><span class="line">        copy-&gt;flags = src-&gt;flags | _Byref_flag_initial_value;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    // 已经拷贝到堆了，只增加引用计数</span><br><span class="line">    else if ((src-&gt;forwarding-&gt;flags &amp; BLOCK_NEEDS_FREE) == BLOCK_NEEDS_FREE) &#123;</span><br><span class="line">        latching_incr_int(&amp;src-&gt;forwarding-&gt;flags);</span><br><span class="line">    &#125;</span><br><span class="line">    // 普通的赋值，里面最底层就*destptr = value;这句表达式</span><br><span class="line">    _Block_assign(src-&gt;forwarding, (void **)destp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要操作都在代码注释中了，总体来说，<code>__block</code>修饰的基本类型会被包装为对象，并且只在最初block拷贝时复制一次，后面的拷贝只会增加这个捕获变量的引用计数。</p>
<h6 id="对象的辅助函数"><a href="#对象的辅助函数" class="headerlink" title="对象的辅助函数"></a>对象的辅助函数</h6><ul>
<li>没有<code>__block</code>修饰</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^Block)();</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSObject *a = [[NSObject alloc] init];</span><br><span class="line">        Block block = ^ &#123;</span><br><span class="line">            a;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，在没有<code>__block</code>修饰时，对象编译转换的结果如下，删除了一些变化不大的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  NSObject *a = __cself-&gt;a; // bound by copy</span><br><span class="line">            a;</span><br><span class="line">        &#125;</span><br><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;a, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0),</span><br></pre></td></tr></table></figure>
<p>对象在没有<code>__block</code>修饰时，并没有产生<code>__Block_byref_a_0</code>结构体，只是将标志位修改为<code>BLOCK_FIELD_IS_OBJECT</code>。而在<code>_Block_object_assign</code>中对应的判断分支代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">else if ((flags &amp; BLOCK_FIELD_IS_OBJECT) == BLOCK_FIELD_IS_OBJECT) &#123;</span><br><span class="line">    _Block_retain_object(object);</span><br><span class="line">    _Block_assign((void *)object, destAddr);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看到，block复制时，会retain捕捉对象，以增加其引用计数。</p>
<ul>
<li>有<code>__block</code>修饰</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^Block)();</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        __block NSObject *a = [[NSObject alloc] init];</span><br><span class="line">        Block block = ^ &#123;</span><br><span class="line">            a;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，编译转换的部分结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_a_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_a_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> void (*__Block_byref_id_object_copy)(void*, void*);</span><br><span class="line"> void (*__Block_byref_id_object_dispose)(void*);</span><br><span class="line"> NSObject *a;</span><br><span class="line">&#125;;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(void*)0,(__Block_byref_a_0 *)&amp;a, 33554432, sizeof(__Block_byref_a_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131,....&#125;;</span><br><span class="line">Block block = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 以下的40表示__Block_byref_a_0对象a的位移（4个指针(32字节)＋2个int变量(8字节)＝40字节）</span><br><span class="line">static void __Block_byref_id_object_copy_131(void *dst, void *src) &#123;</span><br><span class="line"> _Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);</span><br><span class="line">&#125;</span><br><span class="line">static void __Block_byref_id_object_dispose_131(void *src) &#123;</span><br><span class="line"> _Block_object_dispose(*(void * *) ((char*)src + 40), 131);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，对于对象，<code>__Block_byref_a_0</code>另外增加了两个辅助函数<code>__Block_byref_id_object_copy</code>、<code>__Block_byref_id_object_dispose</code>,以实现对对象内存的管理。其中两者的最后一个参数<code>131</code>表示<code>BLOCK_BYREF_CALLER</code>|<code>BLOCK_FIELD_IS_OBJECT</code>，BLOCK_BYREF_CALLER表示在内部实现中不对a对象进行retain或copy；以下为相关源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if ((flags &amp; BLOCK_BYREF_CALLER) == BLOCK_BYREF_CALLER) &#123;</span><br><span class="line">    ...</span><br><span class="line">    else &#123;</span><br><span class="line">        // do *not* retain or *copy* __block variables whatever they are</span><br><span class="line">        _Block_assign((void *)object, destAddr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_Block_byref_assign_copy</code>函数的以下代码会对上面的辅助函数（__Block_byref_id_object_copy_131）进行调用；<code>570425344</code>表示<code>BLOCK_HAS_COPY_DISPOSE</code>|<code>BLOCK_HAS_DESCRIPTOR</code>，所以会执行以下相关源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (src-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) &#123;</span><br><span class="line">    // Trust copy helper to copy everything of interest</span><br><span class="line">    // If more than one field shows up in a byref block this is wrong XXX</span><br><span class="line">    copy-&gt;byref_keep = src-&gt;byref_keep;</span><br><span class="line">    copy-&gt;byref_destroy = src-&gt;byref_destroy;</span><br><span class="line">    (*src-&gt;byref_keep)(copy, src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ARC中block的工作"><a href="#ARC中block的工作" class="headerlink" title="ARC中block的工作"></a>ARC中block的工作</h2><p><img src="http://upload-images.jianshu.io/upload_images/608238-0fbaf756460d459f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p>
<p>苹果说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_NSConcreteStackBlock</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_NSConcreteMallocBlock</span><br></pre></td></tr></table></figure>
<h6 id="block试验"><a href="#block试验" class="headerlink" title="block试验"></a>block试验</h6><p>下面对block做点实验：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        int i = 10;</span><br><span class="line">        void (^block)() = ^&#123;i;&#125;;</span><br><span class="line"></span><br><span class="line">        __weak void (^weakBlock)() = ^&#123;i;&#125;;</span><br><span class="line"></span><br><span class="line">        void (^stackBlock)() = ^&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        // ARC情况下</span><br><span class="line"></span><br><span class="line">        // 创建时，都会在栈中</span><br><span class="line">        // &lt;__NSStackBlock__: 0x7fff5fbff730&gt;</span><br><span class="line">        NSLog(@&quot;%@&quot;, ^&#123;i;&#125;);</span><br><span class="line"></span><br><span class="line">        // 因为block为strong类型，且捕获了外部变量，所以赋值时，自动进行了copy</span><br><span class="line">        // &lt;__NSMallocBlock__: 0x100206920&gt;</span><br><span class="line">        NSLog(@&quot;%@&quot;, block);</span><br><span class="line"></span><br><span class="line">        // 如果是weak类型的block，依然不会自动进行copy</span><br><span class="line">        // &lt;__NSStackBlock__: 0x7fff5fbff728&gt;</span><br><span class="line">        NSLog(@&quot;%@&quot;, weakBlock);</span><br><span class="line"></span><br><span class="line">        // 如果block是strong类型，并且没有捕获外部变量，那么就会转换成__NSGlobalBlock__</span><br><span class="line">        // &lt;__NSGlobalBlock__: 0x100001110&gt;</span><br><span class="line">        NSLog(@&quot;%@&quot;, stackBlock);</span><br><span class="line"></span><br><span class="line">        // 在非ARC情况下，产生以下输出</span><br><span class="line">        // &lt;__NSStackBlock__: 0x7fff5fbff6d0&gt;</span><br><span class="line">        // &lt;__NSStackBlock__: 0x7fff5fbff730&gt;</span><br><span class="line">        // &lt;__NSStackBlock__: 0x7fff5fbff700&gt;</span><br><span class="line">        // &lt;__NSGlobalBlock__: 0x1000010d0&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，ARC对<code>类型为strong</code>且<code>捕获了外部变量</code>的block进行了copy。并且当block<code>类型为strong</code>，但是创建时<code>没有捕获外部变量</code>，block最终会变成<code>__NSGlobalBlock__</code>类型（这里可能因为block中的代码没有捕获外部变量，所以不需要在栈中开辟变量，也就是说，在<code>编译</code>时，这个block的<code>所有内容已经在代码段中生成了</code>，所以就把block的类型转换为全局类型）</p>
<h6 id="block作为参数传递"><a href="#block作为参数传递" class="headerlink" title="block作为参数传递"></a>block作为参数传递</h6><p>再来看下使用在栈中的block需要注意的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *arrayM;</span><br><span class="line">void myBlock()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 5;</span><br><span class="line">    Block block = ^ &#123;</span><br><span class="line">        NSLog(@&quot;%d&quot;, a);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    [arrayM addObject:block];</span><br><span class="line">    NSLog(@&quot;%@&quot;, block);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        arrayM = @[].mutableCopy;</span><br><span class="line"></span><br><span class="line">        myBlock();</span><br><span class="line"></span><br><span class="line">        Block block = [arrayM firstObject];</span><br><span class="line">        // 非ARC这里崩溃</span><br><span class="line">        block();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">// ARC情况下输出</span><br><span class="line">// &lt;__NSMallocBlock__: 0x100214480&gt;</span><br><span class="line"></span><br><span class="line">// 非ARC情况下输出</span><br><span class="line">// &lt;__NSStackBlock__: 0x7fff5fbff738&gt;</span><br><span class="line">// 崩溃，野指针错误</span><br></pre></td></tr></table></figure>
<p>可以看到，ARC情况下因为自动执行了copy，所以返回类型为<code>__NSMallocBlock__</code>，在函数结束后依然可以访问；而非ARC情况下，需要我们手动调用<code>[block copy]</code>来将block拷贝到堆中，否则因为栈中的block生命周期和函数中的栈生命周期关联，当函数退出后，相应的堆被销毁，block也就不存在了。<br>如果把block的以下代码删除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%d&quot;, a);</span><br></pre></td></tr></table></figure>
<p>那么block就会变成全局类型，在main中访问也不会出崩溃。</p>
<h6 id="block作为返回值"><a href="#block作为返回值" class="headerlink" title="block作为返回值"></a>block作为返回值</h6><p>在非ARC情况下，如果返回值是block，则一般这样操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return [[block copy] autorelease];</span><br></pre></td></tr></table></figure>
<p>对于外部要使用的block，更趋向于把它拷贝到堆中，使其脱离栈生命周期的约束。</p>
<h6 id="block属性"><a href="#block属性" class="headerlink" title="block属性"></a>block属性</h6><p>这里还有一点关于block类型的ARC属性。上文也说明了，ARC会自动帮<code>strong类型</code>且<code>捕获外部变量</code>的block进行copy，所以在定义block类型的属性时也可以使用strong，不一定使用copy。也就是以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/** 假如有栈block赋给以下两个属性 **/</span><br><span class="line"></span><br><span class="line">// 这里因为ARC，当栈block中会捕获外部变量时，这个block会被copy进堆中</span><br><span class="line">// 如果没有捕获外部变量，这个block会变为全局类型</span><br><span class="line">// 不管怎么样，它都脱离了栈生命周期的约束</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic) Block *strongBlock;</span><br><span class="line"></span><br><span class="line">// 这里都会被copy进堆中</span><br><span class="line">@property (copy, nonatomic) Block *copyBlock;</span><br></pre></td></tr></table></figure>
<h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p><a href="https://link.jianshu.com/?t=http://blog.devtang.com/blog/2013/07/28/a-look-inside-blocks/" target="_blank" rel="noopener">谈Objective-C Block的实现</a><br><a href="https://link.jianshu.com/?t=http://blog.csdn.net/jasonblog/article/details/7756763" target="_blank" rel="noopener">iOS中block实现的探究</a><br><a href="https://link.jianshu.com/?t=http://www.galloway.me.uk/2013/05/a-look-inside-blocks-episode-3-block-copy/" target="_blank" rel="noopener">A look inside blocks: Episode 3</a><br><a href="https://link.jianshu.com/?t=http://llvm.org/svn/llvm-project/compiler-rt/trunk/lib/BlocksRuntime/runtime.c" target="_blank" rel="noopener">runtime.c</a><br><a href="https://link.jianshu.com/?t=http://llvm.org/svn/llvm-project/compiler-rt/trunk/lib/BlocksRuntime/Block_private.h" target="_blank" rel="noopener">Block_private.h</a></p>
<h2 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h2><p><a href="https://link.jianshu.com/?t=http://clang.llvm.org/docs/Block-ABI-Apple.html" target="_blank" rel="noopener">llvm对于Block的编译规则</a><br><a href="https://link.jianshu.com/?t=https://github.com/EmbeddedSources/BlockRuntime" target="_blank" rel="noopener">ESBlockRuntime</a></p>
<p><a href="https://www.jianshu.com/p/51d04b7639f1" target="_blank" rel="noopener">转自 [<a href="https://www.jianshu.com/u/97e39e95c2cc" target="_blank" rel="noopener">tripleCC</a>]</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/14/NSString的内存问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/14/NSString的内存问题/" itemprop="url">
                  NSString的内存问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-14 14:43:42 / 修改时间：14:50:14" itemprop="dateCreated datePublished" datetime="2018-09-14T14:43:42+08:00">2018-09-14</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/内存管理/" itemprop="url" rel="index"><span itemprop="name">内存管理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>NSString 在 OC 的内存管理策略中是一个特殊的存在，因为其在编译和运行中做了一些优化处理，不同于普通对象的存在，看看下面代码打印情况（此代码测试环境为MRC，可以在ARC工程下，设置当前测试代码文件为手动内存管理，找到路径Build Phases—-&gt;Compile Sources—-&gt;XXX.m，将XXX.m的Compiler Flags设置为”-fno-objc-arc”.）：</p>
<p>//宏定义</p>
<p>#define XWLog(_var) ({ NSString *name = @#_var; NSLog(@”变量名=%@，类型=%@， 地址=%p，值=%@，引用计数=%d”, name, [_var class], _var, _var, (int)[_var retainCount]); })<br>//测试代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NSString *a = @&quot;string&quot;;</span><br><span class="line"></span><br><span class="line">NSString *b = [[NSString alloc]init];</span><br><span class="line"></span><br><span class="line">NSString *c = [[NSString alloc]initWithString:@&quot;string&quot;];</span><br><span class="line"></span><br><span class="line">NSString *d = [[NSString alloc]initWithFormat:@&quot;string&quot;];</span><br><span class="line"></span><br><span class="line">NSString *e = [NSString stringWithFormat:@&quot;string&quot;];</span><br><span class="line"></span><br><span class="line">NSString *f = [NSString stringWithFormat:@&quot;123456789&quot;];</span><br><span class="line"></span><br><span class="line">NSString *g = [NSString stringWithFormat:@&quot;1234567890&quot;];</span><br><span class="line"></span><br><span class="line">XWLog(a); XWLog(b); XWLog(c); XWLog(d); XWLog(e); XWLog(f); XWLog(g);</span><br></pre></td></tr></table></figure>
<p>//打印结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">变量名=a，类型=__NSCFConstantString， 地址=0x1015f3120，值=string，引用计数=-1</span><br><span class="line"></span><br><span class="line">变量名=b，类型=__NSCFConstantString， 地址=0x1019808d0，值=，引用计数=-1</span><br><span class="line"></span><br><span class="line">变量名=c，类型=__NSCFConstantString， 地址=0x1015f3120，值=string，引用计数=-1</span><br><span class="line"></span><br><span class="line">变量名=d，类型=NSTaggedPointerString， 地址=0xa00676e697274736，值=string，引用计数=-1</span><br><span class="line"></span><br><span class="line">变量名=e，类型=NSTaggedPointerString， 地址=0xa00676e697274736，值=string，引用计数=-1</span><br><span class="line"></span><br><span class="line">变量名=f，类型=NSTaggedPointerString， 地址=0xa1ea1f72bb30ab19，值=123456789，引用计数=-1</span><br><span class="line"></span><br><span class="line">变量名=g，类型=__NSCFString， 地址=0x60800002b580，值=1234567890，引用计数=1</span><br></pre></td></tr></table></figure>
<p>从打印结果看出，变量 b 到 f 的引用计数为-1，若是无符号格式输出，应该是一个很大的数字，与我们理解的对象初始化后引用计数为 1 所不同，不同的创建方式，字符串的类型不同，引用计数也有区别，创建的字符串有三种类型：</p>
<p><strong>NSCFConstantString
</strong>NSCFString<br>NSTaggedPointerString<br>造成这种情况是由于 OC 对 NSString 的内存优化产生的。</p>
<p><strong>NSCFConstantString<br>从字面就可以看出，这是一个常量字符串，该类型的字符串是以字面量创建的，是在编译期创建的，保存在常量区。通过 a 与 c 的打印结果看出，当创建的字符串变量值在常量区存在时，变量会指向那个字符串，这是编译期做的优化，c 指向同一字符串 @”string”，地址与a相同。<br>文字常量区存放常量字符串，程序结束后由系统释放，也就是说指向常量表的指针不受引用计数管理。所以对于NSCFConstantString类型的变量，OC 的内存管理策略对其无效。
</strong>NSCFString<br>表示这是一个对象类型的字符串，在运行时创建，存储在堆区，服从OC 的对象内存管理策略。该类型的字符串由 Format 创建，无论是实例方法还是类方法且其长度不能太小（内容若包含中文字符，不论长度大小，都是NSCFString），否则创建的是NSTaggedPointerString类型，例如上例的变量 f 与 g。</p>
<p>NSTaggedPointerString<br>对于64位程序，为了节省内存和提高运行速度，苹果引入了 Tagged Point 技术。NSTaggedPointerString是对NSCFString优化后的存在，在运行时创建时对字符串的内容和长度做出判断，若字符串内容是由ASCII字符构成且长度较小（大概十个字符以内），这时候创建的字符串就是NSTaggedPointerString类型，字符串直接存储在指针里，引用计数同样为-1，不适用对象的内存管理策略。</p>
<p>Tagged Pointer指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，OC 对象的内存管理方式对其无效。<br>现在，我们在看看这道题：</p>
<p>在MRC下，会不会造成内存泄漏？会不会奔溃？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = [[NSString alloc] initWithString:@&quot;ABC&quot;];</span><br><span class="line"></span><br><span class="line">str = @&quot;123&quot;;</span><br><span class="line"></span><br><span class="line">[str release];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;.str);</span><br></pre></td></tr></table></figure>
<p>一目了然，str指向字符串常量，对象的内存管理方式对其无效，程序结束时，系统才会销毁常量区的值。所以不会造成内存泄漏更不会奔溃。</p>
<p>接下来我们再看看NSArray的平时注意不到的问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NSArray *a1 = @[@&quot;1&quot;,@&quot;2&quot;];</span><br><span class="line"></span><br><span class="line">NSArray *a2 = [[NSArray alloc]init];</span><br><span class="line"></span><br><span class="line">NSArray *a3 = [[NSArray alloc]initWithObjects:@&quot;1&quot;, nil];</span><br><span class="line"></span><br><span class="line">NSArray *a4 = [[NSArray alloc]initWithArray:@[@&quot;a&quot;,@&quot;b&quot;]];</span><br><span class="line"></span><br><span class="line">NSArray *a5 = [NSArray arrayWithObjects:@&quot;m&quot;,@&quot;n&quot;, nil];</span><br><span class="line"></span><br><span class="line">NSArray *a6 = [[NSArray alloc]init];</span><br><span class="line"></span><br><span class="line">NSArray *a7 = @[];</span><br><span class="line"></span><br><span class="line">XWLog(a1); XWLog(a2); XWLog(a3); XWLog(a4); XWLog(a5); XWLog(a6);XWLog(a7);</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">变量名=a1，类型=__NSArrayI， 地址=0x608000029400，值=(1,2)，引用计数=1</span><br><span class="line"></span><br><span class="line">变量名=a2，类型=__NSArray0， 地址=0x618000012490，值=()，引用计数=-1</span><br><span class="line"></span><br><span class="line">变量名=a3，类型=__NSSingleObjectArrayI， 地址=0x608000012890，值=(1)，引用计数=1</span><br><span class="line"></span><br><span class="line">变量名=a4，类型=__NSArrayI， 地址=0x608000029440，值=(a,b)，引用计数=1</span><br><span class="line"></span><br><span class="line">变量名=a5，类型=__NSArrayI， 地址=0x608000029460，值=(m,n)，引用计数=1</span><br><span class="line"></span><br><span class="line">变量名=a6，类型=__NSArray0， 地址=0x618000012490，值=()，引用计数=-1</span><br><span class="line"></span><br><span class="line">变量名=a7，类型=__NSArray0， 地址=0x618000012490，值=()，引用计数=-1</span><br></pre></td></tr></table></figure>
<p>从结果看出，只有a2 a6 a7这三个的引用计数为-1，其他变量的引用计数为1，显示正常。我们仔细发现，这三个的地址相同，这就是说三个变量指向了同一块内存，说明a2 a6 a7三个创建方式创建的空实例是一个特殊值的存在，其应该存储在常量静态区。我们可以猜测，OC为了优化内存，在常量静态区创建一个空值的特殊存在，应该是静态常量对象，无论什么方式创建的空实例，其都指向静态区这个空值的。</p>
<p>不仅是NSArray，Foundation中如NSString, NSDictionary, NSSet等区分可变和不可变版本的类，空实例都是静态对象（NSString的空实例对象是常量区的@””）,对象的内存管理策略对其无效。<br>参考</p>
<p>深入理解Tagged Pointer<br>NSString内存管理<br>从NSArray看类簇</p>
<p><a href="https://www.jianshu.com/p/462adf281fde" target="_blank" rel="noopener">转自 简书<a href="https://www.jianshu.com/u/292ed4eda0e2" target="_blank" rel="noopener">懒癌重症者</a></a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/14/自动释放池/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/14/自动释放池/" itemprop="url">
                  自动释放池
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-14 14:13:09 / 修改时间：14:14:17" itemprop="dateCreated datePublished" datetime="2018-09-14T14:13:09+08:00">2018-09-14</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/内存管理/" itemprop="url" rel="index"><span itemprop="name">内存管理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="我是前言"><a href="#我是前言" class="headerlink" title="我是前言"></a>我是前言</h1><p>Autorelease机制是iOS开发者管理对象内存的好伙伴，MRC中，调用<code>[obj autorelease]</code>来延迟内存的释放是一件简单自然的事，ARC下，我们甚至可以完全不知道Autorelease就能管理好内存。而在这背后，objc和编译器都帮我们做了哪些事呢，它们是如何协作来正确管理内存的呢？刨根问底，一起来探究下黑幕背后的Autorelease机制。</p>
<h1 id="Autorelease对象什么时候释放？"><a href="#Autorelease对象什么时候释放？" class="headerlink" title="Autorelease对象什么时候释放？"></a>Autorelease对象什么时候释放？</h1><p>这个问题拿来做面试题，问过很多人，没有几个能答对的。很多答案都是“当前作用域大括号结束时释放”，显然木有正确理解Autorelease机制。<br>在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的<code>runloop</code>迭代结束时释放的，而它能够释放的原因是<strong>系统在每个runloop迭代中都加入了自动释放池Push和Pop</strong></p>
<h2 id="小实验"><a href="#小实验" class="headerlink" title="小实验"></a>小实验</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__weak id reference = nil;</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    NSString *str = [NSString stringWithFormat:@&quot;sunnyxx&quot;];</span><br><span class="line">    // str是一个autorelease对象，设置一个weak的引用来观察它</span><br><span class="line">    reference = str;</span><br><span class="line">&#125;</span><br><span class="line">- (void)viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">    [super viewWillAppear:animated];</span><br><span class="line">    NSLog(@&quot;%@&quot;, reference); // Console: sunnyxx</span><br><span class="line">&#125;</span><br><span class="line">- (void)viewDidAppear:(BOOL)animated &#123;</span><br><span class="line">    [super viewDidAppear:animated];</span><br><span class="line">    NSLog(@&quot;%@&quot;, reference); // Console: (null)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>这个实验同时也证明了<code>viewDidLoad</code>和<code>viewWillAppear</code>是在同一个runloop调用的，而<code>viewDidAppear</code>是在之后的某个runloop调用的。</del><br>由于这个vc在loadView之后便add到了window层级上，所以<code>viewDidLoad</code>和<code>viewWillAppear</code>是在同一个runloop调用的，因此在<code>viewWillAppear</code>中，这个autorelease的变量依然有值。 </p>
<p>当然，我们也可以手动干预Autorelease对象的释放时机：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSString *str = [NSString stringWithFormat:@&quot;sunnyxx&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;%@&quot;, str); // Console: (null)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Autorelease原理"><a href="#Autorelease原理" class="headerlink" title="Autorelease原理"></a>Autorelease原理</h1><h2 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h2><p>ARC下，我们使用<code>@autoreleasepool{}</code>来使用一个AutoreleasePool，随后编译器将其改写成下面的样子： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void *context = objc_autoreleasePoolPush();</span><br><span class="line">// &#123;&#125;中的代码</span><br><span class="line">objc_autoreleasePoolPop(context);</span><br></pre></td></tr></table></figure>
<p>而这两个函数都是对<code>AutoreleasePoolPage</code>的简单封装，所以自动释放机制的核心就在于这个类。 </p>
<p>AutoreleasePoolPage是一个C++实现的类</p>
<p><img src="http://ww2.sinaimg.cn/mw690/51530583gw1elj2ugt21wj20f109m3zl.jpg" alt="img"></p>
<ul>
<li>AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以<code>双向链表</code>的形式组合而成（分别对应结构中的parent指针和child指针）</li>
<li>AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程）</li>
<li>AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址</li>
<li>上面的<code>id *next</code>指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置</li>
<li>一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入</li>
</ul>
<p>所以，若当前线程中只有一个AutoreleasePoolPage对象，并记录了很多autorelease对象地址时内存如下图：</p>
<p><img src="http://ww2.sinaimg.cn/mw690/51530583gw1elj5gvphtqj20dy0cx756.jpg" alt="img"></p>
<p>图中的情况，这一页再加入一个autorelease对象就要满了（也就是next指针马上指向栈顶），这时就要执行上面说的操作，建立下一页page对象，与这一页链表连接完成后，新page的<code>next</code>指针被初始化在栈底（begin的位置），然后继续向栈顶添加新对象。</p>
<p><strong>所以，向一个对象发送- autorelease消息，就是将这个对象加入到当前AutoreleasePoolPage的栈顶next指针指向的位置</strong></p>
<h2 id="释放时刻"><a href="#释放时刻" class="headerlink" title="释放时刻"></a>释放时刻</h2><p>每当进行一次<code>objc_autoreleasePoolPush</code>调用时，runtime向当前的AutoreleasePoolPage中add进一个<code>哨兵对象</code>，值为0（也就是个nil），那么这一个page就变成了下面的样子： </p>
<p><img src="http://ww2.sinaimg.cn/large/51530583gw1elj5z7hawej20ji0dewff.jpg" alt="img"></p>
<p><code>objc_autoreleasePoolPush</code>的返回值正是这个哨兵对象的地址，被<code>objc_autoreleasePoolPop(哨兵对象)</code>作为入参，于是：</p>
<ol>
<li>根据传入的哨兵对象地址找到哨兵对象所处的page</li>
<li>在当前page中，将晚于哨兵对象插入的所有autorelease对象都发送一次<code>- release</code>消息，并向回移动<code>next</code>指针到正确位置</li>
<li>补充2：从最新加入的对象一直向前清理，可以向前跨越若干个page，直到哨兵所在的page</li>
</ol>
<p>刚才的objc_autoreleasePoolPop执行后，最终变成了下面的样子： </p>
<p><img src="http://ww3.sinaimg.cn/mw690/51530583gw1elj6u2i3fyj20dz0bqdgi.jpg" alt="img"></p>
<h2 id="嵌套的AutoreleasePool"><a href="#嵌套的AutoreleasePool" class="headerlink" title="嵌套的AutoreleasePool"></a>嵌套的AutoreleasePool</h2><p>知道了上面的原理，嵌套的AutoreleasePool就非常简单了，pop的时候总会释放到上次push的位置为止，多层的pool就是多个哨兵对象而已，就像剥洋葱一样，每次一层，互不影响。</p>
<hr>
<p>【附加内容】</p>
<h1 id="Autorelease返回值的快速释放机制"><a href="#Autorelease返回值的快速释放机制" class="headerlink" title="Autorelease返回值的快速释放机制"></a>Autorelease返回值的快速释放机制</h1><p>值得一提的是，ARC下，runtime有一套对autorelease返回值的优化策略。<br>比如一个工厂方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)createSark &#123;</span><br><span class="line">    return [self new];</span><br><span class="line">&#125;</span><br><span class="line">// caller</span><br><span class="line">Sark *sark = [Sark createSark];</span><br></pre></td></tr></table></figure>
<p>秉着谁创建谁释放的原则，返回值需要是一个autorelease对象才能配合调用方正确管理内存，于是乎编译器改写成了形如下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)createSark &#123;</span><br><span class="line">    id tmp = [self new];</span><br><span class="line">    return objc_autoreleaseReturnValue(tmp); // 代替我们调用autorelease</span><br><span class="line">&#125;</span><br><span class="line">// caller</span><br><span class="line">id tmp = objc_retainAutoreleasedReturnValue([Sark createSark]) // 代替我们调用retain</span><br><span class="line">Sark *sark = tmp;</span><br><span class="line">objc_storeStrong(&amp;sark, nil); // 相当于代替我们调用了release</span><br></pre></td></tr></table></figure>
<p>一切看上去都很好，不过既然编译器知道了这么多信息，干嘛还要劳烦autorelease这个开销不小的机制呢？于是乎，runtime使用了一些黑魔法将这个问题解决了。</p>
<h2 id="黑魔法之Thread-Local-Storage"><a href="#黑魔法之Thread-Local-Storage" class="headerlink" title="黑魔法之Thread Local Storage"></a>黑魔法之Thread Local Storage</h2><p>Thread Local Storage（TLS）线程局部存储，目的很简单，将一块内存作为某个线程专有的存储，以key-value的形式进行读写，比如在非arm架构下，使用pthread提供的方法实现： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void* pthread_getspecific(pthread_key_t);</span><br><span class="line">int pthread_setspecific(pthread_key_t , const void *);</span><br></pre></td></tr></table></figure>
<p>说它是黑魔法可能被懂pthread的笑话- - </p>
<p>在返回值身上调用<code>objc_autoreleaseReturnValue</code>方法时，runtime将这个返回值object储存在TLS中，然后直接返回这个object（不调用autorelease）；同时，在外部接收这个返回值的<code>objc_retainAutoreleasedReturnValue</code>里，发现TLS中正好存了这个对象，那么直接返回这个object（不调用retain）。<br>于是乎，调用方和被调方利用TLS做中转，很有默契的免去了对返回值的内存管理。 </p>
<p>于是问题又来了，假如被调方和主调方只有一边是ARC环境编译的该咋办？（比如我们在ARC环境下用了非ARC编译的第三方库，或者反之）<br>只能动用更高级的黑魔法。 </p>
<h2 id="黑魔法之-builtin-return-address"><a href="#黑魔法之-builtin-return-address" class="headerlink" title="黑魔法之__builtin_return_address"></a>黑魔法之__builtin_return_address</h2><p>这个内建函数原型是<code>char *__builtin_return_address(int level)</code>，作用是得到函数的返回地址，参数表示层数，如__builtin_return_address(0)表示当前函数体返回地址，传1是调用这个函数的外层函数的返回值地址，以此类推。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (int)foo &#123;</span><br><span class="line">    NSLog(@&quot;%p&quot;, __builtin_return_address(0)); // 根据这个地址能找到下面ret的地址</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">// caller</span><br><span class="line">int ret = [sark foo];</span><br></pre></td></tr></table></figure>
<p>看上去也没啥厉害的，不过要知道，函数的返回值地址，也就对应着调用者结束这次调用的地址（或者相差某个固定的偏移量，根据编译器决定）<br>也就是说，被调用的函数也有翻身做地主的机会了，可以反过来对主调方干点坏事。<br>回到上面的问题，<strong>如果一个函数返回前知道调用方是ARC还是非ARC，就有机会对于不同情况做不同的处理</strong></p>
<h2 id="黑魔法之反查汇编指令"><a href="#黑魔法之反查汇编指令" class="headerlink" title="黑魔法之反查汇编指令"></a>黑魔法之反查汇编指令</h2><p>通过上面的__builtin_return_address加某些偏移量，被调方可以定位到主调方在返回值后面的<code>汇编指令</code>： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// caller</span><br><span class="line">int ret = [sark foo];</span><br><span class="line">// 内存中接下来的汇编指令（x86，我不懂汇编，瞎写的）</span><br><span class="line">movq ??? ???</span><br><span class="line">callq ???</span><br></pre></td></tr></table></figure>
<p>而这些汇编指令在内存中的值是固定的，比如movq对应着0x48。<br>于是乎，就有了下面的这个函数，入参是调用方__builtin_return_address传入值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static bool callerAcceptsFastAutorelease(const void * const ra0) &#123;</span><br><span class="line">    const uint8_t *ra1 = (const uint8_t *)ra0;</span><br><span class="line">    const uint16_t *ra2;</span><br><span class="line">    const uint32_t *ra4 = (const uint32_t *)ra1;</span><br><span class="line">    const void **sym;</span><br><span class="line">    // 48 89 c7    movq  %rax,%rdi</span><br><span class="line">    // e8          callq symbol</span><br><span class="line">    if (*ra4 != 0xe8c78948) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    ra1 += (long)*(const int32_t *)(ra1 + 4) + 8l;</span><br><span class="line">    ra2 = (const uint16_t *)ra1;</span><br><span class="line">    // ff 25       jmpq *symbol@DYLDMAGIC(%rip)</span><br><span class="line">    if (*ra2 != 0x25ff) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    ra1 += 6l + (long)*(const int32_t *)(ra1 + 2);</span><br><span class="line">    sym = (const void **)ra1;</span><br><span class="line">    if (*sym != objc_retainAutoreleasedReturnValue)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它检验了主调方在返回值之后是否紧接着调用了<code>objc_retainAutoreleasedReturnValue</code>，如果是，就知道了外部是ARC环境，反之就走没被优化的老逻辑。</p>
<h1 id="其他Autorelease相关知识点"><a href="#其他Autorelease相关知识点" class="headerlink" title="其他Autorelease相关知识点"></a>其他Autorelease相关知识点</h1><p>使用容器的block版本的枚举器时，内部会自动添加一个AutoreleasePool： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123;</span><br><span class="line">    // 这里被一个局部@autoreleasepool包围着</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>当然，在普通for循环和for in循环中没有，所以，还是新版的block版本枚举器更加方便。for循环中遍历产生大量autorelease变量时，就需要手加局部AutoreleasePool咯。</p>
<p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">转自</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/14/iOS底层解析weak的实现原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/14/iOS底层解析weak的实现原理/" itemprop="url">
                  iOS底层解析weak的实现原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-14 12:31:00 / 修改时间：13:54:01" itemprop="dateCreated datePublished" datetime="2018-09-14T12:31:00+08:00">2018-09-14</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/内存管理/" itemprop="url" rel="index"><span itemprop="name">内存管理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>很少有人知道weak表其实是一个hash（哈希）表，Key是所指对象的地址，Value是weak指针的地址数组。更多人的人只是知道weak是弱引用，所引用对象的计数器不会加一，并在引用对象被释放的时候自动被设置为nil。通常用于解决循环引用问题。但现在单知道这些已经不足以应对面试了，好多公司会问weak的原理。weak的原理是什么呢？下面就分析一下weak的工作原理（只是自己对这个问题好奇，学习过程中的笔记，希望对读者也有所帮助）。</p>
<h1 id="weak-实现原理的概括"><a href="#weak-实现原理的概括" class="headerlink" title="weak 实现原理的概括"></a>weak 实现原理的概括</h1><p>Runtime维护了一个weak表，用于存储指向某个对象的所有weak指针。weak表其实是一个hash（哈希）表，Key是所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象指针的地址）数组。</p>
<h2 id="weak-的实现原理可以概括一下三步："><a href="#weak-的实现原理可以概括一下三步：" class="headerlink" title="weak 的实现原理可以概括一下三步："></a>weak 的实现原理可以概括一下三步：</h2><p>1、初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。<br>2、添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。<br>3、释放时，调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。</p>
<h3 id="下面将开始详细介绍每一步："><a href="#下面将开始详细介绍每一步：" class="headerlink" title="下面将开始详细介绍每一步："></a>下面将开始详细介绍每一步：</h3><h4 id="初始化时：runtime会调用objc-initWeak函数，objc-initWeak函数会初始化一个新的weak指针指向对象的地址。"><a href="#初始化时：runtime会调用objc-initWeak函数，objc-initWeak函数会初始化一个新的weak指针指向对象的地址。" class="headerlink" title="初始化时：runtime会调用objc_initWeak函数，objc_initWeak函数会初始化一个新的weak指针指向对象的地址。"></a>初始化时：runtime会调用objc_initWeak函数，objc_initWeak函数会初始化一个新的weak指针指向对象的地址。</h4><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    NSObject *obj = [[NSObject alloc] init];</span><br><span class="line">    id __weak obj1 = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们初始化一个weak变量时，runtime会调用 NSObject.mm 中的objc_initWeak函数。这个函数在Clang中的声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_initWeak(id *object, id value);</span><br></pre></td></tr></table></figure>
<p>而对于 objc_initWeak() 方法的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">id objc_initWeak(id *location, id newObj) &#123;</span><br><span class="line">// 查看对象实例是否有效</span><br><span class="line">// 无效对象直接导致指针释放</span><br><span class="line">    if (!newObj) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    // 这里传递了三个 bool 数值</span><br><span class="line">    // 使用 template 进行常量参数传递是为了优化性能</span><br><span class="line">    return storeWeakfalse/*old*/, true/*new*/, true/*crash*/&gt;</span><br><span class="line">    (location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，这个函数仅仅是一个深层函数的调用入口，而一般的入口函数中，都会做一些简单的判断（例如 objc_msgSend 中的缓存判断），这里判断了其指针指向的类对象是否有效，无效直接释放，不再往深层调用函数。否则，object将被注册为一个指向value的__weak对象。而这事应该是objc_storeWeak函数干的。</p>
<p>注意：<em>objc_initWeak函数有一个前提条件：就是object必须是一个没有被注册为__weak对象的有效指针。而value则可以是null，或者指向一个有效的对象。</em></p>
<h4 id="添加引用时：objc-initWeak函数会调用-objc-storeWeak-函数，-objc-storeWeak-的作用是更新指针指向，创建对应的弱引用表。"><a href="#添加引用时：objc-initWeak函数会调用-objc-storeWeak-函数，-objc-storeWeak-的作用是更新指针指向，创建对应的弱引用表。" class="headerlink" title="添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。"></a>添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。</h4><p>objc_storeWeak的函数声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_storeWeak(id *location, id value);</span><br></pre></td></tr></table></figure>
<p>objc_storeWeak() 的具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">// HaveOld:  true - 变量有值</span><br><span class="line">//          false - 需要被及时清理，当前值可能为 nil</span><br><span class="line">// HaveNew:  true - 需要被分配的新值，当前值可能为 nil</span><br><span class="line">//          false - 不需要分配新值</span><br><span class="line">// CrashIfDeallocating: true - 说明 newObj 已经释放或者 newObj 不支持弱引用，该过程需要暂停</span><br><span class="line">//          false - 用 nil 替代存储</span><br><span class="line">template bool HaveOld, bool HaveNew, bool CrashIfDeallocating&gt;</span><br><span class="line">static id storeWeak(id *location, objc_object *newObj) &#123;</span><br><span class="line">    // 该过程用来更新弱引用指针的指向</span><br><span class="line">    // 初始化 previouslyInitializedClass 指针</span><br><span class="line">    Class previouslyInitializedClass = nil;</span><br><span class="line">    id oldObj;</span><br><span class="line">    // 声明两个 SideTable</span><br><span class="line">    // ① 新旧散列创建</span><br><span class="line">    SideTable *oldTable;</span><br><span class="line">    SideTable *newTable;</span><br><span class="line">    // 获得新值和旧值的锁存位置（用地址作为唯一标示）</span><br><span class="line">    // 通过地址来建立索引标志，防止桶重复</span><br><span class="line">    // 下面指向的操作会改变旧值</span><br><span class="line">retry:</span><br><span class="line">    if (HaveOld) &#123;</span><br><span class="line">        // 更改指针，获得以 oldObj 为索引所存储的值地址</span><br><span class="line">        oldObj = *location;</span><br><span class="line">        oldTable = &amp;SideTables()[oldObj];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        oldTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    if (HaveNew) &#123;</span><br><span class="line">        // 更改新值指针，获得以 newObj 为索引所存储的值地址</span><br><span class="line">        newTable = &amp;SideTables()[newObj];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        newTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    // 加锁操作，防止多线程中竞争冲突</span><br><span class="line">    SideTable::lockTwoHaveOld, HaveNew&gt;(oldTable, newTable);</span><br><span class="line">    // 避免线程冲突重处理</span><br><span class="line">    // location 应该与 oldObj 保持一致，如果不同，说明当前的 location 已经处理过 oldObj 可是又被其他线程所修改</span><br><span class="line">    if (HaveOld  &amp;&amp;  *location != oldObj) &#123;</span><br><span class="line">        SideTable::unlockTwoHaveOld, HaveNew&gt;(oldTable, newTable);</span><br><span class="line">        goto retry;</span><br><span class="line">    &#125;</span><br><span class="line">    // 防止弱引用间死锁</span><br><span class="line">    // 并且通过 +initialize 初始化构造器保证所有弱引用的 isa 非空指向</span><br><span class="line">    if (HaveNew  &amp;&amp;  newObj) &#123;</span><br><span class="line">        // 获得新对象的 isa 指针</span><br><span class="line">        Class cls = newObj-&gt;getIsa();</span><br><span class="line">        // 判断 isa 非空且已经初始化</span><br><span class="line">        if (cls != previouslyInitializedClass  &amp;&amp;</span><br><span class="line">            !((objc_class *)cls)-&gt;isInitialized()) &#123;</span><br><span class="line">            // 解锁</span><br><span class="line">            SideTable::unlockTwoHaveOld, HaveNew&gt;(oldTable, newTable);</span><br><span class="line">            // 对其 isa 指针进行初始化</span><br><span class="line">            _class_initialize(_class_getNonMetaClass(cls, (id)newObj));</span><br><span class="line">            // 如果该类已经完成执行 +initialize 方法是最理想情况</span><br><span class="line">            // 如果该类 +initialize 在线程中</span><br><span class="line">            // 例如 +initialize 正在调用 storeWeak 方法</span><br><span class="line">            // 需要手动对其增加保护策略，并设置 previouslyInitializedClass 指针进行标记</span><br><span class="line">            previouslyInitializedClass = cls;</span><br><span class="line">            // 重新尝试</span><br><span class="line">            goto retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // ② 清除旧值</span><br><span class="line">    if (HaveOld) &#123;</span><br><span class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    &#125;</span><br><span class="line">    // ③ 分配新值</span><br><span class="line">    if (HaveNew) &#123;</span><br><span class="line">        newObj = (objc_object *)weak_register_no_lock(&amp;newTable-&gt;weak_table,</span><br><span class="line">                                                      (id)newObj, location,</span><br><span class="line">                                                      CrashIfDeallocating);</span><br><span class="line">        // 如果弱引用被释放 weak_register_no_lock 方法返回 nil</span><br><span class="line">        // 在引用计数表中设置若引用标记位</span><br><span class="line">        if (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">            // 弱引用位初始化操作</span><br><span class="line">            // 引用计数那张散列表的weak引用对象的引用计数中标识为weak引用</span><br><span class="line">            newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">        // 之前不要设置 location 对象，这里需要更改指针指向</span><br><span class="line">        *location = (id)newObj;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        // 没有新值，则无需更改</span><br><span class="line">    &#125;</span><br><span class="line">    SideTable::unlockTwoHaveOld, HaveNew&gt;(oldTable, newTable);</span><br><span class="line">    return (id)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>撇开源码中各种锁操作，来看看这段代码都做了些什么。</p>
<h5 id="SideTable"><a href="#SideTable" class="headerlink" title="SideTable"></a>SideTable</h5><p>SideTable 这个结构体，我给他起名引用计数和弱引用依赖表，因为它主要用于管理对象的引用计数和 weak 表。在 NSObject.mm 中声明其数据结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct SideTable &#123;</span><br><span class="line">// 保证原子操作的自旋锁</span><br><span class="line">    spinlock_t slock;</span><br><span class="line">    // 引用计数的 hash 表</span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    // weak 引用全局 hash 表</span><br><span class="line">    weak_table_t weak_table;</span><br></pre></td></tr></table></figure>
<p>}<br>对于 slock 和 refcnts 两个成员不用多说，第一个是为了防止竞争选择的自旋锁，第二个是协助对象的 isa 指针的 extra_rc 共同引用计数的变量（对于对象结果，在今后的文中提到）。这里主要看 weak 全局 hash 表的结构与作用。</p>
<h5 id="weak表"><a href="#weak表" class="headerlink" title="weak表"></a>weak表</h5><p>weak表是一个弱引用表，实现为一个weak_table_t结构体，存储了某个对象相关的的所有的弱引用信息。其定义如下(具体定义在<a href="https://link.jianshu.com/?t=https://opensource.apple.com/source/objc4/objc4-646/runtime/objc-weak.h" target="_blank" rel="noopener">objc-weak.h</a>中)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   struct weak_table_t &#123;</span><br><span class="line">    // 保存了所有指向指定对象的 weak 指针</span><br><span class="line">    weak_entry_t *weak_entries;</span><br><span class="line">    // 存储空间</span><br><span class="line">    size_t    num_entries;</span><br><span class="line">    // 参与判断引用计数辅助量</span><br><span class="line">    uintptr_t mask;</span><br><span class="line">    // hash key 最大偏移值</span><br><span class="line">    uintptr_t max_hash_displacement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是一个全局弱引用hash表。使用不定类型对象的地址作为 key ，用 weak_entry_t 类型结构体对象作为 value 。其中的 weak_entries 成员，从字面意思上看，即为弱引用表入口。其实现也是这样的。</p>
<p>其中weak_entry_t是存储在弱引用表中的一个内部结构体，它负责维护和存储指向一个对象的所有弱引用hash表。其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef objc_object ** weak_referrer_t;</span><br><span class="line">struct weak_entry_t &#123;</span><br><span class="line">    DisguisedPtrobjc_object&gt; referent;</span><br><span class="line">    union &#123;</span><br><span class="line">        struct &#123;</span><br><span class="line">            weak_referrer_t *referrers;</span><br><span class="line">            uintptr_t        out_of_line : 1;</span><br><span class="line">            uintptr_t        num_refs : PTR_MINUS_1;</span><br><span class="line">            uintptr_t        mask;</span><br><span class="line">            uintptr_t        max_hash_displacement;</span><br><span class="line">        &#125;;</span><br><span class="line">        struct &#123;</span><br><span class="line">            // out_of_line=0 is LSB of one of these (don&apos;t care which)</span><br><span class="line">            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 weak_entry_t 的结构中，DisguisedPtr referent 是对泛型对象的指针做了一个封装，通过这个泛型类来解决内存泄漏的问题。从注释中写 out_of_line 成员为最低有效位，当其为0的时候， weak_referrer_t 成员将扩展为多行静态 hash table。其实其中的 weak_referrer_t 是二维 objc_object 的别名，通过一个二维指针地址偏移，用下标作为 hash 的 key，做成了一个弱引用散列。<br>那么在有效位未生效的时候，out_of_line 、 num_refs、 mask 、 max_hash_displacement 有什么作用？以下是笔者自身的猜测：</p>
<p>out_of_line：最低有效位，也是标志位。当标志位 0 时，增加引用表指针纬度。<br>num_refs：引用数值。这里记录弱引用表中引用有效数字，因为弱引用表使用的是静态 hash 结构，所以需要使用变量来记录数目。<br>mask：计数辅助量。<br>max_hash_displacement：hash 元素上限阀值。<br>其实 out_of_line 的值通常情况下是等于零的，所以弱引用表总是一个 objc_objective 指针二维数组。一维 objc_objective 指针可构成一张弱引用散列表，通过第三纬度实现了多张散列表，并且表数量为 WEAK_INLINE_COUNT 。</p>
<p>总结一下 StripedMap[] ： StripedMap 是一个模板类，在这个类中有一个 array 成员，用来存储 PaddedT 对象，并且其中对于 [] 符的重载定义中，会返回这个 PaddedT 的 value 成员，这个 value 就是我们传入的 T 泛型成员，也就是 SideTable 对象。在 array 的下标中，这里使用了 indexForPointer 方法通过位运算计算下标，实现了静态的 Hash Table。而在 weak_table 中，其成员 weak_entry 会将传入对象的地址加以封装起来，并且其中也有访问全局弱引用表的入口。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1204112-3b57375cebb02aee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="img"></p>
<p>31B622B5-77ED-4D50-8CF9-0803785117BC.png</p>
<h5 id="旧对象解除注册操作-weak-unregister-no-lock"><a href="#旧对象解除注册操作-weak-unregister-no-lock" class="headerlink" title="旧对象解除注册操作 weak_unregister_no_lock"></a>旧对象解除注册操作 weak_unregister_no_lock</h5><p>该方法主要作用是将旧对象在 weak_table 中接触 weak 指针的对应绑定。根据函数名，称之为解除注册操作。从源码中，可以知道其功能就是从 weak_table 中接触 weak 指针的绑定。而其中的遍历查询，就是针对于 weak_entry 中的多张弱引用散列表。</p>
<h5 id="新对象添加注册操作-weak-register-no-lock"><a href="#新对象添加注册操作-weak-register-no-lock" class="headerlink" title="新对象添加注册操作 weak_register_no_lock"></a>新对象添加注册操作 weak_register_no_lock</h5><p>这一步与上一步相反，通过 weak_register_no_lock 函数把心的对象进行注册操作，完成与对应的弱引用表进行绑定操作。</p>
<h1 id="初始化弱引用对象流程一览"><a href="#初始化弱引用对象流程一览" class="headerlink" title="初始化弱引用对象流程一览"></a>初始化弱引用对象流程一览</h1><p>弱引用的初始化，从上文的分析中可以看出，主要的操作部分就在弱引用表的取键、查询散列、创建弱引用表等操作，可以总结出如下的流程图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1204112-4deeaa2c414b5350.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/553" alt="img"></p>
<p>C6029C92-5145-4334-9C25-3CDBA50F142B.png</p>
<p>这个图中省略了很多情况的判断，但是当声明一个 <strong>weak 会调用上图中的这些方法。当然， storeWeak 方法不仅仅用在 </strong>weak 的声明中，在 class 内部的操作中也会常常通过该方法来对 weak 对象进行操作。</p>
<h2 id="释放时，调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。"><a href="#释放时，调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。" class="headerlink" title="# 释放时，调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。"></a># 释放时，调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。</h2><h4 id="当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？当释放对象时，其基本流程如下："><a href="#当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？当释放对象时，其基本流程如下：" class="headerlink" title="当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？当释放对象时，其基本流程如下："></a>当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？当释放对象时，其基本流程如下：</h4><p>1、调用objc_release<br>2、因为对象的引用计数为0，所以执行dealloc<br>3、在dealloc中，调用了_objc_rootDealloc函数<br>4、在_objc_rootDealloc中，调用了object_dispose函数<br>5、调用objc_destructInstance<br>6、最后调用objc_clear_deallocating</p>
<p>重点看对象被释放时调用的objc_clear_deallocating函数。该函数实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void  objc_clear_deallocating(id obj) </span><br><span class="line">&#123;</span><br><span class="line">    assert(obj);</span><br><span class="line">    assert(!UseGC);</span><br><span class="line">    if (obj-&gt;isTaggedPointer()) return;</span><br><span class="line">   obj-&gt;clearDeallocating();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是调用了clearDeallocating，继续追踪可以发现，它最终是使用了迭代器来取weak表的value，然后调用weak_clear_no_lock,然后查找对应的value，将该weak指针置空，weak_clear_no_lock函数的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Called by dealloc; nils out all weak pointers that point to the</span><br><span class="line"> * provided object so that they can no longer be used.</span><br><span class="line"> *</span><br><span class="line"> * @param weak_table</span><br><span class="line"> * @param referent The object being deallocated.</span><br><span class="line"> */</span><br><span class="line">void weak_clear_no_lock(weak_table_t *weak_table, id referent_id)</span><br><span class="line">&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    weak_entry_t *entry = weak_entry_for_referent(weak_table, referent);</span><br><span class="line">    if (entry == nil) &#123;</span><br><span class="line">        /// XXX shouldn&apos;t happen, but does with mismatched CF/objc</span><br><span class="line">        //printf(&quot;XXX no entry for clear deallocating %p\n&quot;, referent);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // zero out references</span><br><span class="line">    weak_referrer_t *referrers;</span><br><span class="line">    size_t count;</span><br><span class="line">    </span><br><span class="line">    if (entry-&gt;out_of_line) &#123;</span><br><span class="line">        referrers = entry-&gt;referrers;</span><br><span class="line">        count = TABLE_SIZE(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        referrers = entry-&gt;inline_referrers;</span><br><span class="line">        count = WEAK_INLINE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (size_t i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">        objc_object **referrer = referrers[i];</span><br><span class="line">        if (referrer) &#123;</span><br><span class="line">            if (*referrer == referent) &#123;</span><br><span class="line">                *referrer = nil;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (*referrer) &#123;</span><br><span class="line">                _objc_inform(&quot;__weak variable at %p holds %p instead of %p. &quot;</span><br><span class="line">                             &quot;This is probably incorrect use of &quot;</span><br><span class="line">                             &quot;objc_storeWeak() and objc_loadWeak(). &quot;</span><br><span class="line">                             &quot;Break on objc_weak_error to debug.\n&quot;,</span><br><span class="line">                             referrer, (void*)*referrer, (void*)referent);</span><br><span class="line">                objc_weak_error();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    weak_entry_remove(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objc_clear_deallocating该函数的动作如下：</p>
<p>1、从weak表中获取废弃对象的地址为键值的记录<br>2、将包含在记录中的所有附有 weak修饰符变量的地址，赋值为nil<br>3、将weak表中该记录删除<br>4、从引用计数表中删除废弃对象的地址为键值的记录</p>
<p>看了objc-weak.mm的源码就明白了：其实Weak表是一个hash（哈希）表，然后里面的key是指向对象的地址，Value是Weak指针的地址的数组。</p>
<h2 id="补充：-m和-mm的区别"><a href="#补充：-m和-mm的区别" class="headerlink" title="补充：.m和.mm的区别"></a>补充：.m和.mm的区别</h2><p>.m：源代码文件，这个典型的源代码文件扩展名，可以包含OC和C代码。<br>.mm：源代码文件，带有这种扩展名的源代码文件，除了可以包含OC和C代码之外，还可以包含C++代码。仅在你的OC代码中确实需要使用C++类或者特性的时候才用这种扩展名。</p>
<p>参考资料：<br><a href="https://link.jianshu.com/?t=http://ios.jobbole.com/89012/" target="_blank" rel="noopener">weak 弱引用的实现方式</a><br><a href="https://link.jianshu.com/?t=http://www.cocoachina.com/ios/20150605/11990.html" target="_blank" rel="noopener">weak的生命周期：具体实现方法</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/14/从NSObject的初始化了解isa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/14/从NSObject的初始化了解isa/" itemprop="url">
                  从NSObject的初始化了解isa
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-14 12:09:33 / 修改时间：12:10:50" itemprop="dateCreated datePublished" datetime="2018-09-14T12:09:33+08:00">2018-09-14</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/内存管理/" itemprop="url" rel="index"><span itemprop="name">内存管理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 <code>x86_64</code> 架构下运行的，对于在 arm64 中运行的代码会特别说明。</p>
</blockquote>
<p>如果你曾经对 ObjC 底层的实现有一定的了解，你应该会知道 <strong>Objective-C 对象都是 C 语言结构体</strong>，所有的对象都包含一个类型为  <code>isa</code> 的指针，那么你可能确实对 ObjC 的底层有所知，不过现在的 ObjC 对象的结构已经不是这样了。代替 <code>isa</code> 指针的是结构体 <code>isa_t</code>, 这个结构体中”包含”了当前对象指向的类的信息，这篇文章中会介绍一些关于这个变化的知识。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">    isa_t isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当 ObjC 为一个对象分配内存，初始化实例变量后，在这些对象的实例变量的结构体中的第一个就是 <code>isa</code>。</p>
<p><a href="https://github.com/Draveness/analyze/blob/master/contents/images/objc-isa-class-object.png" target="_blank" rel="noopener"><img src="https://github.com/Draveness/analyze/raw/master/contents/images/objc-isa-class-object.png" alt="objc-isa-class-object"></a></p>
<blockquote>
<p>所有继承自 <code>NSObject</code> 的类实例化后的对象都会包含一个类型为 <code>isa_t</code> 的结构体。</p>
</blockquote>
<p>从上图中可以看出，不只是<strong>实例</strong>会包含一个 <code>isa</code> 结构体，所有的<strong>类</strong>也有这么一个 <code>isa</code>。在 ObjC 中 Class 的定义也是一个名为 <code>objc_class</code> 的结构体，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    isa_t isa;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;</span><br><span class="line">    class_data_bits_t bits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于 <code>objc_class</code> 结构体是继承自 <code>objc_object</code> 的，所以在这里显式地写出了 <code>isa_t isa</code> 这个成员变量。</p>
</blockquote>
<h2 id="isa-指针的作用与元类"><a href="#isa-指针的作用与元类" class="headerlink" title="isa 指针的作用与元类"></a><code>isa</code> 指针的作用与元类</h2><p>到这里，我们就明白了：<strong>Objective-C 中类也是一个对象</strong>。</p>
<p>这个 <code>isa</code> 包含了什么呢？回答这个问题之前，要引入了另一个概念 <em>元类(meta class)</em>，我们先了解一些关于元类的信息。</p>
<p>因为在 Objective-C 中，对象的方法并<strong>没有存储于对象的结构体中</strong>（如果每一个对象都保存了自己能执行的方法，那么对内存的占用有极大的影响）。</p>
<p>当<strong>实例方法</strong>被调用时，它要通过自己持有的 <code>isa</code> 来查找对应的类，然后在这里的 <code>class_data_bits_t</code> 结构体中查找对应方法的实现。同时，每一个 <code>objc_class</code> 也有一个<strong>指向自己的父类的指针</strong> <code>super_class</code> 用来查找继承的方法。</p>
<blockquote>
<p>关于如何在 <code>class_data_bits_t</code> 中查找对应方法会在之后的文章中讲到。这里只需要知道，它会在这个结构体中查找到对应方法的实现就可以了。<a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20ObjC%20%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84.md" target="_blank" rel="noopener">深入解析 ObjC 中方法的结构</a></p>
</blockquote>
<p><a href="https://github.com/Draveness/analyze/blob/master/contents/images/objc-isa-class-pointer.png" target="_blank" rel="noopener"><img src="https://github.com/Draveness/analyze/raw/master/contents/images/objc-isa-class-pointer.png" alt="objc-isa-class-pointer"></a></p>
<p>但是，这样就有一个问题，类方法的实现又是如何查找并且调用的呢？这时，就需要引入<em>元类</em>来保证无论是类还是对象都能<strong>通过相同的机制查找方法的实现</strong>。</p>
<p><a href="https://github.com/Draveness/analyze/blob/master/contents/images/objc-isa-meta-class.png" target="_blank" rel="noopener"><img src="https://github.com/Draveness/analyze/raw/master/contents/images/objc-isa-meta-class.png" alt="objc-isa-meta-class"></a></p>
<p>让每一个类的 <code>isa</code> 指向对应的元类，这样就达到了使类方法和实例方法的调用机制相同的目的：</p>
<ul>
<li>实例方法调用时，通过对象的 <code>isa</code> 在类中获取方法的实现</li>
<li>类方法调用时，通过类的 <code>isa</code> 在元类中获取方法的实现</li>
</ul>
<p>下面这张图介绍了对象，类与元类之间的关系，笔者认为已经觉得足够清晰了，所以不在赘述。</p>
<p><a href="https://github.com/Draveness/analyze/blob/master/contents/images/objc-isa-class-diagram.png" target="_blank" rel="noopener"><img src="https://github.com/Draveness/analyze/raw/master/contents/images/objc-isa-class-diagram.png" alt="img"></a></p>
<blockquote>
<p>图片来自 <a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" target="_blank" rel="noopener">objc_explain_Classes_and_metaclasses</a></p>
</blockquote>
<p>有关与介绍类与元类之间的关系的文章实在是太多了，因为这篇文章主要介绍 <code>isa</code>，在这一小节只是对其作用以及元类的概念进行介绍。如果想要了解更多关于类与元类的信息，可以看 <a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html" target="_blank" rel="noopener">What is a meta-class in Objective-C?</a></p>
<h2 id="结构体-isa-t"><a href="#结构体-isa-t" class="headerlink" title="结构体 isa_t"></a>结构体 <code>isa_t</code></h2><p>其实 <code>isa_t</code> 是一个定义得非常”奇怪”的结构体，在 ObjC 源代码中可以看到这样的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#define ISA_MASK        0x00007ffffffffff8ULL</span><br><span class="line">#define ISA_MAGIC_MASK  0x001f800000000001ULL</span><br><span class="line">#define ISA_MAGIC_VALUE 0x001d800000000001ULL</span><br><span class="line">#define RC_ONE   (1ULL&lt;&lt;56)</span><br><span class="line">#define RC_HALF  (1ULL&lt;&lt;7)</span><br><span class="line"></span><br><span class="line">union isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"></span><br><span class="line">    struct &#123;</span><br><span class="line">        uintptr_t indexed           : 1;</span><br><span class="line">        uintptr_t has_assoc         : 1;</span><br><span class="line">        uintptr_t has_cxx_dtor      : 1;</span><br><span class="line">        uintptr_t shiftcls          : 44;</span><br><span class="line">        uintptr_t magic             : 6;</span><br><span class="line">        uintptr_t weakly_referenced : 1;</span><br><span class="line">        uintptr_t deallocating      : 1;</span><br><span class="line">        uintptr_t has_sidetable_rc  : 1;</span><br><span class="line">        uintptr_t extra_rc          : 8;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是在 <code>__x86_64__</code> 上的实现，对于 iPhone5s 等架构为 <code>__arm64__</code> 的设备上，具体结构体的实现和位数可能有些差别，不过这些字段都是存在的，可以看这里的 <a href="https://github.com/Draveness/analyze/blob/master/contents/objc/%E4%BB%8E%20NSObject%20%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%86%E8%A7%A3%20isa.md#arm64" target="_blank" rel="noopener">arm64 上结构体的实现</a></p>
</blockquote>
<p><strong>在本篇文章中, 我们会以 <strong>x86_64</strong> 为例进行分析，而不会对两种架构下由于不同的内存布局方式导致的差异进行分析</strong>。在我看来，这个细节不会影响对 <code>isa</code> 指针的理解，不过还是要知道的。</p>
<p>笔者对这个 <code>isa_t</code> 的实现声明顺序有一些更改，更方便分析和理解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">union isa_t &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>isa_t</code> 是一个 <code>union</code> 类型的结构体，对 <code>union</code> 不熟悉的读者可以看这个 stackoverflow 上的<a href="http://stackoverflow.com/questions/252552/why-do-we-need-c-unions" target="_blank" rel="noopener">回答</a>. 也就是说其中的 <code>isa_t</code>、<code>cls</code>、 <code>bits</code> 还有结构体共用同一块地址空间。而 <code>isa</code> 总共会占据 64 位的内存空间（决定于其中的结构体）</p>
<p><a href="https://github.com/Draveness/analyze/blob/master/contents/images/objc-isa-isat.png" target="_blank" rel="noopener"><img src="https://github.com/Draveness/analyze/raw/master/contents/images/objc-isa-isat.png" alt="objc-isa-isat"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">   uintptr_t indexed           : 1;</span><br><span class="line">   uintptr_t has_assoc         : 1;</span><br><span class="line">   uintptr_t has_cxx_dtor      : 1;</span><br><span class="line">   uintptr_t shiftcls          : 44;</span><br><span class="line">   uintptr_t magic             : 6;</span><br><span class="line">   uintptr_t weakly_referenced : 1;</span><br><span class="line">   uintptr_t deallocating      : 1;</span><br><span class="line">   uintptr_t has_sidetable_rc  : 1;</span><br><span class="line">   uintptr_t extra_rc          : 8;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="isa-的初始化"><a href="#isa-的初始化" class="headerlink" title="isa 的初始化"></a><code>isa</code> 的初始化</h2><p>我们可以通过 <code>isa</code> 初始化的方法 <code>initIsa</code> 来初步了解这 64 位的 bits 的作用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">inline void </span><br><span class="line">objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">    initIsa(cls, true, hasCxxDtor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void </span><br><span class="line">objc_object::initIsa(Class cls, bool indexed, bool hasCxxDtor) </span><br><span class="line">&#123; </span><br><span class="line">    if (!indexed) &#123;</span><br><span class="line">        isa.cls = cls;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        isa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">        isa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        isa.shiftcls = (uintptr_t)cls &gt;&gt; 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="indexed-和-magic"><a href="#indexed-和-magic" class="headerlink" title="indexed 和 magic"></a><code>indexed</code> 和 <code>magic</code></h3><p>当我们对一个 ObjC 对象分配内存时，其方法调用栈中包含了上述的两个方法，这里关注的重点是 <code>initIsa</code> 方法，由于在 <code>initInstanceIsa</code> 方法中传入了 <code>indexed = true</code>，所以，我们简化一下这个方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inline void objc_object::initIsa(Class cls, bool indexed, bool hasCxxDtor) </span><br><span class="line">&#123; </span><br><span class="line">    isa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">    isa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">    isa.shiftcls = (uintptr_t)cls &gt;&gt; 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对整个 <code>isa</code> 的值 <code>bits</code> 进行设置，传入 <code>ISA_MAGIC_VALUE</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ISA_MAGIC_VALUE 0x001d800000000001ULL</span><br></pre></td></tr></table></figure>
<p>我们可以把它转换成二进制的数据，然后看一下哪些属性对应的位被这行代码初始化了（标记为红色）：</p>
<p><a href="https://github.com/Draveness/analyze/blob/master/contents/images/objc-isa-isat-bits.png" target="_blank" rel="noopener"><img src="https://github.com/Draveness/analyze/raw/master/contents/images/objc-isa-isat-bits.png" alt="objc-isa-isat-bits"></a></p>
<p>从图中了解到，在使用 <code>ISA_MAGIC_VALUE</code> 设置 <code>isa_t</code> 结构体之后，实际上只是设置了 <code>indexed</code> 以及 <code>magic</code> 这两部分的值。</p>
<ul>
<li><p>其中 <code>indexed</code> 表示 <code>isa_t</code> 的类型</p>
<ul>
<li>0 表示 <code>raw isa</code>，也就是没有结构体的部分，访问对象的 <code>isa</code> 会直接返回一个指向 <code>cls</code> 的指针，也就是在 iPhone 迁移到 64 位系统之前时 isa 的类型。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">union isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>1 表示当前 <code>isa</code> 不是指针，但是其中也有 <code>cls</code> 的信息，只是其中<strong>关于类的指针都是保存在 shiftcls 中</strong>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">union isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"></span><br><span class="line">    struct &#123;</span><br><span class="line">        uintptr_t indexed           : 1;</span><br><span class="line">        uintptr_t has_assoc         : 1;</span><br><span class="line">        uintptr_t has_cxx_dtor      : 1;</span><br><span class="line">        uintptr_t shiftcls          : 44;</span><br><span class="line">        uintptr_t magic             : 6;</span><br><span class="line">        uintptr_t weakly_referenced : 1;</span><br><span class="line">        uintptr_t deallocating      : 1;</span><br><span class="line">        uintptr_t has_sidetable_rc  : 1;</span><br><span class="line">        uintptr_t extra_rc          : 8;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>magic</code> 的值为 <code>0x3b</code> 用于调试器判断当前对象是真的对象还是没有初始化的空间</p>
</li>
</ul>
<h3 id="has-cxx-dtor"><a href="#has-cxx-dtor" class="headerlink" title="has_cxx_dtor"></a><code>has_cxx_dtor</code></h3><p>在设置 <code>indexed</code> 和 <code>magic</code> 值之后，会设置 <code>isa</code> 的 <code>has_cxx_dtor</code>，这一位表示当前对象有 C++ 或者 ObjC 的析构器(destructor)，如果没有析构器就会快速释放内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isa.has_cxx_dtor = hasCxxDtor;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/Draveness/analyze/blob/master/contents/images/objc-isa-isat-bits-has-css-dtor.png" target="_blank" rel="noopener"><img src="https://github.com/Draveness/analyze/raw/master/contents/images/objc-isa-isat-bits-has-css-dtor.png" alt="objc-isa-isat-bits-has-css-dto"></a></p>
<h3 id="shiftcls"><a href="#shiftcls" class="headerlink" title="shiftcls"></a><code>shiftcls</code></h3><p>在为 <code>indexed</code>、 <code>magic</code> 和 <code>has_cxx_dtor</code> 设置之后，我们就要将当前对象对应的类指针存入 <code>isa</code> 结构体中了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isa.shiftcls = (uintptr_t)cls &gt;&gt; 3;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>将当前地址右移三位的主要原因是用于将 Class 指针中无用的后三位清除减小内存的消耗，因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的 0</strong>。</p>
<p>绝大多数机器的架构都是 <a href="https://en.wikipedia.org/wiki/Byte_addressing" target="_blank" rel="noopener">byte-addressable</a> 的，但是对象的内存地址必须对齐到字节的倍数，这样可以提高代码运行的性能，在 iPhone5s 中虚拟地址为 33 位，所以用于对齐的最后三位比特为 <code>000</code>，我们只会用其中的 30 位来表示对象的地址。</p>
</blockquote>
<p>而 ObjC 中的类指针的地址后三位也为 0，在 <code>_class_createInstanceFromZone</code> 方法中打印了调用这个方法传入的类指针：</p>
<p><a href="https://github.com/Draveness/analyze/blob/master/contents/images/objc-isa-print-cls.png" target="_blank" rel="noopener"><img src="https://github.com/Draveness/analyze/raw/master/contents/images/objc-isa-print-cls.png" alt="objc-isa-print-cls"></a></p>
<p>可以看到，这里打印出来的<strong>所有类指针十六进制地址的最后一位都为 8 或者 0</strong>。也就是说，类指针的后三位都为 0，所以，我们在上面存储 <code>Class</code> 指针时右移三位是没有问题的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isa.shiftcls = (uintptr_t)cls &gt;&gt; 3;</span><br></pre></td></tr></table></figure>
<p>如果再尝试打印对象指针的话，会发现所有对象内存地址的<strong>后四位</strong>都是 0，说明 ObjC 在初始化内存时是以 16 个字节对齐的, 分配的内存地址后四位都是 0。</p>
<p><a href="https://github.com/Draveness/analyze/blob/master/contents/images/objc-isa-print-object.png" target="_blank" rel="noopener"><img src="https://github.com/Draveness/analyze/raw/master/contents/images/objc-isa-print-object.png" alt="objc-isa-print-object"></a></p>
<blockquote>
<p>使用整个指针大小的内存来存储 <code>isa</code> 指针有些浪费，尤其在 64 位的 CPU 上。在 <code>ARM64</code> 运行的 iOS 只使用了 33 位作为指针(与结构体中的 33 位无关，Mac OS 上为 47 位)，而剩下的 31 位用于其它目的。类的指针也同样根据字节对齐了，每一个类指针的地址都能够被 8 整除，也就是使最后 3 bits 为 0，为 <code>isa</code> 留下 34 位用于性能的优化。</p>
<p>Using an entire pointer-sized piece of memory for the isa pointer is a bit wasteful, especially on 64-bit CPUs which don’t use all 64 bits of a pointer. ARM64 running iOS currently uses only 33 bits of a pointer, leaving 31 bits for other purposes. Class pointers are also aligned, meaning that a class pointer is guaranteed to be divisible by 8, which frees up another three bits, leaving 34 bits of the isa available for other uses. Apple’s ARM64 runtime takes advantage of this for some great performance improvements. from <a href="https://www.mikeash.com/pyblog/friday-qa-2013-09-27-arm64-and-you.html" target="_blank" rel="noopener">ARM64 and You</a></p>
</blockquote>
<p>我尝试运行了下面的代码将 <code>NSObject</code> 的类指针和对象的 <code>isa</code> 打印出来，具体分析一下</p>
<p><a href="https://github.com/Draveness/analyze/blob/master/contents/images/objc-isa-print-class-object.png" target="_blank" rel="noopener"><img src="https://github.com/Draveness/analyze/raw/master/contents/images/objc-isa-print-class-object.png" alt="objc-isa-print-class-object"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">object_pointer: 0000000001011101100000000000000100000000001110101110000011111001 // 补全至 64 位</span><br><span class="line">class_pointer:                                 100000000001110101110000011111000</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编译器对直接访问 <code>isa</code> 的操作会有警告，因为直接访问 <code>isa</code> 已经不会返回类指针了，这种行为已经被弃用了，取而代之的是使用 <a href="https://github.com/Draveness/analyze/blob/master/contents/objc/%E4%BB%8E%20NSObject%20%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%86%E8%A7%A3%20isa.md#ISA(" target="_blank" rel="noopener">ISA()</a>) 方法来获取类指针。</p>
</blockquote>
<p>代码中的 <code>object</code> 对象的 <code>isa</code> 结构体中的内容是这样的：</p>
<p><a href="https://github.com/Draveness/analyze/blob/master/contents/images/objc-isa-isat-class-highlight-bits.png" target="_blank" rel="noopener"><img src="https://github.com/Draveness/analyze/raw/master/contents/images/objc-isa-isat-class-highlight-bits.png" alt="objc-isa-isat-class-highlight-bits"></a></p>
<p>其中红色的为<strong>类指针</strong>，与上面打印出的 <code>[NSObject class]</code> 指针右移三位的结果完全相同。这也就验证了我们之前对于初始化 <code>isa</code> 时对 <code>initIsa</code> 方法的分析是正确的。它设置了 <code>indexed</code>、<code>magic</code> 以及 <code>shiftcls</code>。</p>
<h3 id="ISA-方法"><a href="#ISA-方法" class="headerlink" title="ISA() 方法"></a>ISA() 方法</h3><p>因为我们使用结构体取代了原有的 isa 指针，所以要提供一个方法 <code>ISA()</code> 来返回类指针。</p>
<p>其中 <code>ISA_MASK</code> 是宏定义，这里通过掩码的方式获取类指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define ISA_MASK 0x00007ffffffffff8ULL</span><br><span class="line">inline Class </span><br><span class="line">objc_object::ISA() </span><br><span class="line">&#123;</span><br><span class="line">    return (Class)(isa.bits &amp; ISA_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其它-bits"><a href="#其它-bits" class="headerlink" title="其它 bits"></a>其它 bits</h3><p>在 <code>isa_t</code> 中，我们还有一些没有介绍的其它 bits，在这个小结就简单介绍下这些 bits 的作用</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">has_assoc</span><br></pre></td></tr></table></figure>
<ul>
<li>对象含有或者曾经含有关联引用，没有关联引用的可以更快地释放内存</li>
</ul>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weakly_referenced</span><br></pre></td></tr></table></figure>
<ul>
<li>对象被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放</li>
</ul>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deallocating</span><br></pre></td></tr></table></figure>
<ul>
<li>对象正在释放内存</li>
</ul>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">has_sidetable_rc</span><br></pre></td></tr></table></figure>
<ul>
<li>对象的引用计数太大了，存不下</li>
</ul>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extra_rc</span><br></pre></td></tr></table></figure>
<ul>
<li>对象的引用计数超过 1，会存在这个这个里面，如果引用计数为 10，<code>extra_rc</code> 的值就为 9</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">   uintptr_t indexed           : 1;</span><br><span class="line">   uintptr_t has_assoc         : 1;</span><br><span class="line">   uintptr_t has_cxx_dtor      : 1;</span><br><span class="line">   uintptr_t shiftcls          : 44;</span><br><span class="line">   uintptr_t magic             : 6;</span><br><span class="line">   uintptr_t weakly_referenced : 1;</span><br><span class="line">   uintptr_t deallocating      : 1;</span><br><span class="line">   uintptr_t has_sidetable_rc  : 1;</span><br><span class="line">   uintptr_t extra_rc          : 8;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="arm64-架构中的-isa-t-结构体"><a href="#arm64-架构中的-isa-t-结构体" class="headerlink" title="arm64 架构中的 isa_t 结构体"></a>arm64 架构中的 <code>isa_t</code> 结构体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line">#define ISA_MAGIC_MASK  0x000003f000000001ULL</span><br><span class="line">#define ISA_MAGIC_VALUE 0x000001a000000001ULL</span><br><span class="line">#define RC_ONE   (1ULL&lt;&lt;45)</span><br><span class="line">#define RC_HALF  (1ULL&lt;&lt;18)</span><br><span class="line">union isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"></span><br><span class="line">    struct &#123;</span><br><span class="line">       uintptr_t indexed           : 1;</span><br><span class="line">       uintptr_t has_assoc         : 1;</span><br><span class="line">       uintptr_t has_cxx_dtor      : 1;</span><br><span class="line">       uintptr_t shiftcls          : 33;</span><br><span class="line">       uintptr_t magic             : 6;</span><br><span class="line">       uintptr_t weakly_referenced : 1;</span><br><span class="line">       uintptr_t deallocating      : 1;</span><br><span class="line">       uintptr_t has_sidetable_rc  : 1;</span><br><span class="line">       uintptr_t extra_rc          : 19;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/Draveness/analyze/blob/master/contents/objc/从%20NSObject%20的初始化了解%20isa.md" target="_blank" rel="noopener">转自</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/14/内存布局/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/14/内存布局/" itemprop="url">
                  内存布局
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-14 11:56:57 / 修改时间：12:06:09" itemprop="dateCreated datePublished" datetime="2018-09-14T11:56:57+08:00">2018-09-14</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/内存管理/" itemprop="url" rel="index"><span itemprop="name">内存管理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在计算机系统中，运行的应用程序的数据都是保存在内存中的，不同类型的数据，保存的内存区域不同。<br>一、内存分区</p>
<ol>
<li>栈区(stack) 由编译器自动分配并释放，存放函数的参数值，局部变量等。栈是系统数据结构，对应线程/进程是唯一的。<br>优点是快速高效，缺点时有限制，数据不灵活。［先进后出］</li>
</ol>
<p>栈空间分静态分配 和动态分配两种。<br>静态分配是编译器完成的，比如自动变量(auto)的分配。<br>动态分配由alloca函数完成。<br>栈的动态分配无需释放(是自动的)，也就没有释放函数。<br>为可移植的程序起见，栈的动态分配操作是不被鼓励的！</p>
<ol>
<li><p>堆区(heap) 由程序员分配和释放，如果程序员不释放，程序结束时，可能会由操作系统回收 ，比如在ios 中 alloc 都是存放在堆中。<br>优点是灵活方便，数据适应面广泛，但是效率有一定降低。［顺序随意］<br>堆是函数库内部数据结构，不一定唯一。<br>不同堆分配的内存无法互相操作。<br>堆空间的分配总是动态的<br>虽然程序结束时所有的数据空间都会被释放回系统，但是精确的申请内存，释放内存匹配是良好程序的基本要素。</p>
</li>
<li><p>全局区(静态区) (static) 全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后有系统释放。<br>注意：全局区又可分为未初始化全局区：<br>.bss段和初始化全局区：data段。<br>举例：int a;未初始化的。int a = 10;已初始化的。<br>例子代码：<br>int a = 10; 全局初始化区<br>char *p; 全局未初始化区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main&#123;</span><br><span class="line">  int b; 栈区</span><br><span class="line">  char s[] = &quot;abc&quot; 栈</span><br><span class="line">  char *p1; 栈 </span><br><span class="line">  char *p2 = &quot;123456&quot;;  123456\\\\0在常量区，p2在栈上。</span><br><span class="line">  static int c =0； 全局（静态）初始化区 </span><br><span class="line"></span><br><span class="line">  w1 = (char *)malloc(10); </span><br><span class="line">  w2 = (char *)malloc(20); </span><br><span class="line">  分配得来得10和20字节的区域就在堆区。 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>文字常量区 存放常量字符串，程序结束后由系统释放</p>
</li>
<li><p>程序代码区 存放函数的二进制代码</p>
</li>
</ol>
<p>二、申请后的系统响应</p>
<ol>
<li><p>栈：存储每一个函数在执行的时候都会向操作系统索要资源，栈区就是函数运行时的内存，栈区中的变量由编译器负责分配和释放，内存随着函数的运行分配，随着函数的结束而释放，由系统自动完成。</p>
<p>注意：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p>
</li>
<li><p>堆：<br>1.首先应该知道操作系统有一个记录空闲内存地址的链表。<br>2.当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。<br>3 .由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中</p>
</li>
</ol>
<p>三、 申请大小的限制</p>
<ol>
<li><p>栈：栈是向低地址扩展的数据结构，是一块连续的内存的区域。是栈顶的地址和栈的最大容量是系统预先规定好的，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数 ) ,如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</p>
</li>
<li><p>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p>
<p>​</p>
<p>​</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1232160-0db68b7366e194e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/284" alt="img"></p>
<p>内存分配.png</p>
</li>
</ol>
<p>栈：由系统自动分配，速度较快，不会产生内存碎片<br>堆：是由alloc分配的内存，速度比较慢，而且容易产生内存碎片，不过用起来最方便</p>
<p>打个比喻来说：</p>
<p>使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。</p>
<p>使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。</p>
<p>[转自 <a href="https://www.jianshu.com/p/f3c1b920e8eb" target="_blank" rel="noopener">iOS程序中的内存分配 栈区堆区全局区</a>]</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/14/iOS中copy-strong-retain-weak和assign的区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/14/iOS中copy-strong-retain-weak和assign的区别/" itemprop="url">
                  iOS中copy,strong,retain,weak和assign的区别
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-14 11:43:02 / 修改时间：11:53:21" itemprop="dateCreated datePublished" datetime="2018-09-14T11:43:02+08:00">2018-09-14</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Objective-C语言特性/" itemprop="url" rel="index"><span itemprop="name">Objective-C语言特性</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文逻辑图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1829796-01df8f735749a62c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/833" alt="img"></p>
<p>文章逻辑图</p>
<p>在知道他们区别之前，我们首先要知道NSObject对象的赋值操作做了哪些操作。</p>
<p>A=C其实是在内存中创建了一个A，然后又开辟了一个内存C，C里面存放的着值B。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1829796-fefe525bde028e51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/538" alt="img"></p>
<p>NSObject赋值示意图1</p>
<p>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSMutableString*tempMStr = [[NSMutableString alloc]initWithString:@&quot;strValue&quot;];</span><br><span class="line">NSLog(@&quot;tempMStr值地址:%p，tempMStr值%@,tempMStr值引用计数%@\\n&quot;, tempMStr,tempMStr,[tempMStr valueForKey:@&quot;retainCount&quot;]);</span><br><span class="line"></span><br><span class="line">//输出tempMStr值地址:0x7a05f650，tempMStr值strValue,tempMStr值引用计数1</span><br></pre></td></tr></table></figure>
<p>此处tempMStr就是A，值地址就是C，“strValue”就是B，而引用计数这个概念是针对C的，赋值给其他变量或者指针设置为nil，如tempStr = nil，都会使得引用计数有所增减。当内存区域引用计数为0时就会将数据抹除。而我们使用copy,strong,retain,weak,assign区别就在：</p>
<p><strong>1.是否开辟新的内存</strong><br><strong>2.是否对地址C有引用计数增加</strong></p>
<p>需要注意的是property修饰符是在被赋值时起作用。</p>
<p>1.以典型的NSMutableString为例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@property(copy,nonatomic)NSMutableString*aCopyMStr;</span><br><span class="line">@property(strong,nonatomic)NSMutableString*strongMStr;</span><br><span class="line">@property(weak,nonatomic)NSMutableString*weakMStr;</span><br><span class="line">@property(assign,nonatomic)NSMutableString*assignMStr;</span><br><span class="line"></span><br><span class="line">NSMutableString*mstrOrigin = [[NSMutableStringalloc]initWithString:@&quot;mstrOriginValue&quot;];</span><br><span class="line"></span><br><span class="line">self.aCopyMStr= mstrOrigin;</span><br><span class="line">self.strongMStr= mstrOrigin;</span><br><span class="line">self.strongMStr= mstrOrigin;</span><br><span class="line">self.weakMStr= mstrOrigin;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;mstrOrigin输出:%p,%@\\n&quot;, mstrOrigin,mstrOrigin);</span><br><span class="line">NSLog(@&quot;aCopyMStr输出:%p,%@\\n&quot;,_aCopyMStr,_aCopyMStr);</span><br><span class="line">NSLog(@&quot;strongMStr输出:%p,%@\\n&quot;,_strongMStr,_strongMStr);</span><br><span class="line">NSLog(@&quot;weakMStr输出:%p,%@\\n&quot;,_weakMStr,_weakMStr);</span><br><span class="line">NSLog(@&quot;引用计数%@&quot;,[mstrOriginvalueForKey:@&quot;retainCount&quot;]);</span><br><span class="line"></span><br><span class="line">//输出结果</span><br><span class="line">//2016-09-01 15:19:13.134 lbCopy[1205:87583] mstrOrigin输出:0x7892a5e0,mstrOriginValue</span><br><span class="line">//2016-09-01 15:19:13.135 lbCopy[1205:87583] aCopyMStr输出:0x7893deb0,mstrOriginValue</span><br><span class="line">//2016-09-01 15:19:13.135 lbCopy[1205:87583] strongMStr输出:0x7892a5e0,mstrOriginValue</span><br><span class="line">//2016-09-01 15:19:13.135 lbCopy[1205:87583] weakMStr输出:0x7892a5e0,mstrOriginValue</span><br><span class="line">//2016-09-01 15:19:13.135 lbCopy[1205:87583] 引用计数2</span><br></pre></td></tr></table></figure>
<p>strongMStr和weakMStr指针指向的内存地址都和mstrOrigin相同,但mstrOrigin内存引用计数为2，不为3，因为weakMStr虽然指向了数据内存地址（之后用C简称，见示意图1），但不会增加C计数。copy修饰的的aCopyMStr，赋值后则是自己单独开辟了一块内存，内存上保存“mstrOrigin”字符串，并指向。</p>
<p>拷贝示意图如下</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1829796-23d123453eb7707e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/645" alt="img"></p>
<p>NSMutableString拷贝示意图2</p>
<p>可见当我修改mstrOrigin的值的时候，必然不会影响aCopyMStr,只会影响strongMStr和weakMStr。我们来验证下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;------------------修改原值后------------------------&quot;);</span><br><span class="line"></span><br><span class="line">[mstrOriginappendString:@&quot;1&quot;];</span><br><span class="line">NSLog(@&quot;mstrOrigin输出:%p,%@\\n&quot;, mstrOrigin,mstrOrigin);</span><br><span class="line">NSLog(@&quot;aCopyMStr输出:%p,%@\\n&quot;,_aCopyMStr,_aCopyMStr);</span><br><span class="line">NSLog(@&quot;strongMStr输出:%p,%@\\n&quot;,_strongMStr,_strongMStr);</span><br><span class="line">NSLog(@&quot;weakMStr输出:%p,%@\\n&quot;,_weakMStr,_weakMStr);</span><br><span class="line"></span><br><span class="line">//输出结果</span><br><span class="line">//2016-09-01 15:33:02.839 lbCopy[1205:87583] mstrOrigin输出:0x7892a5e0,mstrOrigin1</span><br><span class="line">//2016-09-01 15:33:02.839 lbCopy[1205:87583] aCopyMStr输出:0x7893deb0,mstrOrigin</span><br><span class="line">//2016-09-01 15:33:02.839 lbCopy[1205:87583] strongMStr输出:0x7892a5e0,mstrOrigin1</span><br><span class="line">//2016-09-01 15:33:02.839 lbCopy[1205:87583] weakMStr输出:0x7892a5e0,mstrOrigin1</span><br></pre></td></tr></table></figure>
<p>copy会重新开辟新的内存来保存一份相同的数据。被赋值对象和原值修改互不影响。strong和weak赋值都指向原来数据地址，区别是前者会对数据地址进行引用计数+1，后者不会</p>
<p>引用计数是否+1有什么实质区别呢？</p>
<p>如果知道“值地址的引用计数为0时，地址上保存的值就会被释放”。那么区别就不难理解，weak修饰的指针A指向的值地址C，那么地址上当其他指向他的指针被释放的时候，这个值地址引用计数也就变为0了，这个A的值也就为nil了。换句话说当值地址C上没有其他强引用指针修饰的时候C就会被立即释放，A的值就变为nil了。</p>
<p>这里我们来初始化mstrOrigin和并将strongMStr设置为nil让C的引用计数为0，然后输出weakMStr，看是否为nil.<br>注：初始化和设为nil都可以将指针所指向的数据地址引用计数减少1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mstrOrigin = [[NSMutableStringalloc]initWithString:@&quot;mstrOriginChange2&quot;];</span><br><span class="line">self.strongMStr=nil;</span><br><span class="line">NSLog(@&quot;mstrOrigin输出:%p,%@\\n&quot;, mstrOrigin,mstrOrigin);</span><br><span class="line">NSLog(@&quot;strongMStr输出:%p,%@\\n&quot;,_strongMStr,_strongMStr);</span><br><span class="line">NSLog(@&quot;weakMStr输出:%p,%@\\n&quot;,_weakMStr,_weakMStr);</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">//2016-09-01 15:41:33.793 lbCopy[1247:100742] mstrOrigin输出:0x7874d140,mstrOriginChange2</span><br><span class="line">//2016-09-01 15:41:33.793 lbCopy[1247:100742] strongMStr输出:0x0,(null)</span><br><span class="line">//2016-09-01 15:41:33.794 lbCopy[1247:100742] weakMStr输出:0x0,(null)</span><br></pre></td></tr></table></figure>
<p>可见之前引用计数2是mstrOrigin和strongMStr添加的。<br><strong>结论：copy会重新开辟新的内存来保存一份相同的数据。被赋值对象和原值修改互不影响。strong和weak虽然都指向原来数据地址，原值修改的时候storng和weak会随之变化。区别是前者会对数据地址进行引用计数+1防止原地址值被释放，但后者不会，当其他值都不在指向值地址时，值地址被释放，weak的值也就是为nil了。我们称会对数据地址增加引用计数的为强引用，不改变引用计数的为弱引用</strong></p>
<h3 id="1-2-assign和weak的区别"><a href="#1-2-assign和weak的区别" class="headerlink" title="1.2 assign和weak的区别"></a>1.2 assign和weak的区别</h3><p>对assign和weak修饰的值进行赋值，并输出指针结构地址和值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.assignMStr= mstrOrigin;</span><br><span class="line">self.weakMStr= mstrOrigin;</span><br><span class="line">mstrOrigin = [[NSMutableStringalloc]initWithString:@&quot;mstrOriginChange3&quot;];</span><br><span class="line">NSLog(@&quot;weakMStr输出:%p,%@\\n&quot;,_weakMStr,_weakMStr);</span><br><span class="line">NSLog(@&quot;assignMStr输出:%p,%@\\n&quot;,self.assignMStr,self.assignMStr);</span><br></pre></td></tr></table></figure>
<p>可以发现在输出assignMStr时会偶尔出现奔溃的情况。原因是发送了野指针的情况。assign同weak，指向C并且计数不+1，但当C地址引用计数为0时，assign不会对C地址进行B数据的抹除操作，只是进行值释放。这就导致野指针存在，即当这块地址还没写上其他值前，能输出正常值，但一旦重新写上数据，该指针随时可能没有值，造成奔溃。</p>
<h3 id="1-3那retain是什么"><a href="#1-3那retain是什么" class="headerlink" title="1.3那retain是什么"></a>1.3那retain是什么</h3><p>ARC之前属性构造器的关键字是retain,copy,assign，strong和weak是ARC带出来的关键字。<br><strong>retain现在同strong，就是指针指向值地址，同时进行引用计数加1。</strong></p>
<h2 id="2-非NSMutableString的情况"><a href="#2-非NSMutableString的情况" class="headerlink" title="2.非NSMutableString的情况"></a>2.非NSMutableString的情况</h2><p><br><br>上面我们讨论了典型的例子NSMutableString，即非容器可变变量。也就是说还存在其他三种类型需要讨论…</p>
<p>1.非容器不可变变量NSSting<br>2.容器可变变量NSMutableArray<br>3.容器不可变变量NSArray</p>
<p>更重要的是不同类型会有不同结果…，好吧，不要奔溃，上面一大段我们讨论了1/4，接下来我们要讨论其他的3/4情况。但好消息是，其他几种情况基本与上面非容器可变变量情况基本类似。</p>
<h3 id="2-1容器可变变量"><a href="#2-1容器可变变量" class="headerlink" title="2.1容器可变变量"></a>2.1容器可变变量</h3><p>容器可变变量的典型例子就是NSMutableArray<br>下面代码可以忽略，只做参考用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">@property(copy,nonatomic)NSMutableArray*aCopyMArr;</span><br><span class="line">@property(strong,nonatomic)NSMutableArray*strongMArr;</span><br><span class="line">@property(weak,nonatomic)NSMutableArray*weakMArr;</span><br><span class="line"></span><br><span class="line">NSMutableArray*mArrOrigin = [[NSMutableArrayalloc]init];</span><br><span class="line">NSMutableString*mstr1 = [[NSMutableStringalloc]initWithString:@&quot;value1&quot;];</span><br><span class="line">NSMutableString*mstr2 = [[NSMutableStringalloc]initWithString:@&quot;value2&quot;];</span><br><span class="line">NSMutableString*mstr3 = [[NSMutableStringalloc]initWithString:@&quot;value3&quot;];</span><br><span class="line"></span><br><span class="line">[mArrOriginaddObject:mstr1];</span><br><span class="line">[mArrOriginaddObject:mstr2];</span><br><span class="line"></span><br><span class="line">//将mArrOrigin拷贝给aCopyMArr，strongMArr，weakMArr</span><br><span class="line">self.aCopyMArr= mArrOrigin;</span><br><span class="line">self.strongMArr= mArrOrigin;</span><br><span class="line">self.weakMArr= mArrOrigin;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;mArrOrigin输出:%p,%@\\n&quot;, mArrOrigin,mArrOrigin);</span><br><span class="line">NSLog(@&quot;aCopyMArr输出:%p,%@\\n&quot;,_aCopyMArr,_aCopyMArr);</span><br><span class="line">NSLog(@&quot;strongMArr输出:%p,%@\\n&quot;,_strongMArr,_strongMArr);</span><br><span class="line">NSLog(@&quot;weakMArr输出:%p,%@\\n&quot;,_weakMArr,_weakMArr);</span><br><span class="line">NSLog(@&quot;weakMArr输出:%p,%@\\n&quot;,_weakMArr[0],_weakMArr[0]);</span><br><span class="line">NSLog(@&quot;mArrOrigin中的数据引用计数%@&quot;, [mArrOriginvalueForKey:@&quot;retainCount&quot;]);</span><br><span class="line">NSLog(@&quot;%p %p %p %p&quot;,&amp;mArrOrigin,mArrOrigin,mArrOrigin[0],mArrOrigin[1]);</span><br><span class="line"></span><br><span class="line">//以下是输出</span><br><span class="line">2016-09-02 20:42:30.777 lbCopy[4207:475091] mArrOrigin输出:0x78f81680,(</span><br><span class="line">value1,</span><br><span class="line">value2</span><br><span class="line">)</span><br><span class="line">2016-09-02 20:42:30.777 lbCopy[4207:475091] aCopyMArr输出:0x7a041340,(</span><br><span class="line">value1,</span><br><span class="line">value2</span><br><span class="line">)</span><br><span class="line">2016-09-02 20:42:30.777 lbCopy[4207:475091] strongMArr输出:0x78f81680,(</span><br><span class="line">value1,</span><br><span class="line">value2</span><br><span class="line">)</span><br><span class="line">2016-09-02 20:42:30.777 lbCopy[4207:475091] weakMArr输出:0x78f81680,(</span><br><span class="line">value1,</span><br><span class="line">value2</span><br><span class="line">)</span><br><span class="line">2016-09-02 20:42:30.777 lbCopy[4207:475091] weakMArr输出:0x78f816a0,value1</span><br><span class="line">2016-09-02 20:42:30.778 lbCopy[4207:475091] mArrOrigin中的数据引用计数(</span><br><span class="line">3,</span><br><span class="line">3</span><br><span class="line">)</span><br><span class="line">2016-09-02 20:42:30.778 lbCopy[4207:475091] 0xbffb4098 0x78f81680 0x78f816a0 0x78f81710</span><br><span class="line">//以上是输出</span><br><span class="line"></span><br><span class="line">//给原数组添加一个元素</span><br><span class="line">[mArrOriginaddObject:mstr3];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;mArrOrigin输出:%p,%@\\n&quot;, mArrOrigin,mArrOrigin);</span><br><span class="line">NSLog(@&quot;aCopyMArr输出:%p,%@\\n&quot;,_aCopyMArr,_aCopyMArr);</span><br><span class="line">NSLog(@&quot;strongMArr输出:%p,%@\\n&quot;,_strongMArr,_strongMArr);</span><br><span class="line">NSLog(@&quot;weakMArr输出:%p,%@\\n&quot;,_weakMArr,_weakMArr);</span><br><span class="line">NSLog(@&quot;mArrOrigin中的数据引用计数%@&quot;, [mArrOriginvalueForKey:@&quot;retainCount&quot;]);</span><br><span class="line"></span><br><span class="line">//修改原数组中的元素，看是否有随之变化</span><br><span class="line">[mstr1appendFormat:@&quot;aaa&quot;];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;mArrOrigin输出:%p,%@\\n&quot;, mArrOrigin,mArrOrigin);</span><br><span class="line">NSLog(@&quot;aCopyMArr输出:%p,%@\\n&quot;,_aCopyMArr,_aCopyMArr);</span><br><span class="line">NSLog(@&quot;strongMArr输出:%p,%@\\n&quot;,_strongMArr,_strongMArr);</span><br><span class="line">NSLog(@&quot;weakMArr输出:%p,%@\\n&quot;,_weakMArr,_weakMArr);</span><br><span class="line"></span><br><span class="line">//以下是输出</span><br><span class="line">2016-09-02 20:42:30.778 lbCopy[4207:475091] mArrOrigin输出:0x78f81680,(</span><br><span class="line">value1,</span><br><span class="line">value2,</span><br><span class="line">value3</span><br><span class="line">)</span><br><span class="line">2016-09-02 20:42:30.778 lbCopy[4207:475091] aCopyMArr输出:0x7a041340,(</span><br><span class="line">value1,</span><br><span class="line">value2</span><br><span class="line">)</span><br><span class="line">2016-09-02 20:42:30.778 lbCopy[4207:475091] strongMArr输出:0x78f81680,(</span><br><span class="line">value1,</span><br><span class="line">value2,</span><br><span class="line">value3</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">2016-09-02 20:42:30.778 lbCopy[4207:475091] weakMArr输出:0x78f81680,(</span><br><span class="line">value1,</span><br><span class="line">value2,</span><br><span class="line">value3</span><br><span class="line">)</span><br><span class="line">2016-09-02 20:42:30.779 lbCopy[4207:475091] mArrOrigin中的数据引用计数(</span><br><span class="line">3,</span><br><span class="line">3,</span><br><span class="line">2</span><br><span class="line">)</span><br><span class="line">2016-09-02 20:42:30.779 lbCopy[4207:475091] mArrOrigin输出:0x78f81680,(</span><br><span class="line">value1aaa,</span><br><span class="line">value2,</span><br><span class="line">value3</span><br><span class="line">)</span><br><span class="line">2016-09-02 20:42:30.779 lbCopy[4207:475091] aCopyMArr输出:0x7a041340,(</span><br><span class="line">value1aaa,</span><br><span class="line">value2</span><br><span class="line">)</span><br><span class="line">2016-09-02 20:42:30.779 lbCopy[4207:475091] strongMArr输出:0x78f81680,(</span><br><span class="line">value1aaa,</span><br><span class="line">value2,</span><br><span class="line">value3</span><br><span class="line">)</span><br><span class="line">2016-09-02 20:42:30.779 lbCopy[4207:475091] weakMArr输/出:0x78f81680,(</span><br><span class="line">value1aaa,</span><br><span class="line">value2,</span><br><span class="line">value3</span><br><span class="line">)</span><br><span class="line">//以上是输出</span><br></pre></td></tr></table></figure>
<p>上面代码有点多，所做的操作是mArrOrigin（value1,value2）赋值给copy,strong,weak修饰的aCopyMArr,strongMArr,weakMArr。通过给原数组增加元素，修改原数组元素值，然后输出mArrOrigin的引用计数，和数组地址，查看变化。<br>发现其中数组本身指向的内存地址除了aCopyMArr重新开辟了一块地址，strongMArr,weakMArr和mArrOrigin指针指向的地址是一样的。也就是说</p>
<p><strong>容器可变变量中容器本身和非容器可变变量是一样的，copy深拷贝，strongMArr,weakMArr和assign都是浅拷贝</strong></p>
<p>另外我们发现被拷贝对象mArrOrigin中的数据引用计数居然不是1而是3。也就是说容器内的数据拷贝都是进行了浅拷贝。同时当我们修改数组中的一个数据时strongMArr,weakMArr，aCopyMArr中的数据都改变了，说明</p>
<p><strong>容器可变变量中的数据在拷贝的时候都是浅拷贝</strong></p>
<p>容器可变变量的拷贝结构如下图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1829796-5fec2788d9c9c6b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/692" alt="img"></p>
<p>NSMutableArray拷贝示意图3</p>
<p>2.2非容器不变变量</p>
<p>典型例子是NSString</p>
<p>我们还是以代码引出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">@property(copy,nonatomic)NSString*aCopyStr;</span><br><span class="line">@property(strong,nonatomic)NSString*strongStr;</span><br><span class="line">@property(weak,nonatomic)NSString*weakStr;</span><br><span class="line">@property(assign,nonatomic)NSString*assignStr;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;\\n\\n\\n\\n------------------不可变量实验------------------------&quot;);</span><br><span class="line"></span><br><span class="line">NSString*strOrigin = [[NSStringalloc]initWithUTF8String:&quot;strOrigin0123456&quot;];</span><br><span class="line"></span><br><span class="line">self.aCopyStr= strOrigin;</span><br><span class="line"></span><br><span class="line">self.strongStr= strOrigin;</span><br><span class="line"></span><br><span class="line">self.weakStr= strOrigin;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;strOrigin输出:%p,%@\\n&quot;, strOrigin,strOrigin);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;aCopyStr输出:%p,%@\\n&quot;,_aCopyStr,_aCopyStr);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;strongStr输出:%p,%@\\n&quot;,_strongStr,_strongStr);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;weakStr输出:%p,%@\\n&quot;,_weakStr,_weakStr);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;------------------修改原值后------------------------&quot;);</span><br><span class="line"></span><br><span class="line">strOrigin =@&quot;aaa&quot;;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;strOrigin输出:%p,%@\\n&quot;, strOrigin,strOrigin);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;aCopyStr输出:%p,%@\\n&quot;,_aCopyStr,_aCopyStr);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;strongStr输出:%p,%@\\n&quot;,_strongStr,_strongStr);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;weakStr输出:%p,%@\\n&quot;,_weakStr,_weakStr);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;------------------结论------------------------&quot;);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;strOrigin值值为改变，但strOrigin和aCopyStr指针地址和指向都已经改变，说明不可变类型值不可被修改，重新初始化&quot;);</span><br><span class="line"></span><br><span class="line">self.aCopyStr=nil;</span><br><span class="line"></span><br><span class="line">self.strongStr=nil;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;strOrigin输出:%p,%@\\n&quot;, strOrigin,strOrigin);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;aCopyStr输出:%p,%@\\n&quot;,_aCopyStr,_aCopyStr);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;strongStr输出:%p,%@\\n&quot;,_strongStr,_strongStr);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;weakStr输出:%p,%@\\n&quot;,_weakStr,_weakStr);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;------------------结论------------------------&quot;);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;当只有weakStr拥有C时，值依旧会被释放，同非容器可变变量&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//以下是输出</span><br><span class="line"></span><br><span class="line">------------------不可变量实验------------------------</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.053 lbCopy[4297:488549] strOrigin输出:0x7a2550d0,strOrigin0123456</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.053 lbCopy[4297:488549] aCopyStr输出:0x7a2550d0,strOrigin0123456</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.054 lbCopy[4297:488549] strongStr输出:0x7a2550d0,strOrigin0123456</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.054 lbCopy[4297:488549] weakStr输出:0x7a2550d0,strOrigin0123456</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.054 lbCopy[4297:488549] strOrigin值内存引用计数3</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.054 lbCopy[4297:488549] ------------------修改原值后------------------------</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.054 lbCopy[4297:488549] strOrigin输出:0x8c1f8,aaa</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.054 lbCopy[4297:488549] aCopyStr输出:0x7a2550d0,strOrigin0123456</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.054 lbCopy[4297:488549] strongStr输出:0x7a2550d0,strOrigin0123456</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.055 lbCopy[4297:488549] weakStr输出:0x7a2550d0,strOrigin0123456</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.055 lbCopy[4297:488549] ------------------结论------------------------</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.055 lbCopy[4297:488549] strOrigin值值为改变，但strOrigin和aCopyStr指针地址和指向都已经改变，说明不可变类型值不可被修改，重新初始化</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.059 lbCopy[4297:488549] strOrigin输出:0x8c1f8,aaa</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.059 lbCopy[4297:488549] aCopyStr输出:0x0,(null)</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.060 lbCopy[4297:488549] strongStr输出:0x0,(null)</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.060 lbCopy[4297:488549] weakStr输出:0x0,(null)</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.060 lbCopy[4297:488549] ------------------结论------------------------</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.061 lbCopy[4297:488549]当只有weakStr拥有C时，值依旧会被释放，同非容器可变变量</span><br><span class="line">//以上是输出</span><br></pre></td></tr></table></figure>
<p>此处我们将strOrigin拷贝给aCopyStr，strongStr，weakStr，然后输出他们的值地址，发现他们四个的值地址一样，且strOrigin值的引用计数为3。修改strOrigin和发现strOrigin值地址改变，其他三个值地址不变，将aCopyStr，strongStr设为nil后，发现weakStr随之nil。</p>
<p>综合上面现象NSString和NSMutableString（非容器可变变量）基本相同，除了copy，NSString为浅拷贝，NSMutableString是深拷贝。那么为什么NSString的copy是浅拷贝呢，也就是说为什么aCopyStr不自己开辟一个独立的内存出来呢。答案很简单，因为不可变量的值不会改变，既然都不会改变，所以没必要重新开辟一个内存出来让aCopyStr指向他，直接指向原来值位置就可以了。示意图如下</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1829796-93b7a0f217ca3baa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/644" alt="img"></p>
<p>NSString拷贝示意图4</p>
<p><strong>所以非容器不可变量除了copy其他特性同非容器可变变量，copy是浅拷贝</strong></p>
<h3 id="2-3不可变容器变量"><a href="#2-3不可变容器变量" class="headerlink" title="2.3不可变容器变量"></a>2.3不可变容器变量</h3><p>典型对象NSArray。该对象实验自行实验。但结论在这里给出，其实不实验也可以大概知道概率<br>在不可变容器变量中，容器本身都是浅拷贝包括copy，同NSString，容器里面的数据都是浅拷贝，同NSMutableArray。</p>
<p>3.总结<br>copy，strong，weak，assign的区别。</p>
<p>可变变量中，copy是重新开辟一个内存，strong，weak，assgin后三者不开辟内存，只是指针指向原来保存值的内存的位置，storng指向后会对该内存引用计数+1，而weak，assgin不会。weak，assgin会在引用保存值的内存引用计数为0的时候值为空，并且weak会将内存值设为nil，assign不会，assign在内存没有被重写前依旧可以输出，但一旦被重写将出现奔溃</p>
<p>不可变变量中，因为值本身不可被改变，copy没必要开辟出一块内存存放和原来内存一模一样的值，所以内存管理系统默认都是浅拷贝。其他和可变变量一样，如weak修饰的变量同样会在内存引用计数为0时变为nil。</p>
<p>容器本身遵守上面准则，但容器内部的每个值都是浅拷贝。</p>
<p><strong>综上所述，当创建property构造器创建变量value1的时候，使用copy，strong，weak，assign根据具体使用情况来决定。value1 = value2，如果你希望value1和value2的修改不会互相影响的就用用copy，反之用strong,weak,assign。如果你还希望原来值C(C是什么见示意图1)为nil的时候，你的变量不为nil就用strong,反之用weak和assign。weak和assign保证了不强引用某一块内存，如delegate我们就用weak表示，就是为了防止循环引用的产生。<br>另外，我们上面讨论的是类变量，直接创建局部变量默认是Strong修饰
</strong></p>
<h4 id="补充：delegate为什么要用weak或者assign而不用strong"><a href="#补充：delegate为什么要用weak或者assign而不用strong" class="headerlink" title="补充：delegate为什么要用weak或者assign而不用strong"></a>补充：delegate为什么要用weak或者assign而不用strong</h4><p>a创建对象b,b中有C类对象c，所以a对b有一个引用,b对c有一个引用，a.b引用计数分别为1，1。当c.delegate = b的时候，实则是对b有了一个引用，如果此时c的delegate用strong修饰则会对b的值内存引用计数+1，b引用计数为2。当a的生命周期结束，随之释放对b的引用，b的引用计数变为1，导致b不能释放，b不能释放又导致b对c的引用不能释放，c引用计数还是为1，这样就造成了b和c一直留在了内存中。</p>
<p>而要解决这个问题就是使用weak或者assign修饰delegate，这样虽然会有c仍然会对b有一个引用，但是引用是弱引用，当a生命周期结束的时候，b的引用计数变为0，b释放后随之c的引用消失，c引用计数变为0，释放。</p>
<h2 id="不可变常量的特殊性"><a href="#不可变常量的特殊性" class="headerlink" title="不可变常量的特殊性"></a>不可变常量的特殊性</h2><p>在2.2的讨论中如果你<br>1.字符串改成小于10长度的字符串<br>2.NSString*strOrigin = @”strOrigin0123456”;<br>初始化NSString，你都会发现strOrigin值内存引用计数将发生异常，通常表现为引用计数特别大，具体可以看下<a href="https://www.jianshu.com/p/f26e1fb64f7f" target="_blank" rel="noopener">iOS中NSString的特别之处</a>这篇文章</p>
<p>项目地址<a href="https://link.jianshu.com/?t=https://github.com/ai966669/copy" target="_blank" rel="noopener">https://github.com/ai966669/copy</a><br><a href="https://www.jianshu.com/p/a29a0bdd5da8" target="_blank" rel="noopener">转自</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/14/深拷贝与浅拷贝/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/14/深拷贝与浅拷贝/" itemprop="url">
                  深拷贝与浅拷贝
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-14 11:33:49 / 修改时间：11:41:05" itemprop="dateCreated datePublished" datetime="2018-09-14T11:33:49+08:00">2018-09-14</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Objective-C语言特性/" itemprop="url" rel="index"><span itemprop="name">Objective-C语言特性</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>对象拷贝有两种方式：浅复制和深复制。顾名思义，浅复制，并不拷贝对象本身，仅仅是拷贝指向对象的指针；深复制是直接拷贝整个对象内存到另一块内存中。</p>
<p>一图以蔽之</p>
<p><img src="http://7s1ssm.com1.z0.glb.clouddn.com/image_note50592_1.png" alt="图片"></p>
<p>再简单些说：<strong>浅复制就是指针拷贝；深复制就是内容拷贝。</strong></p>
<hr>
<h2 id="集合的浅复制-shallow-copy"><a href="#集合的浅复制-shallow-copy" class="headerlink" title="集合的浅复制 (shallow copy)"></a>集合的浅复制 (shallow copy)</h2><p>集合的浅复制有非常多种方法。当你进行浅复制时，会向原始的集合发送retain消息，引用计数加1，同时指针被拷贝到新的集合。</p>
<p>现在让我们看一些浅复制的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray *shallowCopyArray = [someArray copyWithZone:nil];NSSet *shallowCopySet = [NSSet mutableCopyWithZone:nil];NSDictionary *shallowCopyDict = [[NSDictionary alloc] initWithDictionary:someDictionary copyItems:NO];</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="集合的深复制-deep-copy"><a href="#集合的深复制-deep-copy" class="headerlink" title="集合的深复制 (deep copy)"></a>集合的深复制 (deep copy)</h2><p>集合的深复制有两种方法。可以用 initWithArray:copyItems: 将第二个参数设置为YES即可深复制，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary shallowCopyDict = [[NSDictionary alloc] initWithDictionary:someDictionary copyItems:YES];</span><br></pre></td></tr></table></figure>
<p>如果你用这种方法深复制，集合里的每个对象都会收到 copyWithZone: 消息。如果集合里的对象遵循 NSCopying 协议，那么对象就会被深复制到新的集合。如果对象没有遵循 NSCopying 协议，而尝试用这种方法进行深复制，会在运行时出错。copyWithZone: 这种拷贝方式只能够提供一层内存拷贝(one-level-deep copy)，而非真正的深复制。</p>
<p>第二个方法是将集合进行归档(archive)，然后解档(unarchive)，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray *trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:oldArray]];</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="集合的单层深复制-one-level-deep-copy"><a href="#集合的单层深复制-one-level-deep-copy" class="headerlink" title="集合的单层深复制 (one-level-deep copy)"></a>集合的单层深复制 (one-level-deep copy)</h2><p>看到这里，有同学会问：如果在多层数组中，对第一层进行内容拷贝，其它层进行指针拷贝，这种情况是属于深复制，还是浅复制？对此，<a href="https://developer.apple.com/library/mac/documentation/cocoa/conceptual/Collections/Articles/Copying.html#//apple_ref/doc/uid/TP40010162-SW3" target="_blank" rel="noopener">苹果官网文档</a>有这样一句话描述</p>
<blockquote>
<p>This kind of copy is only capable of producing a one-level-deep copy. If you only need a one-level-deep copy…</p>
<p>If you need a true deep copy, such as when you have an array of arrays…</p>
</blockquote>
<p>从文中可以看出，苹果认为这种复制不是真正的深复制，而是将其称为<strong>单层深复制(one-level-deep copy)</strong>。因此，网上有人对浅复制、深复制、单层深复制做了概念区分。</p>
<blockquote>
<ul>
<li>浅复制(shallow copy)：在浅复制操作时，对于被复制对象的每一层都是指针复制。</li>
<li>深复制(one-level-deep copy)：在深复制操作时，对于被复制对象，至少有一层是深复制。</li>
<li>完全复制(real-deep copy)：在完全复制操作时，对于被复制对象的每一层都是对象复制。</li>
</ul>
</blockquote>
<p>当然，这些都是概念性的东西，没有必要纠结于此。只要知道进行拷贝操作时，被拷贝的是指针还是内容即可。</p>
<hr>
<h2 id="系统对象的copy与mutableCopy方法"><a href="#系统对象的copy与mutableCopy方法" class="headerlink" title="系统对象的copy与mutableCopy方法"></a>系统对象的copy与mutableCopy方法</h2><p>不管是集合类对象，还是非集合类对象，接收到copy和mutableCopy消息时，都遵循以下准则：</p>
<ul>
<li>copy返回imutable对象；所以，如果对copy返回值使用mutable对象接口就会crash；</li>
<li>mutableCopy返回mutable对象；</li>
</ul>
<p>下面将针对非集合类对象和集合类对象的copy和mutableCopy方法进行具体的阐述</p>
<h3 id="1、非集合类对象的copy与mutableCopy"><a href="#1、非集合类对象的copy与mutableCopy" class="headerlink" title="1、非集合类对象的copy与mutableCopy"></a>1、非集合类对象的copy与mutableCopy</h3><p>系统非集合类对象指的是 NSString, NSNumber … 之类的对象。下面先看个非集合类immutable对象拷贝的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *string = @&quot;origin&quot;;NSString *stringCopy = [string copy];NSMutableString *stringMCopy = [string mutableCopy];</span><br></pre></td></tr></table></figure>
<p>通过查看内存，可以看到 stringCopy 和 string 的地址是一样，进行了指针拷贝；而 stringMCopy 的地址和 string 不一样，进行了内容拷贝；</p>
<p>再看mutable对象拷贝例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSMutableString *string = [NSMutableString stringWithString: @&quot;origin&quot;];//copyNSString *stringCopy = [string copy];NSMutableString *mStringCopy = [string copy];NSMutableString *stringMCopy = [string mutableCopy];//change value[mStringCopy appendString:@&quot;mm&quot;]; //crash[string appendString:@&quot; origion!&quot;];[stringMCopy appendString:@&quot;!!&quot;];</span><br></pre></td></tr></table></figure>
<p>运行以上代码，会在第7行crash，原因就是 copy 返回的对象是 immutable 对象。注释第7行后再运行，查看内存，发现 string、stringCopy、mStringCopy、stringMCopy 四个对象的内存地址都不一样，说明此时都是做内容拷贝。</p>
<p><strong>综上两个例子，我们可以得出结论：</strong></p>
<blockquote>
<p>在非集合类对象中：对immutable对象进行copy操作，是指针复制，mutableCopy操作时内容复制；对mutable对象进行copy和mutableCopy都是内容复制。用代码简单表示如下：</p>
<ul>
<li>[immutableObject copy] // 浅复制</li>
<li>[immutableObject mutableCopy] //深复制</li>
<li>[mutableObject copy] //深复制</li>
<li>[mutableObject mutableCopy] //深复制</li>
</ul>
</blockquote>
<h3 id="2、集合类对象的copy与mutableCopy"><a href="#2、集合类对象的copy与mutableCopy" class="headerlink" title="2、集合类对象的copy与mutableCopy"></a>2、集合类对象的copy与mutableCopy</h3><p>集合类对象是指NSArray、NSDictionary、NSSet … 之类的对象。下面先看集合类immutable对象使用copy和mutableCopy的一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@[@&quot;a&quot;, @&quot;b&quot;], @[@&quot;c&quot;, @&quot;d&quot;];NSArray *copyArray = [array copy];NSMutableArray *mCopyArray = [array mutableCopy];</span><br></pre></td></tr></table></figure>
<p>查看内容，可以看到copyArray和array的地址是一样的，而mCopyArray和array的地址是不同的。说明copy操作进行了指针拷贝，mutableCopy进行了内容拷贝。但需要强调的是：此处的内容拷贝，仅仅是拷贝array这个对象，array集合内部的元素仍然是指针拷贝。这和上面的非集合immutable对象的拷贝还是挺相似的，那么mutable对象的拷贝会不会类似呢？我们继续往下，看mutable对象拷贝的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *array = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@&quot;a&quot;],@&quot;b&quot;,@&quot;c&quot;,nil];NSArray *copyArray = [array copy];NSMutableArray *mCopyArray = [array mutableCopy];</span><br></pre></td></tr></table></figure>
<p>查看内存，如我们所料，copyArray、mCopyArray和array的内存地址都不一样，说明copyArray、mCopyArray都对array进行了内容拷贝。同样，我们可以得出结论：</p>
<blockquote>
<p>在集合类对象中，对immutable对象进行copy，是指针复制，mutableCopy是内容复制；对mutable对象进行copy和mutableCopy都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。用代码简单表示如下：</p>
<ul>
<li>[immutableObject copy] // 浅复制</li>
<li>[immutableObject mutableCopy] //单层深复制</li>
<li>[mutableObject copy] //单层深复制</li>
<li>[mutableObject mutableCopy] //单层深复制</li>
</ul>
</blockquote>
<p>这个代码结论和非集合类的非常相似。</p>
<p>这时候，是不是有人要问了，如果要对集合对象复制元素怎么办？有这疑问的同学不妨回头看看<strong>集合的深复制</strong>。</p>
<p>好了，深复制与浅复制就讲到这里。</p>
<hr>
<p>最后说个题外的东西，在搜集资料的过程中，发现一个有可能犯错的点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;string&quot;;str = @&quot;newString&quot;;</span><br></pre></td></tr></table></figure>
<p>上面这段代码，在执行第二行代码后，内存地址发生了变化。乍一看，有点意外。按照 C 语言的经验，初始化一个字符串之后，字符串的首地址就被确定下来，不管之后如何修改字符串内容，这个地址都不会改变。但此处第二行并不是对 str 指向的内存地址重新赋值，因为赋值操作符左边的 str 是一个指针，也就是说此处修改的是内存地址。</p>
<p>所以第二行应该这样理解：将@”newStirng”当做一个新的对象，将这段对象的内存地址赋值给str。</p>
<p>我有如下的两个方法查看内存地址</p>
<ul>
<li><code>p str</code> 会打印对象本身的内存地址和对象内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p str(NSString *) $0 = 0x000000010c913680 @&quot;a&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>po &amp;str</code> 则打印的是引用对象的指针所在的地址</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po &amp;str0x00007fff532fb6c0</span><br></pre></td></tr></table></figure>
<p><a href="https://www.zybuluo.com/MicroCai/note/50592" target="_blank" rel="noopener">转自</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/13/KVO的底层实现原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/13/KVO的底层实现原理/" itemprop="url">
                  KVO的底层实现原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-13 18:07:43" itemprop="dateCreated datePublished" datetime="2018-09-13T18:07:43+08:00">2018-09-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-09-14 11:21:02" itemprop="dateModified" datetime="2018-09-14T11:21:02+08:00">2018-09-14</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Objective-C语言特性/" itemprop="url" rel="index"><span itemprop="name">Objective-C语言特性</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="addObserver-forKeyPath-options-context-各个参数的作用分别是什么-observer中需要实现哪个方法才能获得KVO回调？"><a href="#addObserver-forKeyPath-options-context-各个参数的作用分别是什么-observer中需要实现哪个方法才能获得KVO回调？" class="headerlink" title="addObserver:forKeyPath:options:context:各个参数的作用分别是什么, observer中需要实现哪个方法才能获得KVO回调？"></a>addObserver:forKeyPath:options:context:各个参数的作用分别是什么, observer中需要实现哪个方法才能获得KVO回调？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 1. self.person：要监听的对象</span><br><span class="line"> 2. 参数说明：</span><br><span class="line">    * @param addObserver  观察者，负责处理监听事件的对象</span><br><span class="line">    * @param forKeyPath 要监听的属性</span><br><span class="line">    * @param  options 观察的选项（观察新、旧值，也可以都观察）</span><br><span class="line">    * @param context 上下文，用于传递数据，可以利用上下文区分不同的监听</span><br><span class="line"> */</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:@&quot;Person Name&quot;];</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  当监控的某个属性的值改变了就会调用</span><br><span class="line"> *</span><br><span class="line"> *  @param keyPath 监听的属性名</span><br><span class="line"> *  @param object  属性所属的对象</span><br><span class="line"> *  @param change  属性的修改情况（属性原来的值`oldValue`、属性最新的值`newValue`）</span><br><span class="line"> *  @param context 传递的上下文数据，与监听的时候传递的一致，可以利用上下文区分不同的监听</span><br><span class="line"> */</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%@对象的%@属性改变了：%@&quot;, object, keyPath, change);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="KVO-Key-Value-Observing"><a href="#KVO-Key-Value-Observing" class="headerlink" title="KVO (Key-Value Observing)"></a>KVO (Key-Value Observing)</h2><p>KVO 是 Objective-C 对观察者模式（Observer Pattern）的实现。也是 Cocoa Binding 的基础。当被观察对象的某个属性发生更改时，观察者对象会获得通知。</p>
<p>有意思的是，你不需要给被观察的对象添加任何额外代码，就能使用 KVO 。这是怎么做到的？</p>
<h1 id="KVO内部实现原理"><a href="#KVO内部实现原理" class="headerlink" title="KVO内部实现原理"></a>KVO内部实现原理</h1><ul>
<li><p>KVO是基于runtime机制实现的</p>
</li>
<li><p>当某个类的属性对象<code>第一次被观察</code>时，系统就会在运行期<code>动态</code>地创建<code>该类的一个派生类</code>，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的<code>通知机制</code></p>
</li>
<li><p>如果原类为Person，那么生成的派生类名为<code>NSKVONotifying_Person</code></p>
</li>
<li><p>每个类对象中都有一个isa指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法</p>
</li>
<li><p>键值观察通知依赖于NSObject 的两个方法: <code>willChangeValueForKey:</code>和 <code>didChangevlueForKey:</code>；在一个被观察属性发生改变之前， <code>willChangeValueForKey:</code>一定会被调用，这就 会记录旧的值。而当改变发生后，<code>didChangeValueForKey:</code>会被调用，继而 <code>observeValueForKey:ofObject:change:context:</code>也会被调用。</p>
</li>
<li><p>补充：KVO的这套实现机制中苹果还偷偷重写了class方法，让我们误认为还是使用的当前类，从而达到隐藏生成的派生类</p>
<p>​</p>
<p>​</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1429890-b28e010d3a7dbdb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/953" alt="img"></p>
<p>KVO内部实现原理.png</p>
<h1 id="如何手动触发一个value的KVO"><a href="#如何手动触发一个value的KVO" class="headerlink" title="如何手动触发一个value的KVO"></a>如何手动触发一个value的KVO</h1></li>
</ul>
<ul>
<li>自动触发的场景：在注册KVO之前设置一个初始值，注册之后，设置一个不一样的值，就可以触发了</li>
<li>想知道如何手动触发，必须知道自动触发 KVO 的原理，见上面的描述</li>
<li>手动触发演示</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) NSDate *now;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    // “手动触发self.now的KVO”，必写。</span><br><span class="line">    [self willChangeValueForKey:@&quot;now&quot;];</span><br><span class="line"></span><br><span class="line">    // “手动触发self.now的KVO”，必写。</span><br><span class="line">    [self didChangeValueForKey:@&quot;now&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1429890-41421e825e153835.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/521" alt="img"></p>
<p>手动触发一个value的KVO.png    </p>
<h1 id="补充：-如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？（看链接）"><a href="#补充：-如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？（看链接）" class="headerlink" title="补充： 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？（看链接）"></a>补充： 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？（看链接）</h1><ul>
<li><a href="https://link.jianshu.com/?t=http://tech.glowing.com/cn/implement-kvo/" target="_blank" rel="noopener">如何自己动手实现 KVO</a></li>
</ul>
<h1 id="附注-KVC底层实现原理-如下"><a href="#附注-KVC底层实现原理-如下" class="headerlink" title="附注: KVC底层实现原理(如下)"></a>附注: KVC底层实现原理(如下)</h1><p>KVC运用了一个isa-swizzling技术. isa-swizzling就是类型混合指针机制, 将2个对象的isa指针互相调换, 就是俗称的黑魔法.<br>KVC主要通过isa-swizzling, 来实现其内部查找定位的. 默认的实现方法�由NSOject提供isa指针, 如其名称所指,(就是is a kind of的意思), 指向分发表对象的类. 该分发表实际上包含了指向实现类中的方法的指针, 和其它数据。</p>
<blockquote>
<ul>
<li>具体主要分为三大步</li>
</ul>
</blockquote>
<ul>
<li>第一步：寻找该属性有没有setsetter方法？有，就直接赋值</li>
<li>第二步：寻找有没有该属性带下划线的成员属性？有，就直接赋值</li>
<li>第三步：寻找有没有该属性的成员属性？有，就直接赋值</li>
</ul>
<blockquote>
<ul>
<li>或者这么说</li>
</ul>
</blockquote>
<ul>
<li>1、首先搜索setKey:方法.(key指成员变量名, 首字母大写)</li>
<li>2、上面的setter方法没找到, 如果类方法accessInstanceVariablesDirectly返回YES. 那么按 _key, _isKey，key, iskey的顺序搜索成员名.(NSKeyValueCodingCatogery中实现的类方法, 默认实现为返回YES)</li>
<li>3、如果没有找到成员变量, 调用setValue:forUnderfinedKey:</li>
</ul>
<p>比如说如下的一行KVC的代码：</p>
<h1 id="举个🌰e-g"><a href="#举个🌰e-g" class="headerlink" title="举个🌰e.g:"></a>举个🌰e.g:</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[object setValue:@&quot;13123&quot; forKey:@&quot;uuid&quot;];</span><br><span class="line"></span><br><span class="line">就会被编译器处理成:</span><br><span class="line">// 首先找到对应sel</span><br><span class="line">SEL sel = sel_get_ uuid(&quot;setValue:forKey:&quot;);</span><br><span class="line">// 根据object-&gt;isa找到sel对应的IMP实现指针</span><br><span class="line">IMP method = objc_msg_lookup (object-&gt;isa,sel);</span><br><span class="line">// 调用指针完成KVC赋值</span><br><span class="line">method(object, sel, @&quot;13123&quot;, @&quot;uuid&quot;);</span><br></pre></td></tr></table></figure>
<p><a href="https://link.jianshu.com/?t=http://blog.csdn.net/iunion/article/details/46890809" target="_blank" rel="noopener"><strong>可供参考文章</strong></a></p>
<p>下面这篇也不错</p>
<p> <a href="https://www.jianshu.com/p/e59bb8f59302" target="_blank" rel="noopener">KVO的实现原理与具体应用</a></p>
<p>[转自 <a href="https://www.jianshu.com/p/829864680648" target="_blank" rel="noopener">探究KVO的底层实现原理</a>]</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Sun Lei</p>
              <p class="site-description motion-element" itemprop="description">只有用心才能看清楚·真正重要的东西·用眼睛是看不见的</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">21</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sun Lei</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.4.4</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Muse</a> v6.4.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.1"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
