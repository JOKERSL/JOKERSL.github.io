<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.1" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.1">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.4.1',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="本文逻辑图：  文章逻辑图 在知道他们区别之前，我们首先要知道NSObject对象的赋值操作做了哪些操作。 A=C其实是在内存中创建了一个A，然后又开辟了一个内存C，C里面存放的着值B。  NSObject赋值示意图1 如下： 1234NSMutableString*tempMStr = [[NSMutableString alloc]initWithString:@&amp;quot;strValue&amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS中copy,strong,retain,weak和assign的区别">
<meta property="og:url" content="http://yoursite.com/iOS面试/2018/09/14/iOS中copy-strong-retain-weak和assign的区别/index.html">
<meta property="og:site_name" content="Man Tou Pu&#39;s Blog">
<meta property="og:description" content="本文逻辑图：  文章逻辑图 在知道他们区别之前，我们首先要知道NSObject对象的赋值操作做了哪些操作。 A=C其实是在内存中创建了一个A，然后又开辟了一个内存C，C里面存放的着值B。  NSObject赋值示意图1 如下： 1234NSMutableString*tempMStr = [[NSMutableString alloc]initWithString:@&amp;quot;strValue&amp;">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1829796-01df8f735749a62c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/833">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1829796-fefe525bde028e51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/538">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1829796-23d123453eb7707e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/645">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1829796-5fec2788d9c9c6b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/692">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1829796-93b7a0f217ca3baa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/644">
<meta property="og:updated_time" content="2018-09-14T03:53:21.614Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS中copy,strong,retain,weak和assign的区别">
<meta name="twitter:description" content="本文逻辑图：  文章逻辑图 在知道他们区别之前，我们首先要知道NSObject对象的赋值操作做了哪些操作。 A=C其实是在内存中创建了一个A，然后又开辟了一个内存C，C里面存放的着值B。  NSObject赋值示意图1 如下： 1234NSMutableString*tempMStr = [[NSMutableString alloc]initWithString:@&amp;quot;strValue&amp;">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/1829796-01df8f735749a62c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/833">






  <link rel="canonical" href="http://yoursite.com/iOS面试/2018/09/14/iOS中copy-strong-retain-weak和assign的区别/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>iOS中copy,strong,retain,weak和assign的区别 | Man Tou Pu's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Man Tou Pu's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">技术、生活个人博客</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/14/iOS中copy-strong-retain-weak和assign的区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS中copy,strong,retain,weak和assign的区别
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-14 11:43:02 / 修改时间：11:53:21" itemprop="dateCreated datePublished" datetime="2018-09-14T11:43:02+08:00">2018-09-14</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Objective-C语言特性/" itemprop="url" rel="index"><span itemprop="name">Objective-C语言特性</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本文逻辑图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1829796-01df8f735749a62c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/833" alt="img"></p>
<p>文章逻辑图</p>
<p>在知道他们区别之前，我们首先要知道NSObject对象的赋值操作做了哪些操作。</p>
<p>A=C其实是在内存中创建了一个A，然后又开辟了一个内存C，C里面存放的着值B。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1829796-fefe525bde028e51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/538" alt="img"></p>
<p>NSObject赋值示意图1</p>
<p>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSMutableString*tempMStr = [[NSMutableString alloc]initWithString:@&quot;strValue&quot;];</span><br><span class="line">NSLog(@&quot;tempMStr值地址:%p，tempMStr值%@,tempMStr值引用计数%@\\n&quot;, tempMStr,tempMStr,[tempMStr valueForKey:@&quot;retainCount&quot;]);</span><br><span class="line"></span><br><span class="line">//输出tempMStr值地址:0x7a05f650，tempMStr值strValue,tempMStr值引用计数1</span><br></pre></td></tr></table></figure>
<p>此处tempMStr就是A，值地址就是C，“strValue”就是B，而引用计数这个概念是针对C的，赋值给其他变量或者指针设置为nil，如tempStr = nil，都会使得引用计数有所增减。当内存区域引用计数为0时就会将数据抹除。而我们使用copy,strong,retain,weak,assign区别就在：</p>
<p><strong>1.是否开辟新的内存</strong><br><strong>2.是否对地址C有引用计数增加</strong></p>
<p>需要注意的是property修饰符是在被赋值时起作用。</p>
<p>1.以典型的NSMutableString为例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@property(copy,nonatomic)NSMutableString*aCopyMStr;</span><br><span class="line">@property(strong,nonatomic)NSMutableString*strongMStr;</span><br><span class="line">@property(weak,nonatomic)NSMutableString*weakMStr;</span><br><span class="line">@property(assign,nonatomic)NSMutableString*assignMStr;</span><br><span class="line"></span><br><span class="line">NSMutableString*mstrOrigin = [[NSMutableStringalloc]initWithString:@&quot;mstrOriginValue&quot;];</span><br><span class="line"></span><br><span class="line">self.aCopyMStr= mstrOrigin;</span><br><span class="line">self.strongMStr= mstrOrigin;</span><br><span class="line">self.strongMStr= mstrOrigin;</span><br><span class="line">self.weakMStr= mstrOrigin;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;mstrOrigin输出:%p,%@\\n&quot;, mstrOrigin,mstrOrigin);</span><br><span class="line">NSLog(@&quot;aCopyMStr输出:%p,%@\\n&quot;,_aCopyMStr,_aCopyMStr);</span><br><span class="line">NSLog(@&quot;strongMStr输出:%p,%@\\n&quot;,_strongMStr,_strongMStr);</span><br><span class="line">NSLog(@&quot;weakMStr输出:%p,%@\\n&quot;,_weakMStr,_weakMStr);</span><br><span class="line">NSLog(@&quot;引用计数%@&quot;,[mstrOriginvalueForKey:@&quot;retainCount&quot;]);</span><br><span class="line"></span><br><span class="line">//输出结果</span><br><span class="line">//2016-09-01 15:19:13.134 lbCopy[1205:87583] mstrOrigin输出:0x7892a5e0,mstrOriginValue</span><br><span class="line">//2016-09-01 15:19:13.135 lbCopy[1205:87583] aCopyMStr输出:0x7893deb0,mstrOriginValue</span><br><span class="line">//2016-09-01 15:19:13.135 lbCopy[1205:87583] strongMStr输出:0x7892a5e0,mstrOriginValue</span><br><span class="line">//2016-09-01 15:19:13.135 lbCopy[1205:87583] weakMStr输出:0x7892a5e0,mstrOriginValue</span><br><span class="line">//2016-09-01 15:19:13.135 lbCopy[1205:87583] 引用计数2</span><br></pre></td></tr></table></figure>
<p>strongMStr和weakMStr指针指向的内存地址都和mstrOrigin相同,但mstrOrigin内存引用计数为2，不为3，因为weakMStr虽然指向了数据内存地址（之后用C简称，见示意图1），但不会增加C计数。copy修饰的的aCopyMStr，赋值后则是自己单独开辟了一块内存，内存上保存“mstrOrigin”字符串，并指向。</p>
<p>拷贝示意图如下</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1829796-23d123453eb7707e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/645" alt="img"></p>
<p>NSMutableString拷贝示意图2</p>
<p>可见当我修改mstrOrigin的值的时候，必然不会影响aCopyMStr,只会影响strongMStr和weakMStr。我们来验证下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;------------------修改原值后------------------------&quot;);</span><br><span class="line"></span><br><span class="line">[mstrOriginappendString:@&quot;1&quot;];</span><br><span class="line">NSLog(@&quot;mstrOrigin输出:%p,%@\\n&quot;, mstrOrigin,mstrOrigin);</span><br><span class="line">NSLog(@&quot;aCopyMStr输出:%p,%@\\n&quot;,_aCopyMStr,_aCopyMStr);</span><br><span class="line">NSLog(@&quot;strongMStr输出:%p,%@\\n&quot;,_strongMStr,_strongMStr);</span><br><span class="line">NSLog(@&quot;weakMStr输出:%p,%@\\n&quot;,_weakMStr,_weakMStr);</span><br><span class="line"></span><br><span class="line">//输出结果</span><br><span class="line">//2016-09-01 15:33:02.839 lbCopy[1205:87583] mstrOrigin输出:0x7892a5e0,mstrOrigin1</span><br><span class="line">//2016-09-01 15:33:02.839 lbCopy[1205:87583] aCopyMStr输出:0x7893deb0,mstrOrigin</span><br><span class="line">//2016-09-01 15:33:02.839 lbCopy[1205:87583] strongMStr输出:0x7892a5e0,mstrOrigin1</span><br><span class="line">//2016-09-01 15:33:02.839 lbCopy[1205:87583] weakMStr输出:0x7892a5e0,mstrOrigin1</span><br></pre></td></tr></table></figure>
<p>copy会重新开辟新的内存来保存一份相同的数据。被赋值对象和原值修改互不影响。strong和weak赋值都指向原来数据地址，区别是前者会对数据地址进行引用计数+1，后者不会</p>
<p>引用计数是否+1有什么实质区别呢？</p>
<p>如果知道“值地址的引用计数为0时，地址上保存的值就会被释放”。那么区别就不难理解，weak修饰的指针A指向的值地址C，那么地址上当其他指向他的指针被释放的时候，这个值地址引用计数也就变为0了，这个A的值也就为nil了。换句话说当值地址C上没有其他强引用指针修饰的时候C就会被立即释放，A的值就变为nil了。</p>
<p>这里我们来初始化mstrOrigin和并将strongMStr设置为nil让C的引用计数为0，然后输出weakMStr，看是否为nil.<br>注：初始化和设为nil都可以将指针所指向的数据地址引用计数减少1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mstrOrigin = [[NSMutableStringalloc]initWithString:@&quot;mstrOriginChange2&quot;];</span><br><span class="line">self.strongMStr=nil;</span><br><span class="line">NSLog(@&quot;mstrOrigin输出:%p,%@\\n&quot;, mstrOrigin,mstrOrigin);</span><br><span class="line">NSLog(@&quot;strongMStr输出:%p,%@\\n&quot;,_strongMStr,_strongMStr);</span><br><span class="line">NSLog(@&quot;weakMStr输出:%p,%@\\n&quot;,_weakMStr,_weakMStr);</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">//2016-09-01 15:41:33.793 lbCopy[1247:100742] mstrOrigin输出:0x7874d140,mstrOriginChange2</span><br><span class="line">//2016-09-01 15:41:33.793 lbCopy[1247:100742] strongMStr输出:0x0,(null)</span><br><span class="line">//2016-09-01 15:41:33.794 lbCopy[1247:100742] weakMStr输出:0x0,(null)</span><br></pre></td></tr></table></figure>
<p>可见之前引用计数2是mstrOrigin和strongMStr添加的。<br><strong>结论：copy会重新开辟新的内存来保存一份相同的数据。被赋值对象和原值修改互不影响。strong和weak虽然都指向原来数据地址，原值修改的时候storng和weak会随之变化。区别是前者会对数据地址进行引用计数+1防止原地址值被释放，但后者不会，当其他值都不在指向值地址时，值地址被释放，weak的值也就是为nil了。我们称会对数据地址增加引用计数的为强引用，不改变引用计数的为弱引用</strong></p>
<h3 id="1-2-assign和weak的区别"><a href="#1-2-assign和weak的区别" class="headerlink" title="1.2 assign和weak的区别"></a>1.2 assign和weak的区别</h3><p>对assign和weak修饰的值进行赋值，并输出指针结构地址和值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.assignMStr= mstrOrigin;</span><br><span class="line">self.weakMStr= mstrOrigin;</span><br><span class="line">mstrOrigin = [[NSMutableStringalloc]initWithString:@&quot;mstrOriginChange3&quot;];</span><br><span class="line">NSLog(@&quot;weakMStr输出:%p,%@\\n&quot;,_weakMStr,_weakMStr);</span><br><span class="line">NSLog(@&quot;assignMStr输出:%p,%@\\n&quot;,self.assignMStr,self.assignMStr);</span><br></pre></td></tr></table></figure>
<p>可以发现在输出assignMStr时会偶尔出现奔溃的情况。原因是发送了野指针的情况。assign同weak，指向C并且计数不+1，但当C地址引用计数为0时，assign不会对C地址进行B数据的抹除操作，只是进行值释放。这就导致野指针存在，即当这块地址还没写上其他值前，能输出正常值，但一旦重新写上数据，该指针随时可能没有值，造成奔溃。</p>
<h3 id="1-3那retain是什么"><a href="#1-3那retain是什么" class="headerlink" title="1.3那retain是什么"></a>1.3那retain是什么</h3><p>ARC之前属性构造器的关键字是retain,copy,assign，strong和weak是ARC带出来的关键字。<br><strong>retain现在同strong，就是指针指向值地址，同时进行引用计数加1。</strong></p>
<h2 id="2-非NSMutableString的情况"><a href="#2-非NSMutableString的情况" class="headerlink" title="2.非NSMutableString的情况"></a>2.非NSMutableString的情况</h2><p><br><br>上面我们讨论了典型的例子NSMutableString，即非容器可变变量。也就是说还存在其他三种类型需要讨论…</p>
<p>1.非容器不可变变量NSSting<br>2.容器可变变量NSMutableArray<br>3.容器不可变变量NSArray</p>
<p>更重要的是不同类型会有不同结果…，好吧，不要奔溃，上面一大段我们讨论了1/4，接下来我们要讨论其他的3/4情况。但好消息是，其他几种情况基本与上面非容器可变变量情况基本类似。</p>
<h3 id="2-1容器可变变量"><a href="#2-1容器可变变量" class="headerlink" title="2.1容器可变变量"></a>2.1容器可变变量</h3><p>容器可变变量的典型例子就是NSMutableArray<br>下面代码可以忽略，只做参考用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">@property(copy,nonatomic)NSMutableArray*aCopyMArr;</span><br><span class="line">@property(strong,nonatomic)NSMutableArray*strongMArr;</span><br><span class="line">@property(weak,nonatomic)NSMutableArray*weakMArr;</span><br><span class="line"></span><br><span class="line">NSMutableArray*mArrOrigin = [[NSMutableArrayalloc]init];</span><br><span class="line">NSMutableString*mstr1 = [[NSMutableStringalloc]initWithString:@&quot;value1&quot;];</span><br><span class="line">NSMutableString*mstr2 = [[NSMutableStringalloc]initWithString:@&quot;value2&quot;];</span><br><span class="line">NSMutableString*mstr3 = [[NSMutableStringalloc]initWithString:@&quot;value3&quot;];</span><br><span class="line"></span><br><span class="line">[mArrOriginaddObject:mstr1];</span><br><span class="line">[mArrOriginaddObject:mstr2];</span><br><span class="line"></span><br><span class="line">//将mArrOrigin拷贝给aCopyMArr，strongMArr，weakMArr</span><br><span class="line">self.aCopyMArr= mArrOrigin;</span><br><span class="line">self.strongMArr= mArrOrigin;</span><br><span class="line">self.weakMArr= mArrOrigin;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;mArrOrigin输出:%p,%@\\n&quot;, mArrOrigin,mArrOrigin);</span><br><span class="line">NSLog(@&quot;aCopyMArr输出:%p,%@\\n&quot;,_aCopyMArr,_aCopyMArr);</span><br><span class="line">NSLog(@&quot;strongMArr输出:%p,%@\\n&quot;,_strongMArr,_strongMArr);</span><br><span class="line">NSLog(@&quot;weakMArr输出:%p,%@\\n&quot;,_weakMArr,_weakMArr);</span><br><span class="line">NSLog(@&quot;weakMArr输出:%p,%@\\n&quot;,_weakMArr[0],_weakMArr[0]);</span><br><span class="line">NSLog(@&quot;mArrOrigin中的数据引用计数%@&quot;, [mArrOriginvalueForKey:@&quot;retainCount&quot;]);</span><br><span class="line">NSLog(@&quot;%p %p %p %p&quot;,&amp;mArrOrigin,mArrOrigin,mArrOrigin[0],mArrOrigin[1]);</span><br><span class="line"></span><br><span class="line">//以下是输出</span><br><span class="line">2016-09-02 20:42:30.777 lbCopy[4207:475091] mArrOrigin输出:0x78f81680,(</span><br><span class="line">value1,</span><br><span class="line">value2</span><br><span class="line">)</span><br><span class="line">2016-09-02 20:42:30.777 lbCopy[4207:475091] aCopyMArr输出:0x7a041340,(</span><br><span class="line">value1,</span><br><span class="line">value2</span><br><span class="line">)</span><br><span class="line">2016-09-02 20:42:30.777 lbCopy[4207:475091] strongMArr输出:0x78f81680,(</span><br><span class="line">value1,</span><br><span class="line">value2</span><br><span class="line">)</span><br><span class="line">2016-09-02 20:42:30.777 lbCopy[4207:475091] weakMArr输出:0x78f81680,(</span><br><span class="line">value1,</span><br><span class="line">value2</span><br><span class="line">)</span><br><span class="line">2016-09-02 20:42:30.777 lbCopy[4207:475091] weakMArr输出:0x78f816a0,value1</span><br><span class="line">2016-09-02 20:42:30.778 lbCopy[4207:475091] mArrOrigin中的数据引用计数(</span><br><span class="line">3,</span><br><span class="line">3</span><br><span class="line">)</span><br><span class="line">2016-09-02 20:42:30.778 lbCopy[4207:475091] 0xbffb4098 0x78f81680 0x78f816a0 0x78f81710</span><br><span class="line">//以上是输出</span><br><span class="line"></span><br><span class="line">//给原数组添加一个元素</span><br><span class="line">[mArrOriginaddObject:mstr3];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;mArrOrigin输出:%p,%@\\n&quot;, mArrOrigin,mArrOrigin);</span><br><span class="line">NSLog(@&quot;aCopyMArr输出:%p,%@\\n&quot;,_aCopyMArr,_aCopyMArr);</span><br><span class="line">NSLog(@&quot;strongMArr输出:%p,%@\\n&quot;,_strongMArr,_strongMArr);</span><br><span class="line">NSLog(@&quot;weakMArr输出:%p,%@\\n&quot;,_weakMArr,_weakMArr);</span><br><span class="line">NSLog(@&quot;mArrOrigin中的数据引用计数%@&quot;, [mArrOriginvalueForKey:@&quot;retainCount&quot;]);</span><br><span class="line"></span><br><span class="line">//修改原数组中的元素，看是否有随之变化</span><br><span class="line">[mstr1appendFormat:@&quot;aaa&quot;];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;mArrOrigin输出:%p,%@\\n&quot;, mArrOrigin,mArrOrigin);</span><br><span class="line">NSLog(@&quot;aCopyMArr输出:%p,%@\\n&quot;,_aCopyMArr,_aCopyMArr);</span><br><span class="line">NSLog(@&quot;strongMArr输出:%p,%@\\n&quot;,_strongMArr,_strongMArr);</span><br><span class="line">NSLog(@&quot;weakMArr输出:%p,%@\\n&quot;,_weakMArr,_weakMArr);</span><br><span class="line"></span><br><span class="line">//以下是输出</span><br><span class="line">2016-09-02 20:42:30.778 lbCopy[4207:475091] mArrOrigin输出:0x78f81680,(</span><br><span class="line">value1,</span><br><span class="line">value2,</span><br><span class="line">value3</span><br><span class="line">)</span><br><span class="line">2016-09-02 20:42:30.778 lbCopy[4207:475091] aCopyMArr输出:0x7a041340,(</span><br><span class="line">value1,</span><br><span class="line">value2</span><br><span class="line">)</span><br><span class="line">2016-09-02 20:42:30.778 lbCopy[4207:475091] strongMArr输出:0x78f81680,(</span><br><span class="line">value1,</span><br><span class="line">value2,</span><br><span class="line">value3</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">2016-09-02 20:42:30.778 lbCopy[4207:475091] weakMArr输出:0x78f81680,(</span><br><span class="line">value1,</span><br><span class="line">value2,</span><br><span class="line">value3</span><br><span class="line">)</span><br><span class="line">2016-09-02 20:42:30.779 lbCopy[4207:475091] mArrOrigin中的数据引用计数(</span><br><span class="line">3,</span><br><span class="line">3,</span><br><span class="line">2</span><br><span class="line">)</span><br><span class="line">2016-09-02 20:42:30.779 lbCopy[4207:475091] mArrOrigin输出:0x78f81680,(</span><br><span class="line">value1aaa,</span><br><span class="line">value2,</span><br><span class="line">value3</span><br><span class="line">)</span><br><span class="line">2016-09-02 20:42:30.779 lbCopy[4207:475091] aCopyMArr输出:0x7a041340,(</span><br><span class="line">value1aaa,</span><br><span class="line">value2</span><br><span class="line">)</span><br><span class="line">2016-09-02 20:42:30.779 lbCopy[4207:475091] strongMArr输出:0x78f81680,(</span><br><span class="line">value1aaa,</span><br><span class="line">value2,</span><br><span class="line">value3</span><br><span class="line">)</span><br><span class="line">2016-09-02 20:42:30.779 lbCopy[4207:475091] weakMArr输/出:0x78f81680,(</span><br><span class="line">value1aaa,</span><br><span class="line">value2,</span><br><span class="line">value3</span><br><span class="line">)</span><br><span class="line">//以上是输出</span><br></pre></td></tr></table></figure>
<p>上面代码有点多，所做的操作是mArrOrigin（value1,value2）赋值给copy,strong,weak修饰的aCopyMArr,strongMArr,weakMArr。通过给原数组增加元素，修改原数组元素值，然后输出mArrOrigin的引用计数，和数组地址，查看变化。<br>发现其中数组本身指向的内存地址除了aCopyMArr重新开辟了一块地址，strongMArr,weakMArr和mArrOrigin指针指向的地址是一样的。也就是说</p>
<p><strong>容器可变变量中容器本身和非容器可变变量是一样的，copy深拷贝，strongMArr,weakMArr和assign都是浅拷贝</strong></p>
<p>另外我们发现被拷贝对象mArrOrigin中的数据引用计数居然不是1而是3。也就是说容器内的数据拷贝都是进行了浅拷贝。同时当我们修改数组中的一个数据时strongMArr,weakMArr，aCopyMArr中的数据都改变了，说明</p>
<p><strong>容器可变变量中的数据在拷贝的时候都是浅拷贝</strong></p>
<p>容器可变变量的拷贝结构如下图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1829796-5fec2788d9c9c6b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/692" alt="img"></p>
<p>NSMutableArray拷贝示意图3</p>
<p>2.2非容器不变变量</p>
<p>典型例子是NSString</p>
<p>我们还是以代码引出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">@property(copy,nonatomic)NSString*aCopyStr;</span><br><span class="line">@property(strong,nonatomic)NSString*strongStr;</span><br><span class="line">@property(weak,nonatomic)NSString*weakStr;</span><br><span class="line">@property(assign,nonatomic)NSString*assignStr;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;\\n\\n\\n\\n------------------不可变量实验------------------------&quot;);</span><br><span class="line"></span><br><span class="line">NSString*strOrigin = [[NSStringalloc]initWithUTF8String:&quot;strOrigin0123456&quot;];</span><br><span class="line"></span><br><span class="line">self.aCopyStr= strOrigin;</span><br><span class="line"></span><br><span class="line">self.strongStr= strOrigin;</span><br><span class="line"></span><br><span class="line">self.weakStr= strOrigin;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;strOrigin输出:%p,%@\\n&quot;, strOrigin,strOrigin);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;aCopyStr输出:%p,%@\\n&quot;,_aCopyStr,_aCopyStr);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;strongStr输出:%p,%@\\n&quot;,_strongStr,_strongStr);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;weakStr输出:%p,%@\\n&quot;,_weakStr,_weakStr);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;------------------修改原值后------------------------&quot;);</span><br><span class="line"></span><br><span class="line">strOrigin =@&quot;aaa&quot;;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;strOrigin输出:%p,%@\\n&quot;, strOrigin,strOrigin);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;aCopyStr输出:%p,%@\\n&quot;,_aCopyStr,_aCopyStr);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;strongStr输出:%p,%@\\n&quot;,_strongStr,_strongStr);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;weakStr输出:%p,%@\\n&quot;,_weakStr,_weakStr);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;------------------结论------------------------&quot;);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;strOrigin值值为改变，但strOrigin和aCopyStr指针地址和指向都已经改变，说明不可变类型值不可被修改，重新初始化&quot;);</span><br><span class="line"></span><br><span class="line">self.aCopyStr=nil;</span><br><span class="line"></span><br><span class="line">self.strongStr=nil;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;strOrigin输出:%p,%@\\n&quot;, strOrigin,strOrigin);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;aCopyStr输出:%p,%@\\n&quot;,_aCopyStr,_aCopyStr);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;strongStr输出:%p,%@\\n&quot;,_strongStr,_strongStr);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;weakStr输出:%p,%@\\n&quot;,_weakStr,_weakStr);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;------------------结论------------------------&quot;);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;当只有weakStr拥有C时，值依旧会被释放，同非容器可变变量&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//以下是输出</span><br><span class="line"></span><br><span class="line">------------------不可变量实验------------------------</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.053 lbCopy[4297:488549] strOrigin输出:0x7a2550d0,strOrigin0123456</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.053 lbCopy[4297:488549] aCopyStr输出:0x7a2550d0,strOrigin0123456</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.054 lbCopy[4297:488549] strongStr输出:0x7a2550d0,strOrigin0123456</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.054 lbCopy[4297:488549] weakStr输出:0x7a2550d0,strOrigin0123456</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.054 lbCopy[4297:488549] strOrigin值内存引用计数3</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.054 lbCopy[4297:488549] ------------------修改原值后------------------------</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.054 lbCopy[4297:488549] strOrigin输出:0x8c1f8,aaa</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.054 lbCopy[4297:488549] aCopyStr输出:0x7a2550d0,strOrigin0123456</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.054 lbCopy[4297:488549] strongStr输出:0x7a2550d0,strOrigin0123456</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.055 lbCopy[4297:488549] weakStr输出:0x7a2550d0,strOrigin0123456</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.055 lbCopy[4297:488549] ------------------结论------------------------</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.055 lbCopy[4297:488549] strOrigin值值为改变，但strOrigin和aCopyStr指针地址和指向都已经改变，说明不可变类型值不可被修改，重新初始化</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.059 lbCopy[4297:488549] strOrigin输出:0x8c1f8,aaa</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.059 lbCopy[4297:488549] aCopyStr输出:0x0,(null)</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.060 lbCopy[4297:488549] strongStr输出:0x0,(null)</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.060 lbCopy[4297:488549] weakStr输出:0x0,(null)</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.060 lbCopy[4297:488549] ------------------结论------------------------</span><br><span class="line"></span><br><span class="line">2016-09-02 21:08:44.061 lbCopy[4297:488549]当只有weakStr拥有C时，值依旧会被释放，同非容器可变变量</span><br><span class="line">//以上是输出</span><br></pre></td></tr></table></figure>
<p>此处我们将strOrigin拷贝给aCopyStr，strongStr，weakStr，然后输出他们的值地址，发现他们四个的值地址一样，且strOrigin值的引用计数为3。修改strOrigin和发现strOrigin值地址改变，其他三个值地址不变，将aCopyStr，strongStr设为nil后，发现weakStr随之nil。</p>
<p>综合上面现象NSString和NSMutableString（非容器可变变量）基本相同，除了copy，NSString为浅拷贝，NSMutableString是深拷贝。那么为什么NSString的copy是浅拷贝呢，也就是说为什么aCopyStr不自己开辟一个独立的内存出来呢。答案很简单，因为不可变量的值不会改变，既然都不会改变，所以没必要重新开辟一个内存出来让aCopyStr指向他，直接指向原来值位置就可以了。示意图如下</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1829796-93b7a0f217ca3baa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/644" alt="img"></p>
<p>NSString拷贝示意图4</p>
<p><strong>所以非容器不可变量除了copy其他特性同非容器可变变量，copy是浅拷贝</strong></p>
<h3 id="2-3不可变容器变量"><a href="#2-3不可变容器变量" class="headerlink" title="2.3不可变容器变量"></a>2.3不可变容器变量</h3><p>典型对象NSArray。该对象实验自行实验。但结论在这里给出，其实不实验也可以大概知道概率<br>在不可变容器变量中，容器本身都是浅拷贝包括copy，同NSString，容器里面的数据都是浅拷贝，同NSMutableArray。</p>
<p>3.总结<br>copy，strong，weak，assign的区别。</p>
<p>可变变量中，copy是重新开辟一个内存，strong，weak，assgin后三者不开辟内存，只是指针指向原来保存值的内存的位置，storng指向后会对该内存引用计数+1，而weak，assgin不会。weak，assgin会在引用保存值的内存引用计数为0的时候值为空，并且weak会将内存值设为nil，assign不会，assign在内存没有被重写前依旧可以输出，但一旦被重写将出现奔溃</p>
<p>不可变变量中，因为值本身不可被改变，copy没必要开辟出一块内存存放和原来内存一模一样的值，所以内存管理系统默认都是浅拷贝。其他和可变变量一样，如weak修饰的变量同样会在内存引用计数为0时变为nil。</p>
<p>容器本身遵守上面准则，但容器内部的每个值都是浅拷贝。</p>
<p><strong>综上所述，当创建property构造器创建变量value1的时候，使用copy，strong，weak，assign根据具体使用情况来决定。value1 = value2，如果你希望value1和value2的修改不会互相影响的就用用copy，反之用strong,weak,assign。如果你还希望原来值C(C是什么见示意图1)为nil的时候，你的变量不为nil就用strong,反之用weak和assign。weak和assign保证了不强引用某一块内存，如delegate我们就用weak表示，就是为了防止循环引用的产生。<br>另外，我们上面讨论的是类变量，直接创建局部变量默认是Strong修饰
</strong></p>
<h4 id="补充：delegate为什么要用weak或者assign而不用strong"><a href="#补充：delegate为什么要用weak或者assign而不用strong" class="headerlink" title="补充：delegate为什么要用weak或者assign而不用strong"></a>补充：delegate为什么要用weak或者assign而不用strong</h4><p>a创建对象b,b中有C类对象c，所以a对b有一个引用,b对c有一个引用，a.b引用计数分别为1，1。当c.delegate = b的时候，实则是对b有了一个引用，如果此时c的delegate用strong修饰则会对b的值内存引用计数+1，b引用计数为2。当a的生命周期结束，随之释放对b的引用，b的引用计数变为1，导致b不能释放，b不能释放又导致b对c的引用不能释放，c引用计数还是为1，这样就造成了b和c一直留在了内存中。</p>
<p>而要解决这个问题就是使用weak或者assign修饰delegate，这样虽然会有c仍然会对b有一个引用，但是引用是弱引用，当a生命周期结束的时候，b的引用计数变为0，b释放后随之c的引用消失，c引用计数变为0，释放。</p>
<h2 id="不可变常量的特殊性"><a href="#不可变常量的特殊性" class="headerlink" title="不可变常量的特殊性"></a>不可变常量的特殊性</h2><p>在2.2的讨论中如果你<br>1.字符串改成小于10长度的字符串<br>2.NSString*strOrigin = @”strOrigin0123456”;<br>初始化NSString，你都会发现strOrigin值内存引用计数将发生异常，通常表现为引用计数特别大，具体可以看下<a href="https://www.jianshu.com/p/f26e1fb64f7f" target="_blank" rel="noopener">iOS中NSString的特别之处</a>这篇文章</p>
<p>项目地址<a href="https://link.jianshu.com/?t=https://github.com/ai966669/copy" target="_blank" rel="noopener">https://github.com/ai966669/copy</a><br><a href="https://www.jianshu.com/p/a29a0bdd5da8" target="_blank" rel="noopener">转自</a></p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/09/14/深拷贝与浅拷贝/" rel="next" title="深拷贝与浅拷贝">
                <i class="fa fa-chevron-left"></i> 深拷贝与浅拷贝
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/09/14/内存布局/" rel="prev" title="内存布局">
                内存布局 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Sun Lei</p>
              <p class="site-description motion-element" itemprop="description">只有用心才能看清楚·真正重要的东西·用眼睛是看不见的</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">32</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-assign和weak的区别"><span class="nav-number">1.</span> <span class="nav-text">1.2 assign和weak的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3那retain是什么"><span class="nav-number">2.</span> <span class="nav-text">1.3那retain是什么</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-非NSMutableString的情况"><span class="nav-number"></span> <span class="nav-text">2.非NSMutableString的情况</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1容器可变变量"><span class="nav-number">1.</span> <span class="nav-text">2.1容器可变变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3不可变容器变量"><span class="nav-number">2.</span> <span class="nav-text">2.3不可变容器变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#补充：delegate为什么要用weak或者assign而不用strong"><span class="nav-number">2.1.</span> <span class="nav-text">补充：delegate为什么要用weak或者assign而不用strong</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不可变常量的特殊性"><span class="nav-number"></span> <span class="nav-text">不可变常量的特殊性</span></a></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sun Lei</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.4.4</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Muse</a> v6.4.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.1"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
