<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.1" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.1">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.4.1',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="1. GCD 简介 什么是 GCD 呢？我们先来看看百度百科的解释简单了解下概念。  引自百度百科 Grand Central Dispatch(GCD) 是 Apple 开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并发任务。在 Mac OS X 10.6 雪豹中首次推出，也可在 iOS 4 及以上版本使用。">
<meta property="og:type" content="article">
<meta property="og:title" content="GCD">
<meta property="og:url" content="http://yoursite.com/iOS面试/2018/09/17/GCD/index.html">
<meta property="og:site_name" content="Man Tou Pu&#39;s Blog">
<meta property="og:description" content="1. GCD 简介 什么是 GCD 呢？我们先来看看百度百科的解释简单了解下概念。  引自百度百科 Grand Central Dispatch(GCD) 是 Apple 开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并发任务。在 Mac OS X 10.6 雪豹中首次推出，也可在 iOS 4 及以上版本使用。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/2/24/161c5e4c0c8b1684?imageslim">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/2/24/161c5e4c21aa3095?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/2/24/161c624e8be89b51?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="http://cc.cocimg.com/api/uploads//20180313/1520928198551422.png">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/2/24/161c6258a0c04a71?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:updated_time" content="2018-09-17T04:05:47.138Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GCD">
<meta name="twitter:description" content="1. GCD 简介 什么是 GCD 呢？我们先来看看百度百科的解释简单了解下概念。  引自百度百科 Grand Central Dispatch(GCD) 是 Apple 开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并发任务。在 Mac OS X 10.6 雪豹中首次推出，也可在 iOS 4 及以上版本使用。">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2018/2/24/161c5e4c0c8b1684?imageslim">






  <link rel="canonical" href="http://yoursite.com/iOS面试/2018/09/17/GCD/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>GCD | Man Tou Pu's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Man Tou Pu's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">技术、生活个人博客</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/iOS面试/2018/09/17/GCD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Lei">
      <meta itemprop="description" content="只有用心才能看清楚·真正重要的东西·用眼睛是看不见的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Man Tou Pu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">GCD
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-17 12:01:23 / 修改时间：12:05:47" itemprop="dateCreated datePublished" datetime="2018-09-17T12:01:23+08:00">2018-09-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/多线程/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><strong>1. GCD 简介</strong></p>
<p>什么是 GCD 呢？我们先来看看百度百科的解释简单了解下概念。</p>
<blockquote>
<p>引自<a href="https://link.juejin.im/?target=http%3A%2F%2Fbaike.baidu.com%2Fitem%2FGCD" target="_blank" rel="noopener">百度百科</a></p>
<p>Grand Central Dispatch(GCD) 是 Apple 开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并发任务。在 Mac OS X 10.6 雪豹中首次推出，也可在 iOS 4 及以上版本使用。</p>
</blockquote>
<p><strong>为什么要用 GCD 呢？</strong></p>
<p>因为 GCD 有很多好处啊，具体如下：</p>
<ul>
<li>GCD 可用于多核的并行运算</li>
<li>GCD 会自动利用更多的 CPU 内核（比如双核、四核）</li>
<li>GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li>
<li>程序员只需要告诉 GCD 想要执行什么任务，不需要编写任何线程管理代码</li>
</ul>
<p>既然 GCD 有这么多的好处，那么下面我们就来系统的学习一下 GCD 的使用方法。</p>
<p><strong>2. GCD 任务和队列</strong></p>
<p>学习 GCD 之前，先来了解 GCD 中两个核心概念：任务和队列。</p>
<p><strong>任务</strong>：就是执行操作的意思，换句话说就是你在线程中执行的那段代码。在 GCD 中是放在 block 中的。执行任务有两种方式：<strong>同步执行（sync）和异步执行（async）</strong>。两者的主要区别是：<strong>是否等待队列的任务执行结束，以及是否具备开启新线程的能力。</strong></p>
<blockquote>
<ul>
<li><strong>同步执行（sync）：</strong></li>
</ul>
<p>同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。</p>
<p>只能在当前线程中执行任务，不具备开启新线程的能力。</p>
<ul>
<li><strong>异步执行（async）：</strong></li>
</ul>
<p>异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。</p>
<p>可以在新的线程中执行任务，具备开启新线程的能力。</p>
</blockquote>
<p>举个简单例子：你要打电话给小明和小白。</p>
<p>同步执行就是，你打电话给小明的时候，不能同时打给小白，等到给小明打完了，才能打给小白（等待任务执行结束）。而且只能用当前的电话（不具备开启新线程的能力）。</p>
<p>而异步执行就是，你打电话给小明的时候，不等和小明通话结束，还能直接给小白打电话，不用等着和小明通话结束再打（不用等待任务执行结束）。除了当前电话，你还可以使用其他所能使用的电话（具备开启新线程的能力）。</p>
<blockquote>
<p>注意： 异步执行（async） 虽然具有开启新线程的能力，但是并不一定开启新线程。这跟任务所指定的队列类型有关（下面会讲）。</p>
</blockquote>
<p><strong>队列（Dispatch Queue）</strong>：这里的队列指执行任务的等待队列，即用来存放任务的队列。队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。队列的结构可参考下图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/2/24/161c5e4c0c8b1684?imageslim" alt="img"></p>
<p>在 GCD 中有两种队列：串行队列和并发队列。两者都符合 FIFO（先进先出）的原则。两者的主要区别是：执行顺序不同，以及开启线程数不同。</p>
<p><strong>串行队列（Serial Dispatch Queue）：</strong></p>
<p>每次只有一个任务被执行。让任务一个接着一个地执行。（只开启一个线程，一个任务执行完毕后，再执行下一个任务）</p>
<p><strong>并发队列（Concurrent Dispatch Queue）：</strong></p>
<p>可以让多个任务并发（同时）执行。（可以开启多个线程，并且同时执行任务）</p>
<blockquote>
<p>注意：并发队列 的并发功能只有在异步（dispatch_async）函数下才有效</p>
</blockquote>
<p>两者具体区别如下两图所示。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/2/24/161c5e4c21aa3095?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/2/24/161c624e8be89b51?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"><strong>3. GCD 的使用步骤</strong></p>
<p>GCD 的使用步骤其实很简单，只有两步。</p>
<ol>
<li>创建一个队列（串行队列或并发队列）</li>
<li>将任务追加到任务的等待队列中，然后系统就会根据任务类型执行任务（同步执行或异步执行）</li>
</ol>
<p>下边来看看 <strong>队列的创建方法/获取方法</strong>，以及 <strong>任务的创建方法</strong>。</p>
<p><strong>3.1 队列的创建方法/获取方法</strong></p>
<ul>
<li>可以使用dispatch_queue_create来创建队列，需要传入两个参数，第一个参数表示队列的唯一标识符，用于 DEBUG，可为空，Dispatch Queue 的名称推荐使用应用程序 ID 这种逆序全程域名；第二个参数用来识别是串行队列还是并发队列。DISPATCH_QUEUE_SERIAL 表示串行队列，DISPATCH_QUEUE_CONCURRENT 表示并发队列。</li>
</ul>
<ul>
<li>对于串行队列，GCD 提供了的一种特殊的串行队列：<strong>主队列（Main Dispatch Queue）</strong>。</li>
</ul>
<ul>
<li>所有放在主队列中的任务，都会放到主线程中执行。</li>
<li>可使用dispatch_get_main_queue()获得主队列。</li>
</ul>
<ul>
<li>对于并发队列，GCD 默认提供了<strong>全局并发队列（Global Dispatch Queue）</strong>。</li>
</ul>
<ul>
<li>可以使用dispatch_get_global_queue来获取。需要传入两个参数。第一个参数表示队列优先级，一般用DISPATCH_QUEUE_PRIORITY_DEFAULT。第二个参数暂时没用，用0即可。</li>
</ul>
<p><strong>3.2 任务的创建方法</strong></p>
<p>GCD 提供了同步执行任务的创建方法dispatch_sync和异步执行任务创建方法dispatch_async。</p>
<p>虽然使用 GCD 只需两步，但是既然我们有两种队列（串行队列/并发队列），两种任务执行方式（同步执行/异步执行），那么我们就有了四种不同的组合方式。这四种不同的组合方式是：</p>
<blockquote>
<p>1.同步执行 + 并发队列</p>
<p>2.异步执行 + 并发队列</p>
<p>3.同步执行 + 串行队列</p>
<p>4.异步执行 + 串行队列</p>
</blockquote>
<p>实际上，刚才还说了两种特殊队列：全局并发队列、主队列。全局并发队列可以作为普通并发队列来使用。但是主队列因为有点特殊，所以我们就又多了两种组合方式。这样就有六种不同的组合方式了。</p>
<blockquote>
<p>5.同步执行 + 主队列</p>
<p>6.异步执行 + 主队列</p>
</blockquote>
<p>那么这几种不同组合方式各有什么区别呢，这里为了方便，先上结果，再来讲解。你可以直接查看表格结果，然后跳过 <strong>4. GCD 的基本使用 。</strong></p>
<p><img src="http://cc.cocimg.com/api/uploads//20180313/1520928198551422.png" alt="微信图片_20180313160225.png"></p>
<p>下边我们来分别讲讲这几种不同的组合方式的使用方法。</p>
<p><strong>4. GCD 的基本使用</strong></p>
<p>先来讲讲并发队列的两种执行方式。</p>
<p><strong>4.1 同步执行 + 并发队列</strong></p>
<ul>
<li>在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。</li>
</ul>
<blockquote>
<p>输出结果：</p>
<p>2018-02-23 20:34:55.095932+0800 YSC-GCD-demo[19892:4996930] currentThread—{number = 1, name = main}</p>
<p>2018-02-23 20:34:55.096086+0800 YSC-GCD-demo[19892:4996930] syncConcurrent—begin</p>
<p>2018-02-23 20:34:57.097589+0800 YSC-GCD-demo[19892:4996930] 1—{number = 1, name = main}</p>
<p>2018-02-23 20:34:59.099100+0800 YSC-GCD-demo[19892:4996930] 1—{number = 1, name = main}</p>
<p>2018-02-23 20:35:01.099843+0800 YSC-GCD-demo[19892:4996930] 2—{number = 1, name = main}</p>
<p>2018-02-23 20:35:03.101171+0800 YSC-GCD-demo[19892:4996930] 2—{number = 1, name = main}</p>
<p>2018-02-23 20:35:05.101750+0800 YSC-GCD-demo[19892:4996930] 3—{number = 1, name = main}</p>
<p>2018-02-23 20:35:07.102414+0800 YSC-GCD-demo[19892:4996930] 3—{number = 1, name = main}</p>
<p>2018-02-23 20:35:07.102575+0800 YSC-GCD-demo[19892:4996930] syncConcurrent—end</p>
</blockquote>
<p>从同步执行 + 并发队列中可看到：</p>
<ul>
<li>所有任务都是在当前线程（主线程）中执行的，没有开启新的线程（同步执行不具备开启新线程的能力）。</li>
<li>所有任务都在打印的syncConcurrent—begin和syncConcurrent—end之间执行的（同步任务需要等待队列的任务执行结束）。</li>
<li>任务按顺序执行的。按顺序执行的原因：虽然并发队列可以开启多个线程，并且同时执行多个任务。但是因为本身不能创建新线程，只有当前线程这一个线程（同步任务不具备开启新线程的能力），所以也就不存在并发。而且当前线程只有等待当前队列中正在执行的任务执行完毕之后，才能继续接着执行下面的操作（同步任务需要等待队列的任务执行结束）。所以任务只能一个接一个按顺序执行，不能同时被执行。</li>
</ul>
<p><strong>4.2 异步执行 + 并发队列</strong></p>
<p>可以开启多个线程，任务交替（同时）执行。</p>
<blockquote>
<p>输出结果：</p>
<p>2018-02-23 20:36:41.769269+0800 YSC-GCD-demo[19929:5005237] currentThread—{number = 1, name = main}</p>
<p>2018-02-23 20:36:41.769496+0800 YSC-GCD-demo[19929:5005237] asyncConcurrent—begin</p>
<p>2018-02-23 20:36:41.769725+0800 YSC-GCD-demo[19929:5005237] asyncConcurrent—end</p>
<p>2018-02-23 20:36:43.774442+0800 YSC-GCD-demo[19929:5005566] 2—{number = 5, name = (null)}</p>
<p>2018-02-23 20:36:43.774440+0800 YSC-GCD-demo[19929:5005567] 3—{number = 4, name = (null)}</p>
<p>2018-02-23 20:36:43.774440+0800 YSC-GCD-demo[19929:5005565] 1—{number = 3, name = (null)}</p>
<p>2018-02-23 20:36:45.779286+0800 YSC-GCD-demo[19929:5005567] 3—{number = 4, name = (null)}</p>
<p>2018-02-23 20:36:45.779302+0800 YSC-GCD-demo[19929:5005565] 1—{number = 3, name = (null)}</p>
<p>2018-02-23 20:36:45.779286+0800 YSC-GCD-demo[19929:5005566] 2—{number = 5, name = (null)}</p>
</blockquote>
<p>在异步执行 + 并发队列中可以看出：</p>
<p>除了当前线程（主线程），系统又开启了3个线程，并且任务是交替/同时执行的。（异步执行具备开启新线程的能力。且并发队列可开启多个线程，同时执行多个任务）。</p>
<p>所有任务是在打印的syncConcurrent—begin和syncConcurrent—end之后才执行的。说明当前线程没有等待，而是直接开启了新线程，在新线程中执行任务（异步执行不做等待，可以继续执行任务）。</p>
<p><strong>接下来再来讲讲串行队列的两种执行方式。</strong></p>
<p><strong>4.3 同步执行 + 串行队列</strong></p>
<ul>
<li>不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。</li>
</ul>
<blockquote>
<p>输出结果：</p>
<p>2018-02-23 20:39:37.876811+0800 YSC-GCD-demo[19975:5017162] currentThread—{number = 1, name = main}</p>
<p>2018-02-23 20:39:37.876998+0800 YSC-GCD-demo[19975:5017162] syncSerial—begin</p>
<p>2018-02-23 20:39:39.878316+0800 YSC-GCD-demo[19975:5017162] 1—{number = 1, name = main}</p>
<p>2018-02-23 20:39:41.879829+0800 YSC-GCD-demo[19975:5017162] 1—{number = 1, name = main}</p>
<p>2018-02-23 20:39:43.880660+0800 YSC-GCD-demo[19975:5017162] 2—{number = 1, name = main}</p>
<p>2018-02-23 20:39:45.881265+0800 YSC-GCD-demo[19975:5017162] 2—{number = 1, name = main}</p>
<p>2018-02-23 20:39:47.882257+0800 YSC-GCD-demo[19975:5017162] 3—{number = 1, name = main}</p>
<p>2018-02-23 20:39:49.883008+0800 YSC-GCD-demo[19975:5017162] 3—{number = 1, name = main}</p>
<p>2018-02-23 20:39:49.883253+0800 YSC-GCD-demo[19975:5017162] syncSerial—end</p>
</blockquote>
<p>在同步执行 + 串行队列可以看到：</p>
<ul>
<li>所有任务都是在当前线程（主线程）中执行的，并没有开启新的线程（同步执行不具备开启新线程的能力）。</li>
<li>所有任务都在打印的syncConcurrent—begin和syncConcurrent—end之间执行（同步任务需要等待队列的任务执行结束）。</li>
<li>任务是按顺序执行的（串行队列每次只有一个任务被执行，任务一个接一个按顺序执行）。</li>
</ul>
<p><strong>4.4 异步执行 + 串行队列</strong></p>
<ul>
<li>会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务</li>
</ul>
<blockquote>
<p>输出结果：</p>
<p>2018-02-23 20:41:17.029999+0800 YSC-GCD-demo[20008:5024757] currentThread—{number = 1, name = main}</p>
<p>2018-02-23 20:41:17.030212+0800 YSC-GCD-demo[20008:5024757] asyncSerial—begin</p>
<p>2018-02-23 20:41:17.030364+0800 YSC-GCD-demo[20008:5024757] asyncSerial—end</p>
<p>2018-02-23 20:41:19.035379+0800 YSC-GCD-demo[20008:5024950] 1—{number = 3, name = (null)}</p>
<p>2018-02-23 20:41:21.037140+0800 YSC-GCD-demo[20008:5024950] 1—{number = 3, name = (null)}</p>
<p>2018-02-23 20:41:23.042220+0800 YSC-GCD-demo[20008:5024950] 2—{number = 3, name = (null)}</p>
<p>2018-02-23 20:41:25.042971+0800 YSC-GCD-demo[20008:5024950] 2—{number = 3, name = (null)}</p>
<p>2018-02-23 20:41:27.047690+0800 YSC-GCD-demo[20008:5024950] 3—{number = 3, name = (null)}</p>
<p>2018-02-23 20:41:29.052327+0800 YSC-GCD-demo[20008:5024950] 3—{number = 3, name = (null)}</p>
</blockquote>
<p>在异步执行 + 串行队列可以看到：</p>
<ul>
<li>开启了一条新线程（异步执行具备开启新线程的能力，串行队列只开启一个线程）。</li>
<li>所有任务是在打印的syncConcurrent—begin和syncConcurrent—end之后才开始执行的（异步执行不会做任何等待，可以继续执行任务）。</li>
<li>任务是按顺序执行的（串行队列每次只有一个任务被执行，任务一个接一个按顺序执行）。</li>
</ul>
<p>下边讲讲刚才我们提到过的特殊队列：<strong>主队列</strong>。</p>
<ul>
<li>主队列：GCD自带的一种特殊的<strong>串行队列</strong></li>
</ul>
<ul>
<li>所有放在主队列中的任务，都会放到主线程中执行</li>
<li>可使用dispatch_get_main_queue()获得主队列</li>
</ul>
<p><strong>我们再来看看主队列的两种组合方式。</strong></p>
<p><strong>4.5 同步执行 + 主队列</strong></p>
<p>同步执行 + 主队列在不同线程中调用结果也是不一样，在主线程中调用会出现死锁，而在其他线程中则不会。</p>
<p><strong>4.5.1 在主线程中调用同步执行 + 主队列</strong></p>
<ul>
<li>互相等待卡住不可行</li>
</ul>
<blockquote>
<p>输出结果：</p>
<p>2018-02-23 20:42:36.842892+0800 YSC-GCD-demo[20041:5030982] currentThread—{number = 1, name = main}</p>
<p>2018-02-23 20:42:36.843050+0800 YSC-GCD-demo[20041:5030982] syncMain—begin</p>
<p>(lldb)</p>
</blockquote>
<p>在同步执行 + 主队列可以惊奇的发现：</p>
<ul>
<li>在主线程中使用同步执行 + 主队列，追加到主线程的任务1、任务2、任务3都不再执行了，而且syncMain—end也没有打印，在XCode 9上还会报崩溃。这是为什么呢？</li>
</ul>
<p>这是因为我们在主线程中执行syncMain方法，相当于把syncMain任务放到了主线程的队列中。而同步执行会等待当前队列中的任务执行完毕，才会接着执行。那么当我们把任务1追加到主队列中，任务1就在等待主线程处理完syncMain任务。而syncMain任务需要等待任务1执行完毕，才能接着执行。</p>
<p>那么，现在的情况就是syncMain任务和任务1都在等对方执行完毕。这样大家互相等待，所以就卡住了，所以我们的任务执行不了，而且syncMain—end也没有打印。</p>
<p><strong>要是如果不在主线程中调用，而在其他线程中调用会如何呢？</strong></p>
<p><strong>4.5.2 在其他线程中调用同步执行 + 主队列</strong></p>
<ul>
<li>不会开启新线程，执行完一个任务，再执行下一个任务</li>
</ul>
<blockquote>
<p>输出结果：</p>
<p>2018-02-23 20:44:19.377321+0800 YSC-GCD-demo[20083:5040347] currentThread—{number = 3, name = (null)}</p>
<p>2018-02-23 20:44:19.377494+0800 YSC-GCD-demo[20083:5040347] syncMain—begin</p>
<p>2018-02-23 20:44:21.384716+0800 YSC-GCD-demo[20083:5040132] 1—{number = 1, name = main}</p>
<p>2018-02-23 20:44:23.386091+0800 YSC-GCD-demo[20083:5040132] 1—{number = 1, name = main}</p>
<p>2018-02-23 20:44:25.387687+0800 YSC-GCD-demo[20083:5040132] 2—{number = 1, name = main}</p>
<p>2018-02-23 20:44:27.388648+0800 YSC-GCD-demo[20083:5040132] 2—{number = 1, name = main}</p>
<p>2018-02-23 20:44:29.390459+0800 YSC-GCD-demo[20083:5040132] 3—{number = 1, name = main}</p>
<p>2018-02-23 20:44:31.391965+0800 YSC-GCD-demo[20083:5040132] 3—{number = 1, name = main}</p>
<p>2018-02-23 20:44:31.392513+0800 YSC-GCD-demo[20083:5040347] syncMain—end</p>
</blockquote>
<p>在其他线程中使用同步执行 + 主队列可看到：</p>
<ul>
<li>所有任务都是在主线程（非当前线程）中执行的，没有开启新的线程（所有放在主队列中的任务，都会放到主线程中执行）。</li>
<li>所有任务都在打印的syncConcurrent—begin和syncConcurrent—end之间执行（同步任务需要等待队列的任务执行结束）。</li>
<li>任务是按顺序执行的（主队列是串行队列，每次只有一个任务被执行，任务一个接一个按顺序执行）。</li>
</ul>
<p><strong>为什么现在就不会卡住了呢？</strong></p>
<p>因为syncMain 任务放到了其他线程里，而任务1、任务2、任务3都在追加到主队列中，这三个任务都会在主线程中执行。syncMain 任务在其他线程中执行到追加任务1到主队列中，因为主队列现在没有正在执行的任务，所以，会直接执行主队列的任务1，等任务1执行完毕，再接着执行任务2、任务3。所以这里不会卡住线程。</p>
<p><strong>4.6 异步执行 + 主队列</strong></p>
<ul>
<li>只在主线程中执行任务，执行完一个任务，再执行下一个任务。</li>
</ul>
<blockquote>
<p>输出结果：</p>
<p>2018-02-23 20:45:49.981505+0800 YSC-GCD-demo[20111:5046708] currentThread—{number = 1, name = main}</p>
<p>2018-02-23 20:45:49.981935+0800 YSC-GCD-demo[20111:5046708] asyncMain—begin</p>
<p>2018-02-23 20:45:49.982352+0800 YSC-GCD-demo[20111:5046708] asyncMain—end</p>
<p>2018-02-23 20:45:51.991096+0800 YSC-GCD-demo[20111:5046708] 1—{number = 1, name = main}</p>
<p>2018-02-23 20:45:53.991959+0800 YSC-GCD-demo[20111:5046708] 1—{number = 1, name = main}</p>
<p>2018-02-23 20:45:55.992937+0800 YSC-GCD-demo[20111:5046708] 2—{number = 1, name = main}</p>
<p>2018-02-23 20:45:57.993649+0800 YSC-GCD-demo[20111:5046708] 2—{number = 1, name = main}</p>
<p>2018-02-23 20:45:59.994928+0800 YSC-GCD-demo[20111:5046708] 3—{number = 1, name = main}</p>
<p>2018-02-23 20:46:01.995589+0800 YSC-GCD-demo[20111:5046708] 3—{number = 1, name = main}</p>
</blockquote>
<p>在异步执行 + 主队列可以看到：</p>
<ul>
<li>所有任务都是在当前线程（主线程）中执行的，并没有开启新的线程（虽然异步执行具备开启线程的能力，但因为是主队列，所以所有任务都在主线程中）。</li>
<li>所有任务是在打印的syncConcurrent—begin和syncConcurrent—end之后才开始执行的（异步执行不会做任何等待，可以继续执行任务）。</li>
<li>任务是按顺序执行的（因为主队列是串行队列，每次只有一个任务被执行，任务一个接一个按顺序执行）。</li>
</ul>
<p>弄懂了难理解、绕来绕去的队列+任务之后，我们来学习一个简单的东西：5. GCD 线程间的通信。</p>
<p><strong>5. GCD 线程间的通信</strong></p>
<p>在 iOS 开发过程中，我们一般在主线程里边进行 UI 刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。</p>
<blockquote>
<p>输出结果：</p>
<p>2018-02-23 20:47:03.462394+0800 YSC-GCD-demo[20154:5053282] 1—{number = 3, name = (null)}</p>
<p>2018-02-23 20:47:05.465912+0800 YSC-GCD-demo[20154:5053282] 1—{number = 3, name = (null)}</p>
<p>2018-02-23 20:47:07.466657+0800 YSC-GCD-demo[20154:5052953] 2—{number = 1, name = main}</p>
</blockquote>
<ul>
<li>可以看到在其他线程中先执行任务，执行完了之后回到主线程执行主线程的相应操作。</li>
</ul>
<p><strong>6. GCD 的其他方法</strong></p>
<p><strong>6.1 GCD 栅栏方法：dispatch_barrier_async</strong></p>
<ul>
<li>我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于 栅栏 一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到dispatch_barrier_async方法在两个操作组间形成栅栏。</li>
</ul>
<p>dispatch_barrier_async函数会等待前边追加到并发队列中的任务全部执行完毕之后，再将指定的任务追加到该异步队列中。然后在dispatch_barrier_async函数追加的任务执行完毕之后，异步队列才恢复为一般动作，接着追加任务到该异步队列并开始执行。具体如下图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/2/24/161c6258a0c04a71?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<blockquote>
<p>输出结果：</p>
<p>2018-02-23 20:48:18.297745+0800 YSC-GCD-demo[20188:5059274] 1—{number = 4, name = (null)}</p>
<p>2018-02-23 20:48:18.297745+0800 YSC-GCD-demo[20188:5059273] 2—{number = 3, name = (null)}</p>
<p>2018-02-23 20:48:20.301139+0800 YSC-GCD-demo[20188:5059274] 1—{number = 4, name = (null)}</p>
<p>2018-02-23 20:48:20.301139+0800 YSC-GCD-demo[20188:5059273] 2—{number = 3, name = (null)}</p>
<p>2018-02-23 20:48:22.306290+0800 YSC-GCD-demo[20188:5059274] barrier—{number = 4, name = (null)}</p>
<p>2018-02-23 20:48:24.311655+0800 YSC-GCD-demo[20188:5059274] barrier—{number = 4, name = (null)}</p>
<p>2018-02-23 20:48:26.316943+0800 YSC-GCD-demo[20188:5059273] 4—{number = 3, name = (null)}</p>
<p>2018-02-23 20:48:26.316956+0800 YSC-GCD-demo[20188:5059274] 3—{number = 4, name = (null)}</p>
<p>2018-02-23 20:48:28.320660+0800 YSC-GCD-demo[20188:5059273] 4—{number = 3, name = (null)}</p>
<p>2018-02-23 20:48:28.320649+0800 YSC-GCD-demo[20188:5059274] 3—{number = 4, name = (null)}</p>
</blockquote>
<p>在dispatch_barrier_async相关代码执行结果中可以看出：</p>
<ul>
<li>在执行完栅栏前面的操作之后，才执行栅栏操作，最后再执行栅栏后边的操作。</li>
</ul>
<p><strong>6.2 GCD 延时执行方法：dispatch_after</strong></p>
<p>我们经常会遇到这样的需求：在指定时间（例如3秒）之后执行某个任务。可以用 GCD 的dispatch_after函数来实现。</p>
<p>需要注意的是：dispatch_after函数并不是在指定时间之后才开始执行处理，而是在指定时间之后将任务追加到主队列中。严格来说，这个时间并不是绝对准确的，但想要大致延迟执行任务，dispatch_after函数是很有效的。</p>
<blockquote>
<p>输出结果：</p>
<p>2018-02-23 20:53:08.713784+0800 YSC-GCD-demo[20282:5080295] currentThread—{number = 1, name = main}</p>
<p>2018-02-23 20:53:08.713962+0800 YSC-GCD-demo[20282:5080295] asyncMain—begin</p>
<p>2018-02-23 20:53:10.714283+0800 YSC-GCD-demo[20282:5080295] after—{number = 1, name = main}</p>
</blockquote>
<p>在dispatch_after相关代码执行结果中可以看出：在打印 asyncMain—begin 之后大约 2.0 秒的时间，打印了 after—{number = 1, name = main}</p>
<p><strong>6.3 GCD 一次性代码（只执行一次）：dispatch_once</strong></p>
<ul>
<li>我们在创建单例、或者有整个程序运行过程中只执行一次的代码时，我们就用到了 GCD 的 dispatch_once 函数。使用dispatch_once 函数能保证某段代码在程序运行过程中只被执行1次，并且即使在多线程的环境下，dispatch_once也可以保证线程安全。</li>
</ul>
<p><strong>6.4 GCD 快速迭代方法：dispatch_apply</strong></p>
<ul>
<li>通常我们会用 for 循环遍历，但是 GCD 给我们提供了快速迭代的函数dispatch_apply。dispatch_apply按照指定的次数将指定的任务追加到指定的队列中，并等待全部队列执行结束。</li>
</ul>
<p>我们可以利用异步队列同时遍历。比如说遍历 0~5 这6个数字，for 循环的做法是每次取出一个元素，逐个遍历。dispatch_apply可以同时遍历多个数字。</p>
<blockquote>
<p>输出结果：</p>
<p>2018-02-23 22:03:18.475499+0800 YSC-GCD-demo[20470:5176805] apply—begin</p>
<p>2018-02-23 22:03:18.476672+0800 YSC-GCD-demo[20470:5177035] 1—{number = 3, name = (null)}</p>
<p>2018-02-23 22:03:18.476693+0800 YSC-GCD-demo[20470:5176805] 0—{number = 1, name = main}</p>
<p>2018-02-23 22:03:18.476704+0800 YSC-GCD-demo[20470:5177037] 2—{number = 4, name = (null)}</p>
<p>2018-02-23 22:03:18.476735+0800 YSC-GCD-demo[20470:5177036] 3—{number = 5, name = (null)}</p>
<p>2018-02-23 22:03:18.476867+0800 YSC-GCD-demo[20470:5177035] 4—{number = 3, name = (null)}</p>
<p>2018-02-23 22:03:18.476867+0800 YSC-GCD-demo[20470:5176805] 5—{number = 1, name = main}</p>
<p>2018-02-23 22:03:18.477038+0800 YSC-GCD-demo[20470:5176805] apply—end</p>
</blockquote>
<p>从dispatch_apply相关代码执行结果中可以看出：</p>
<ul>
<li>0~5 打印顺序不定，最后打印了 apply—end。</li>
</ul>
<p>因为是在并发队列中异步队执行任务，所以各个任务的执行时间长短不定，最后结束顺序也不定。但是apply—end一定在最后执行。这是因为dispatch_apply函数会等待全部任务执行完毕。</p>
<p><strong>6.5 GCD 的队列组：dispatch_group</strong></p>
<p>有时候我们会有这样的需求：分别异步执行2个耗时任务，然后当2个耗时任务都执行完毕后再回到主线程执行任务。这时候我们可以用到 GCD 的队列组。</p>
<ul>
<li>调用队列组的 dispatch_group_async 先把任务放到队列中，然后将队列放入队列组中。或者使用队列组的 dispatch_group_enter、dispatch_group_leave 组合 来实现dispatch_group_async。</li>
<li>调用队列组的 dispatch_group_notify 回到指定线程执行任务。或者使用 dispatch_group_wait 回到当前线程继续向下执行（会阻塞当前线程）。</li>
</ul>
<p><strong>6.5.1 dispatch_group_notify</strong></p>
<ul>
<li>监听 group 中任务的完成状态，当所有的任务都执行完成后，追加任务到 group 中，并执行任务。</li>
</ul>
<blockquote>
<p>输出结果：</p>
<p>2018-02-23 22:05:03.790035+0800 YSC-GCD-demo[20494:5183349] currentThread—{number = 1, name = main}</p>
<p>2018-02-23 22:05:03.790237+0800 YSC-GCD-demo[20494:5183349] group—begin</p>
<p>2018-02-23 22:05:05.792721+0800 YSC-GCD-demo[20494:5183654] 1—{number = 4, name = (null)}</p>
<p>2018-02-23 22:05:05.792725+0800 YSC-GCD-demo[20494:5183656] 2—{number = 3, name = (null)}</p>
<p>2018-02-23 22:05:07.797408+0800 YSC-GCD-demo[20494:5183656] 2—{number = 3, name = (null)}</p>
<p>2018-02-23 22:05:07.797408+0800 YSC-GCD-demo[20494:5183654] 1—{number = 4, name = (null)}</p>
<p>2018-02-23 22:05:09.798717+0800 YSC-GCD-demo[20494:5183349] 3—{number = 1, name = main}</p>
<p>2018-02-23 22:05:11.799827+0800 YSC-GCD-demo[20494:5183349] 3—{number = 1, name = main}</p>
<p>2018-02-23 22:05:11.799977+0800 YSC-GCD-demo[20494:5183349] group—end</p>
</blockquote>
<p>从dispatch_group_notify相关代码运行输出结果可以看出：</p>
<p>当所有任务都执行完成之后，才执行dispatch_group_notify block 中的任务。</p>
<p><strong>6.5.2 dispatch_group_wait</strong></p>
<ul>
<li>暂停当前线程（阻塞当前线程），等待指定的 group 中的任务执行完成后，才会往下继续执行。</li>
</ul>
<blockquote>
<p>输出结果：</p>
<p>2018-02-23 22:10:16.939258+0800 YSC-GCD-demo[20538:5198871] currentThread—{number = 1, name = main}</p>
<p>2018-02-23 22:10:16.939455+0800 YSC-GCD-demo[20538:5198871] group—begin</p>
<p>2018-02-23 22:10:18.943862+0800 YSC-GCD-demo[20538:5199137] 2—{number = 4, name = (null)}</p>
<p>2018-02-23 22:10:18.943861+0800 YSC-GCD-demo[20538:5199138] 1—{number = 3, name = (null)}</p>
<p>2018-02-23 22:10:20.947787+0800 YSC-GCD-demo[20538:5199137] 2—{number = 4, name = (null)}</p>
<p>2018-02-23 22:10:20.947790+0800 YSC-GCD-demo[20538:5199138] 1—{number = 3, name = (null)}</p>
<p>2018-02-23 22:10:20.948134+0800 YSC-GCD-demo[20538:5198871] group—end</p>
</blockquote>
<p>从dispatch_group_wait相关代码运行输出结果可以看出：</p>
<p>当所有任务执行完成之后，才执行 dispatch_group_wait 之后的操作。但是，使用dispatch_group_wait 会阻塞当前线程。</p>
<p><strong>6.5.3 dispatch_group_enter、dispatch_group_leave</strong></p>
<ul>
<li>dispatch_group_enter 标志着一个任务追加到 group，执行一次，相当于 group 中未执行完毕任务数+1</li>
<li>dispatch_group_leave 标志着一个任务离开了 group，执行一次，相当于 group 中未执行完毕任务数-1。</li>
<li>当 group 中未执行完毕任务数为0的时候，才会使dispatch_group_wait解除阻塞，以及执行追加到dispatch_group_notify中的任务。</li>
</ul>
<blockquote>
<p>输出结果：</p>
<p>2018-02-23 22:14:17.997667+0800 YSC-GCD-demo[20592:5214830] currentThread—{number = 1, name = main}</p>
<p>2018-02-23 22:14:17.997839+0800 YSC-GCD-demo[20592:5214830] group—begin</p>
<p>2018-02-23 22:14:20.000298+0800 YSC-GCD-demo[20592:5215094] 1—{number = 4, name = (null)}</p>
<p>2018-02-23 22:14:20.000305+0800 YSC-GCD-demo[20592:5215095] 2—{number = 3, name = (null)}</p>
<p>2018-02-23 22:14:22.001323+0800 YSC-GCD-demo[20592:5215094] 1—{number = 4, name = (null)}</p>
<p>2018-02-23 22:14:22.001339+0800 YSC-GCD-demo[20592:5215095] 2—{number = 3, name = (null)}</p>
<p>2018-02-23 22:14:24.002321+0800 YSC-GCD-demo[20592:5214830] 3—{number = 1, name = main}</p>
<p>2018-02-23 22:14:26.002852+0800 YSC-GCD-demo[20592:5214830] 3—{number = 1, name = main}</p>
<p>2018-02-23 22:14:26.003116+0800 YSC-GCD-demo[20592:5214830] group—end</p>
</blockquote>
<p>从dispatch_group_enter、dispatch_group_leave相关代码运行结果中可以看出：当所有任务执行完成之后，才执行 dispatch_group_notify 中的任务。这里的dispatch_group_enter、dispatch_group_leave组合，其实等同于dispatch_group_async。</p>
<p><strong>6.6 GCD 信号量：dispatch_semaphore</strong></p>
<p>GCD 中的信号量是指<strong> Dispatch Semaphore</strong>，是持有计数的信号。类似于过高速路收费站的栏杆。可以通过时，打开栏杆，不可以通过时，关闭栏杆。在<strong> Dispatch Semaphore </strong>中，使用计数来完成这个功能，计数为0时等待，不可通过。计数为1或大于1时，计数减1且不等待，可通过。<strong>Dispatch Semaphore</strong> 提供了三个函数。</p>
<ul>
<li>dispatch_semaphore_create：创建一个Semaphore并初始化信号的总量</li>
<li>dispatch_semaphore_signal：发送一个信号，让信号总量加1</li>
<li>dispatch_semaphore_wait：可以使总信号量减1，当信号总量为0时就会一直等待（阻塞所在线程），否则就可以正常执行。</li>
</ul>
<blockquote>
<p>注意：信号量的使用前提是：想清楚你需要处理哪个线程等待（阻塞），又要哪个线程继续执行，然后使用信号量。</p>
</blockquote>
<p>Dispatch Semaphore 在实际开发中主要用于：</p>
<ul>
<li>保持线程同步，将异步执行任务转换为同步执行任务</li>
<li>保证线程安全，为线程加锁</li>
</ul>
<p><strong>6.6.1 Dispatch Semaphore 线程同步</strong></p>
<p>我们在开发中，会遇到这样的需求：异步执行耗时任务，并使用异步执行的结果进行一些额外的操作。换句话说，相当于，将将异步执行任务转换为同步执行任务。比如说：AFNetworking 中 AFURLSessionManager.m 里面的 tasksForKeyPath: 方法。通过引入信号量的方式，等待异步执行任务结果，获取到 tasks，然后再返回该 tasks。</p>
<p>下面，我们来利用 Dispatch Semaphore 实现线程同步，将异步执行任务转换为同步执行任务。</p>
<blockquote>
<p>输出结果：</p>
<p>2018-02-23 22:22:26.521665+0800 YSC-GCD-demo[20642:5246341] currentThread—{number = 1, name = main}</p>
<p>2018-02-23 22:22:26.521869+0800 YSC-GCD-demo[20642:5246341] semaphore—begin</p>
<p>2018-02-23 22:22:28.526841+0800 YSC-GCD-demo[20642:5246638] 1—{number = 3, name = (null)}</p>
<p>2018-02-23 22:22:28.527030+0800 YSC-GCD-demo[20642:5246341] semaphore—end,number = 100</p>
</blockquote>
<p>从 Dispatch Semaphore 实现线程同步的代码可以看到：</p>
<ul>
<li>semaphore—end 是在执行完  number = 100; 之后才打印的。而且输出结果 number 为 100。这是因为异步执行不会做任何等待，可以继续执行任务。异步执行将任务1追加到队列之后，不做等待，接着执行dispatch_semaphore_wait方法。此时 semaphore == 0，当前线程进入等待状态。然后，异步任务1开始执行。任务1执行到dispatch_semaphore_signal之后，总信号量，此时 semaphore == 1，dispatch_semaphore_wait方法使总信号量减1，正在被阻塞的线程（主线程）恢复继续执行。最后打印semaphore—end,number = 100。这样就实现了线程同步，将异步执行任务转换为同步执行任务。</li>
</ul>
<p><strong>6.6.2 Dispatch Semaphore 线程安全和线程同步（为线程加锁）</strong></p>
<p><strong>线程安全</strong>：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<p>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。</p>
<p><strong>线程同步</strong>：可理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。</p>
<p>举个简单例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清(操作冲突)。等一个人说完(一个线程结束操作)，另一个再说(另一个线程再开始操作)。</p>
<p>下面，我们模拟火车票售卖的方式，实现 NSThread 线程安全和解决线程同步问题。</p>
<p>场景：总共有50张火车票，有两个售卖火车票的窗口，一个是北京火车票售卖窗口，另一个是上海火车票售卖窗口。两个窗口同时售卖火车票，卖完为止。</p>
<p><strong>6.6.2.1 非线程安全（不使用 semaphore）</strong></p>
<p>先来看看不考虑线程安全的代码：</p>
<blockquote>
<p>输出结果（部分）：</p>
<p>2018-02-23 22:25:35.789072+0800 YSC-GCD-demo[20712:5258914] currentThread—{number = 1, name = main}</p>
<p>2018-02-23 22:25:35.789260+0800 YSC-GCD-demo[20712:5258914] semaphore—begin</p>
<p>2018-02-23 22:25:35.789641+0800 YSC-GCD-demo[20712:5259176] 剩余票数：48 窗口：{number = 3, name = (null)}</p>
<p>2018-02-23 22:25:35.789646+0800 YSC-GCD-demo[20712:5259175] 剩余票数：49 窗口：{number = 4, name = (null)}</p>
<p>2018-02-23 22:25:35.994113+0800 YSC-GCD-demo[20712:5259175] 剩余票数：47 窗口：{number = 4, name = (null)}</p>
<p>2018-02-23 22:25:35.994129+0800 YSC-GCD-demo[20712:5259176] 剩余票数：46 窗口：{number = 3, name = (null)}</p>
<p>2018-02-23 22:25:36.198993+0800 YSC-GCD-demo[20712:5259176] 剩余票数：45 窗口：{number = 3, name = (null)}</p>
<p>……</p>
</blockquote>
<p>可以看到在不考虑线程安全，不使用 semaphore 的情况下，得到票数是错乱的，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。</p>
<p><strong>6.6.2.2 线程安全（使用 semaphore 加锁）</strong></p>
<p>考虑线程安全的代码：</p>
<blockquote>
<p>输出结果为：</p>
<p>2018-02-23 22:32:19.814232+0800 YSC-GCD-demo[20862:5290531] currentThread—{number = 1, name = main}</p>
<p>2018-02-23 22:32:19.814412+0800 YSC-GCD-demo[20862:5290531] semaphore—begin</p>
<p>2018-02-23 22:32:19.814837+0800 YSC-GCD-demo[20862:5290687] 剩余票数：49 窗口：{number = 3, name = (null)}</p>
<p>2018-02-23 22:32:20.017745+0800 YSC-GCD-demo[20862:5290689] 剩余票数：48 窗口：{number = 4, name = (null)}</p>
<p>2018-02-23 22:32:20.222039+0800 YSC-GCD-demo[20862:5290687] 剩余票数：47 窗口：{number = 3, name = (null)}</p>
<p>……</p>
<p>2018-02-23 22:32:29.024817+0800 YSC-GCD-demo[20862:5290689] 剩余票数：4 窗口：{number = 4, name = (null)}</p>
<p>2018-02-23 22:32:29.230110+0800 YSC-GCD-demo[20862:5290687] 剩余票数：3 窗口：{number = 3, name = (null)}</p>
<p>2018-02-23 22:32:29.433615+0800 YSC-GCD-demo[20862:5290689] 剩余票数：2 窗口：{number = 4, name = (null)}</p>
<p>2018-02-23 22:32:29.637572+0800 YSC-GCD-demo[20862:5290687] 剩余票数：1 窗口：{number = 3, name = (null)}</p>
<p>2018-02-23 22:32:29.840234+0800 YSC-GCD-demo[20862:5290689] 剩余票数：0 窗口：{number = 4, name = (null)}</p>
<p>2018-02-23 22:32:30.044960+0800 YSC-GCD-demo[20862:5290687] 所有火车票均已售完</p>
<p>2018-02-23 22:32:30.045260+0800 YSC-GCD-demo[20862:5290689] 所有火车票均已售完</p>
</blockquote>
<p>可以看出，在考虑了线程安全的情况下，使用 dispatch_semaphore 机制之后，得到的票数是正确的，没有出现混乱的情况。我们也就解决了多个线程同步的问题。</p>
<p><a href="https://juejin.im/post/5a90de68f265da4e9b592b40" target="_blank" rel="noopener">转自 <a href="https://juejin.im/user/5a43aed3f265da4318770885" target="_blank" rel="noopener">行走的少年郎</a></a></p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/09/17/iOS-Block用法和实现原理/" rel="next" title="iOS Block用法和实现原理">
                <i class="fa fa-chevron-left"></i> iOS Block用法和实现原理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/09/17/线程安全/" rel="prev" title="线程安全">
                线程安全 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Sun Lei</p>
              <p class="site-description motion-element" itemprop="description">只有用心才能看清楚·真正重要的东西·用眼睛是看不见的</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">23</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sun Lei</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.4.4</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Muse</a> v6.4.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.1"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
